use alloc::boxed::Box;

use p3_baby_bear::BabyBear;
use sp1_stark::*;
use thiserror::Error;

pub mod internal;

use internal::{verify_sp1_proof, verify_sp1_reduce_proof, F, SC};

/// A reason why the verifier rejects a given proof.
#[derive(Debug, Error)]
#[non_exhaustive]
pub enum CompressedError {
    #[error("failed to deserialize proof: {0}")]
    DeserializeProof(Box<bincode::ErrorKind>),
    #[error("unexpected proof mode: expected {exp:?}, got {0:?}", exp = SP1ProofMode::Compressed)]
    Mode(SP1ProofMode),
    #[error("failed to deserialize vkey hash: {0}")]
    DeserializeVkeyHash(Box<bincode::ErrorKind>),
    #[error("failed to verify proof: {0}")]
    ProofRejected(#[from] MachineVerificationError<SC>),
    #[error("single-shard proofs are currently unsupported by this verifier")]
    SingleShard,
    #[error("given public values do not match the commitment in the proof")]
    PublicValuesMismatch,
}

/// A verifier for SP1 "compressed" proofs.
#[derive(Debug)]
pub struct CompressedVerifier;
impl CompressedVerifier {
    /// Attempts to verify an SP1 "compressed" proof, as generated by the SP1 SDK.
    /// Returns `Ok` if the proof verifies or `Err` with the reason that verification failed.
    ///
    /// Due to technical limitations, this verifier rejects single-shard proofs, which roughly means
    /// proofs that come from very short programs. In this case, the verifier returns
    /// `Err(CompressedError::SingleShard)`.
    ///
    /// # Arguments
    ///
    /// * `proof` - The proof bytes.
    /// * `sp1_vkey_hash` - The SP1 vkey hash.
    ///
    /// The arguments may be generated in the following manner:
    ///
    /// ```ignore
    /// use sp1_sdk::{HashableKey, ProverClient, SP1Proof};
    /// let client = ProverClient::builder().cpu().build();
    /// let (pk, vk) = client.setup(ELF);
    /// let sp1_vkey_hash = bincode::serialize(&vk.hash_babybear()).unwrap();
    /// let proof: SP1Proof = match client.prove(&pk, &stdin).compressed().run().unwrap().proof;
    /// ```
    pub fn verify_sp1_proof(
        sp1_proof: &[u8],
        sp1_public_inputs: &[u8],
        sp1_vkey_hash: &[u8],
    ) -> Result<(), CompressedError> {
        let sp1_proof: SP1Proof =
            bincode::deserialize(sp1_proof).map_err(CompressedError::DeserializeProof)?;
        let vkey_hash: [F; 8] = deserialize_vkey(sp1_vkey_hash)?;

        verify_sp1_proof(&sp1_proof, sp1_public_inputs, &vkey_hash)?;

        Ok(())
    }
    pub fn verify_sp1_reduce_proof(
        sp1_reduce_proof: &[u8],
        sp1_public_inputs: &[u8],
        sp1_vkey_hash: &[u8],
    ) -> Result<(), CompressedError> {
        let reduce_proof: Box<SP1ReduceProof<SC>> =
            bincode::deserialize(sp1_reduce_proof).map_err(CompressedError::DeserializeProof)?;
        let vkey_hash: [F; 8] = deserialize_vkey(sp1_vkey_hash)?;

        verify_sp1_reduce_proof(reduce_proof.as_ref(), sp1_public_inputs, &vkey_hash)?;

        Ok(())
    }
}

fn deserialize_vkey(sp1_vkey_hash: &[u8]) -> Result<[BabyBear; 8], CompressedError> {
    bincode::deserialize(sp1_vkey_hash).map_err(CompressedError::DeserializeVkeyHash)
}
