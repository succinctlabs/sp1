use alloc::{boxed::Box, vec, vec::Vec};
use core::borrow::Borrow;

use p3_baby_bear::BabyBear;
use p3_field::{AbstractField, PrimeField32, TwoAdicField};
use p3_symmetric::CryptographicHasher;
use sp1_primitives::poseidon2_hash;
use sp1_recursion_core::{
    air::{RecursionPublicValues, NUM_PV_ELMS_TO_HASH},
    machine::RecursionAir,
};
use sp1_stark::{baby_bear_poseidon2::BabyBearPoseidon2, *};
use thiserror::Error;

pub mod internal;

pub use internal::*;

/// A reason why the verifier rejects a given proof.
#[derive(Debug, Error)]
#[non_exhaustive]
pub enum CompressedError {
    #[error("failed to deserialize proof: {0}")]
    DeserializeProof(Box<bincode::ErrorKind>),
    #[error("unexpected proof mode: expected {exp:?}, got {0:?}", exp = SP1ProofMode::Compressed)]
    Mode(SP1ProofMode),
    #[error("failed to deserialize vkey hash: {0}")]
    DeserializeVkeyHash(Box<bincode::ErrorKind>),
    #[error("failed to verify proof: {0}")]
    ProofRejected(#[from] MachineVerificationError<SC>),
    #[error("single-shard proofs are currently unsupported by this verifier")]
    SingleShard,
    #[error("given public values do not match the commitment in the proof")]
    PublicValuesMismatch,
}

/// A verifier for SP1 "compressed" proofs.
#[derive(Debug)]
pub struct CompressedVerifier;
impl CompressedVerifier {
    /// Attempts to verify an SP1 "compressed" proof, as generated by the SP1 SDK.
    /// Returns `Ok` if the proof verifies or `Err` with the reason that verification failed.
    ///
    /// Due to technical limitations, this verifier rejects single-shard proofs, which roughly means
    /// proofs that come from very short programs. In this case, the verifier returns
    /// `Err(CompressedError::SingleShard)`.
    ///
    /// # Arguments
    ///
    /// * `proof` - The proof bytes.
    /// * `sp1_vkey_hash` - The SP1 vkey hash.
    ///
    /// The arguments may be generated in the following manner:
    ///
    /// ```ignore
    /// use sp1_sdk::{HashableKey, ProverClient, SP1Proof};
    /// let client = ProverClient::builder().cpu().build();
    /// let (pk, vk) = client.setup(ELF);
    /// let sp1_vkey_hash = bincode::serialize(&vk.hash_babybear()).unwrap();
    /// let proof: SP1Proof = match client.prove(&pk, &stdin).compressed().run().unwrap().proof;
    /// ```
    pub fn verify_sp1_proof(
        proof: &[u8],
        sp1_public_inputs: &[u8],
        sp1_vkey_hash: &[u8],
    ) -> Result<(), CompressedError> {
        let sp1_proof: SP1Proof =
            bincode::deserialize(proof).map_err(CompressedError::DeserializeProof)?;
        let SP1Proof::Compressed(reduce_proof) = sp1_proof else {
            return Err(CompressedError::Mode(sp1_proof.into()));
        };
        let vkey_hash: [F; 8] =
            bincode::deserialize(sp1_vkey_hash).map_err(CompressedError::DeserializeVkeyHash)?;

        verify_sp1_reduce_proof(&reduce_proof, sp1_public_inputs, &vkey_hash)?;

        Ok(())
    }
}
