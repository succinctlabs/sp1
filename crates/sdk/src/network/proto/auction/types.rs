// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedMessage {
    /// The message.
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    /// The signature.
    #[prost(string, tag = "2")]
    pub signature: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetWithdrawParamsRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWithdrawParamsResponse {
    /// The default auctioneer address.
    #[prost(bytes = "vec", tag = "1")]
    pub auctioneer: ::prost::alloc::vec::Vec<u8>,
    /// The default withdraw fee.
    #[prost(string, tag = "2")]
    pub fee: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTransferParamsRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransferParamsResponse {
    /// The default auctioneer address.
    #[prost(bytes = "vec", tag = "1")]
    pub auctioneer: ::prost::alloc::vec::Vec<u8>,
    /// The default transfer fee.
    #[prost(string, tag = "2")]
    pub fee: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<WithdrawRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawRequestBody {
    /// The nonce of the request.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The account address to withdraw from. If not a prover, must be the signing account.
    #[prost(bytes = "vec", tag = "2")]
    pub account: ::prost::alloc::vec::Vec<u8>,
    /// The amount to withdraw.
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    /// The domain separator bytes for the request.
    #[prost(bytes = "vec", tag = "4")]
    pub domain: ::prost::alloc::vec::Vec<u8>,
    /// The variant of the transaction.
    #[prost(enumeration = "TransactionVariant", tag = "5")]
    pub variant: i32,
    /// The auctioneer address that will receive the fee.
    #[prost(bytes = "vec", tag = "6")]
    pub auctioneer: ::prost::alloc::vec::Vec<u8>,
    /// The fee to pay for the withdrawal operation.
    #[prost(string, tag = "7")]
    pub fee: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WithdrawResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<WithdrawResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RequestProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The version of the prover to use.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// The mode for the request.
    #[prost(enumeration = "ProofMode", tag = "4")]
    pub mode: i32,
    /// The strategy for fulfiller assignment.
    #[prost(enumeration = "FulfillmentStrategy", tag = "5")]
    pub strategy: i32,
    /// The stdin resource identifier.
    #[prost(string, tag = "6")]
    pub stdin_uri: ::prost::alloc::string::String,
    /// The deadline for the request.
    #[prost(uint64, tag = "7")]
    pub deadline: u64,
    /// The cycle limit for the request.
    #[prost(uint64, tag = "8")]
    pub cycle_limit: u64,
    /// The gas limit for the request. If 0, the cycle_limit is used.
    #[prost(uint64, tag = "9")]
    pub gas_limit: u64,
    /// The minimum period a request can be in auction in seconds. Zero indicates no minimum. Only
    /// applicable if the strategy is auction.
    #[prost(uint64, tag = "10")]
    pub min_auction_period: u64,
    /// The whitelist of provers that can bid and prove this request. An empty list indicates that
    /// any prover can participate. Only applicable if the strategy is auction.
    #[prost(bytes = "vec", repeated, tag = "11")]
    pub whitelist: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// The domain separator bytes for the request.
    #[prost(bytes = "vec", tag = "12")]
    pub domain: ::prost::alloc::vec::Vec<u8>,
    /// The auctioneer address.
    #[prost(bytes = "vec", tag = "13")]
    pub auctioneer: ::prost::alloc::vec::Vec<u8>,
    /// The executor address.
    #[prost(bytes = "vec", tag = "14")]
    pub executor: ::prost::alloc::vec::Vec<u8>,
    /// The verifier address.
    #[prost(bytes = "vec", tag = "15")]
    pub verifier: ::prost::alloc::vec::Vec<u8>,
    /// The optional public values hash.
    #[prost(bytes = "vec", optional, tag = "16")]
    pub public_values_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The base fee for the request.
    #[prost(string, tag = "17")]
    pub base_fee: ::prost::alloc::string::String,
    /// The max price per prover gas unit for the request.
    #[prost(string, tag = "18")]
    pub max_price_per_pgu: ::prost::alloc::string::String,
    /// The variant of the transaction.
    #[prost(enumeration = "TransactionVariant", tag = "19")]
    pub variant: i32,
    /// The treasury address.
    #[prost(bytes = "vec", tag = "20")]
    pub treasury: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RequestProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestProofResponseBody {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReservedMetadata {
    /// The optional ratio of gpu time the proof used on-demand resources versus reserved.
    #[prost(float, optional, tag = "1")]
    pub on_demand_ratio: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FulfillProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<FulfillProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FulfillProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The proof bytes.
    #[prost(bytes = "vec", tag = "3")]
    pub proof: ::prost::alloc::vec::Vec<u8>,
    /// The optional metadata for reserved proofs.
    #[prost(message, optional, tag = "4")]
    pub reserved_metadata: ::core::option::Option<ReservedMetadata>,
    /// The domain separator for the request.
    #[prost(bytes = "vec", tag = "5")]
    pub domain: ::prost::alloc::vec::Vec<u8>,
    /// The variant of the transaction.
    #[prost(enumeration = "TransactionVariant", tag = "6")]
    pub variant: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FulfillProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<FulfillProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FulfillProofResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<ExecuteProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "3")]
    pub execution_status: i32,
    /// The optional public values hash of the request execution, only included if
    /// the request is valid.
    #[prost(bytes = "vec", optional, tag = "4")]
    pub public_values_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional cycles used when executing the request, only included if the
    /// request is valid.
    #[prost(uint64, optional, tag = "5")]
    pub cycles: ::core::option::Option<u64>,
    /// The optional amount of gas used when executing the request, only included if
    /// the request is valid.
    #[prost(uint64, optional, tag = "6")]
    pub pgus: ::core::option::Option<u64>,
    /// The domain separator for the request.
    #[prost(bytes = "vec", tag = "7")]
    pub domain: ::prost::alloc::vec::Vec<u8>,
    /// The punishment amount for the requester.
    #[prost(string, optional, tag = "8")]
    pub punishment: ::core::option::Option<::prost::alloc::string::String>,
    /// The cause of execution failure, if it failed.
    #[prost(enumeration = "ExecuteFailureCause", optional, tag = "9")]
    pub failure_cause: ::core::option::Option<i32>,
    /// The variant of the transaction.
    #[prost(enumeration = "TransactionVariant", tag = "10")]
    pub variant: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<ExecuteProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExecuteProofResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailFulfillmentRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<FailFulfillmentRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailFulfillmentRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The optional proof request error.
    #[prost(enumeration = "ProofRequestError", optional, tag = "3")]
    pub error: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailFulfillmentResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<FailFulfillmentResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FailFulfillmentResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelRequestRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<CancelRequestRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelRequestRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request to cancel.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelRequestResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<CancelRequestResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CancelRequestResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProofRequest {
    /// The request identifier.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The version of the prover to use.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// The mode for the proof.
    #[prost(enumeration = "ProofMode", tag = "4")]
    pub mode: i32,
    /// The strategy for fulfiller assignment.
    #[prost(enumeration = "FulfillmentStrategy", tag = "5")]
    pub strategy: i32,
    /// The program resource identifier.
    #[prost(string, tag = "6")]
    pub program_uri: ::prost::alloc::string::String,
    /// The stdin resource identifier.
    #[prost(string, tag = "7")]
    pub stdin_uri: ::prost::alloc::string::String,
    /// The deadline for the request.
    #[prost(uint64, tag = "8")]
    pub deadline: u64,
    /// The cycle limit for the request.
    #[prost(uint64, tag = "9")]
    pub cycle_limit: u64,
    /// The gas price for the request.
    #[prost(uint64, optional, tag = "10")]
    pub gas_price: ::core::option::Option<u64>,
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "11")]
    pub fulfillment_status: i32,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "12")]
    pub execution_status: i32,
    /// The requester address that signed the request.
    #[prost(bytes = "vec", tag = "13")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
    /// The fulfiller address that fulfilled the request.
    #[prost(bytes = "vec", optional, tag = "14")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional name to refer to an alias of the program id.
    #[prost(string, optional, tag = "15")]
    pub program_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the requester address.
    #[prost(string, optional, tag = "16")]
    pub requester_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "17")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the request was created.
    #[prost(uint64, tag = "18")]
    pub created_at: u64,
    /// The unix timestamp of when the request was updated.
    #[prost(uint64, tag = "19")]
    pub updated_at: u64,
    /// The unix timestamp of when the request was fulfilled. Only included if
    /// the request has a fulfillment status of FULFILLED.
    #[prost(uint64, optional, tag = "20")]
    pub fulfilled_at: ::core::option::Option<u64>,
    /// The transaction hash of the request.
    #[prost(bytes = "vec", tag = "21")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The cycle used during the execution of the request. Only included if the
    /// request has an execution status of EXECUTED.
    #[prost(uint64, optional, tag = "22")]
    pub cycles: ::core::option::Option<u64>,
    /// The public values hash from the execution of the request. Only included if
    /// the request has an execution status of EXECUTED.
    #[prost(bytes = "vec", optional, tag = "23")]
    pub public_values_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The amount deducted from the fulfiller's balance. Only included if the
    /// request has a fulfillment status of ASSIGNED.
    #[prost(string, optional, tag = "24")]
    pub deduction_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// The amount refunded to the fulfiller's balance. Only included if the
    /// request has a fulfillment status of EXECUTED.
    #[prost(string, optional, tag = "25")]
    pub refund_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// The gas limit for the request.
    #[prost(uint64, tag = "26")]
    pub gas_limit: u64,
    /// The amount of gas used for the request.
    #[prost(uint64, optional, tag = "27")]
    pub gas_used: ::core::option::Option<u64>,
    /// The cause of execution failure, if any.
    #[prost(enumeration = "ExecuteFailureCause", tag = "28")]
    pub execute_fail_cause: i32,
    /// The settlement status of the request.
    #[prost(enumeration = "SettlementStatus", tag = "29")]
    pub settlement_status: i32,
    /// The public program resource identifier.
    #[prost(string, tag = "30")]
    pub program_public_uri: ::prost::alloc::string::String,
    /// The public stdin resource identifier.
    #[prost(string, tag = "31")]
    pub stdin_public_uri: ::prost::alloc::string::String,
    /// The minimum period a request can be in auction in seconds. Zero indicates no minimum. Only
    /// applicable if the strategy is auction.
    #[prost(uint64, tag = "32")]
    pub min_auction_period: u64,
    /// The whitelist of provers that can bid and prove this request. An empty list indicates that
    /// any prover can participate. Only applicable if the strategy is auction.
    #[prost(bytes = "vec", repeated, tag = "33")]
    pub whitelist: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// The base fee for the request.
    #[prost(string, optional, tag = "34")]
    pub base_fee: ::core::option::Option<::prost::alloc::string::String>,
    /// The max price per prover gas unit for the request.
    #[prost(string, optional, tag = "35")]
    pub max_price_per_pgu: ::core::option::Option<::prost::alloc::string::String>,
    /// The proof request error, if any.
    #[prost(enumeration = "ProofRequestError", tag = "36")]
    pub error: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestStatusRequest {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestStatusResponse {
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "1")]
    pub fulfillment_status: i32,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "2")]
    pub execution_status: i32,
    /// The transaction hash of the request.
    #[prost(bytes = "vec", tag = "3")]
    pub request_tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The deadline of the request. A request should be ignored if it is past
    /// its deadline.
    #[prost(uint64, tag = "4")]
    pub deadline: u64,
    /// The optional transaction hash of the proof fulfill. Only included if the
    /// request has a fulfillment status of FULFILLED.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub fulfill_tx_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional proof URI, where you can download the result of the request.
    /// Only included if the request has a fulfillment status of FULFILLED.
    #[prost(string, optional, tag = "6")]
    pub proof_uri: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional public values hash from the execution of the request. Only
    /// included if the request has an execution status of EXECUTED.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub public_values_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional public proof URI, where you can download the result of the
    /// request. Only included if the request has a fulfillment status of FULFILLED.
    #[prost(string, optional, tag = "8")]
    pub proof_public_uri: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestDetailsRequest {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestDetailsResponse {
    /// The detailed request.
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<ProofRequest>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProofRequestsRequest {
    /// The optional version of the requests to filter for.
    #[prost(string, optional, tag = "1")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional fulfillment status of the requests to filter for.
    #[prost(enumeration = "FulfillmentStatus", optional, tag = "2")]
    pub fulfillment_status: ::core::option::Option<i32>,
    /// The optional execution status of the requests to filter for.
    #[prost(enumeration = "ExecutionStatus", optional, tag = "3")]
    pub execution_status: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp deadline of the requests to filter for.
    /// Only returns requests with deadlines after this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub minimum_deadline: ::core::option::Option<u64>,
    /// The optional verification key hash of the program to filter for.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub vk_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional requester address to filter for.
    #[prost(bytes = "vec", optional, tag = "6")]
    pub requester: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional fulfiller address to filter for.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional minimum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "8")]
    pub from: ::core::option::Option<u64>,
    /// The optional maximum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "9")]
    pub to: ::core::option::Option<u64>,
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "10")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "11")]
    pub page: ::core::option::Option<u32>,
    /// The optional mode of the requests to filter for.
    #[prost(enumeration = "ProofMode", optional, tag = "12")]
    pub mode: ::core::option::Option<i32>,
    /// The optional bidder address to filter out. Only returns requests that
    /// have not been bid by this address.
    #[prost(bytes = "vec", optional, tag = "13")]
    pub not_bid_by: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional cause of execution failure.
    #[prost(enumeration = "ExecuteFailureCause", optional, tag = "14")]
    pub execute_fail_cause: ::core::option::Option<i32>,
    /// The optional settlement status of the requests to filter for.
    #[prost(enumeration = "SettlementStatus", optional, tag = "15")]
    pub settlement_status: ::core::option::Option<i32>,
    /// The optional proof request error.
    #[prost(enumeration = "ProofRequestError", optional, tag = "16")]
    pub error: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProofRequestsResponse {
    /// The requests that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<ProofRequest>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSearchResultsRequest {
    /// The search query string.
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResult {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSearchResultsResponse {
    /// List of matching request IDs with optional names.
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<SearchResult>,
    /// List of matching program IDs with optional names.
    #[prost(message, repeated, tag = "2")]
    pub programs: ::prost::alloc::vec::Vec<SearchResult>,
    /// List of matching requester IDs with optional names.
    #[prost(message, repeated, tag = "3")]
    pub requesters: ::prost::alloc::vec::Vec<SearchResult>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestMetricsRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetProofRequestMetricsResponse {
    /// The total number of proofs.
    #[prost(uint64, tag = "1")]
    pub total_proofs: u64,
    /// The total number of programs.
    #[prost(uint64, tag = "4")]
    pub total_programs: u64,
    /// The total number of PGUs.
    #[prost(uint64, tag = "5")]
    pub total_gas: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestGraphRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional interval in days for the graph range.
    #[prost(uint64, optional, tag = "2")]
    pub range_interval_days: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphData {
    /// The timestamp of the data point.
    #[prost(string, tag = "1")]
    pub timestamp: ::prost::alloc::string::String,
    /// The value at this timestamp.
    #[prost(uint64, tag = "2")]
    pub value: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestGraphResponse {
    /// The time series data points.
    #[prost(message, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<GraphData>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnalyticsGraphsRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional interval in days for the graph range.
    #[prost(uint64, optional, tag = "2")]
    pub range_interval_days: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnalyticsGraphsResponse {
    /// The daily time series data points for auction success rate.
    #[prost(message, repeated, tag = "4")]
    pub auction_success_rate: ::prost::alloc::vec::Vec<GraphData>,
    /// The daily time series data points for proof count.
    #[prost(message, repeated, tag = "5")]
    pub proofs: ::prost::alloc::vec::Vec<GraphData>,
    /// The daily time series data points for PROVE / M gas ratio.
    #[prost(message, repeated, tag = "6")]
    pub rewards_mgas: ::prost::alloc::vec::Vec<GraphData>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOverviewGraphsRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOverviewGraphsResponse {
    /// The daily time series data points for proof count.
    #[prost(message, repeated, tag = "1")]
    pub proofs: ::prost::alloc::vec::Vec<GraphData>,
    /// The daily time series data points for program count.
    #[prost(message, repeated, tag = "3")]
    pub programs: ::prost::alloc::vec::Vec<GraphData>,
    /// The daily time series data points for PGU count.
    #[prost(message, repeated, tag = "4")]
    pub gas: ::prost::alloc::vec::Vec<GraphData>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetProofRequestParamsRequest {
    /// The mode for the request.
    #[prost(enumeration = "ProofMode", tag = "1")]
    pub mode: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestParamsResponse {
    /// The domain separator bytes.
    #[prost(bytes = "vec", tag = "1")]
    pub domain: ::prost::alloc::vec::Vec<u8>,
    /// The default auctioneer address.
    #[prost(bytes = "vec", tag = "2")]
    pub auctioneer: ::prost::alloc::vec::Vec<u8>,
    /// The default executor address.
    #[prost(bytes = "vec", tag = "3")]
    pub executor: ::prost::alloc::vec::Vec<u8>,
    /// The default verifier address.
    #[prost(bytes = "vec", tag = "4")]
    pub verifier: ::prost::alloc::vec::Vec<u8>,
    /// The default max price per prover gas unit.
    #[prost(string, tag = "5")]
    pub max_price_per_pgu: ::prost::alloc::string::String,
    /// The base fee for the specified proof mode.
    #[prost(string, tag = "6")]
    pub base_fee: ::prost::alloc::string::String,
    /// The default treasury address.
    #[prost(bytes = "vec", tag = "7")]
    pub treasury: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNonceRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetNonceResponse {
    /// The nonce of the account.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAccountNameRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetAccountNameRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAccountNameRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the account to update the name of. Only the sender can
    /// update the name unless authorized.
    #[prost(bytes = "vec", tag = "2")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The name of the account. Must be unique.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAccountNameResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetAccountNameResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetAccountNameResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountNameRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountNameResponse {
    /// The name of the account.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOwnerRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOwnerResponse {
    /// The owner of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTermsSignatureRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTermsSignatureResponse {
    /// Whether the account has signed the terms.
    #[prost(bool, tag = "1")]
    pub is_signed: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetTermsSignatureRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The message accepting the terms of service.
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetTermsSignatureResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Account {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The custom name of the account (optional).
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter handle of the account (optional).
    #[prost(string, optional, tag = "3")]
    pub twitter_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter name of the account (optional).
    #[prost(string, optional, tag = "4")]
    pub twitter_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter username of the account (optional).
    #[prost(string, optional, tag = "5")]
    pub twitter_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter image of the account (optional).
    #[prost(string, optional, tag = "6")]
    pub twitter_image: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether the account wants to use their twitter handle to set their name.
    #[prost(bool, tag = "7")]
    pub use_twitter_handle: bool,
    /// Whether the account wants to use their twitter image to set their image.
    #[prost(bool, tag = "8")]
    pub use_twitter_image: bool,
    /// Whether the account is sanctioned.
    #[prost(bool, tag = "32")]
    pub is_sanctioned: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountResponse {
    /// The account details.
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Account>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTeeWhitelistStatusRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTeeWhitelistStatusResponse {
    /// The whitelist status.
    #[prost(bool, tag = "1")]
    pub is_whitelisted: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Program {
    /// The verification key hash.
    #[prost(bytes = "vec", tag = "1")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The verification key.
    #[prost(bytes = "vec", tag = "2")]
    pub vk: ::prost::alloc::vec::Vec<u8>,
    /// The program resource identifier.
    #[prost(string, tag = "3")]
    pub program_uri: ::prost::alloc::string::String,
    /// The optional name of the program.
    #[prost(string, optional, tag = "4")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The owner of the program.
    #[prost(bytes = "vec", tag = "5")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    /// The unix timestamp of when the program was created.
    #[prost(uint64, tag = "6")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProgramRequest {
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "1")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProgramResponse {
    /// The program details.
    #[prost(message, optional, tag = "1")]
    pub program: ::core::option::Option<Program>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProgramRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<CreateProgramRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProgramRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The verification key hash.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The verification key.
    #[prost(bytes = "vec", tag = "3")]
    pub vk: ::prost::alloc::vec::Vec<u8>,
    /// The program resource identifier.
    #[prost(string, tag = "4")]
    pub program_uri: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProgramResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<CreateProgramResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateProgramResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetProgramNameRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetProgramNameRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetProgramNameRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier of the program to update the name of. Only the original
    /// program creator can update the name unless authorized.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The name of the program. Must be unique.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetProgramNameResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetProgramNameResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetProgramNameResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceResponse {
    /// The amount of credits owned by the account.
    #[prost(string, tag = "1")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BalanceLog {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The type of balance change operation.
    #[prost(enumeration = "BalanceOperation", tag = "2")]
    pub operation: i32,
    /// The amount of the change (can be positive or negative).
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    /// The transaction hash that caused this change.
    #[prost(bytes = "vec", tag = "4")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The unix timestamp of when this change occurred.
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBalanceLogsRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional type of operations to filter for.
    #[prost(enumeration = "BalanceOperation", optional, tag = "2")]
    pub operation: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp to filter logs from. Only returns
    /// logs after this timestamp.
    #[prost(uint64, optional, tag = "3")]
    pub minimum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum unix timestamp to filter logs to. Only returns
    /// logs before this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub maximum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum number of logs to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "5")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "6")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBalanceLogsResponse {
    /// The balance logs that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub logs: ::prost::alloc::vec::Vec<BalanceLog>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<TransferRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the recipient account to transfer credits to.
    #[prost(bytes = "vec", tag = "2")]
    pub to: ::prost::alloc::vec::Vec<u8>,
    /// The amount of credits to transfer.
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    /// The domain separator bytes for the request.
    #[prost(bytes = "vec", tag = "4")]
    pub domain: ::prost::alloc::vec::Vec<u8>,
    /// The variant of the transaction.
    #[prost(enumeration = "TransactionVariant", tag = "5")]
    pub variant: i32,
    /// The auctioneer address that will receive the fee.
    #[prost(bytes = "vec", tag = "6")]
    pub auctioneer: ::prost::alloc::vec::Vec<u8>,
    /// The fee to pay for the transfer operation.
    #[prost(string, tag = "7")]
    pub fee: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<TransferResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TransferResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLatestBridgeBlockRequest {
    /// The chain ID of the bridge.
    #[prost(uint32, tag = "1")]
    pub chain_id: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLatestBridgeBlockResponse {
    /// The latest processed block in the bridge.
    #[prost(uint64, tag = "1")]
    pub block_number: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGasPriceEstimateRequest {
    #[prost(enumeration = "FulfillmentStrategy", tag = "1")]
    pub strategy: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGasPriceEstimateResponse {
    #[prost(uint64, tag = "1")]
    pub gas_price: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionDetailsRequest {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionDetails {
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "4")]
    pub nonce: u64,
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
    #[prost(string, optional, tag = "6")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "7")]
    pub request_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionDetailsResponse {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<TransactionDetails>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<BidRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The request ID to bid on.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The amount to bid.
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    /// The domain separator for the request.
    #[prost(bytes = "vec", tag = "4")]
    pub domain: ::prost::alloc::vec::Vec<u8>,
    /// The address of the prover.
    #[prost(bytes = "vec", tag = "5")]
    pub prover: ::prost::alloc::vec::Vec<u8>,
    /// The variant of the transaction.
    #[prost(enumeration = "TransactionVariant", tag = "6")]
    pub variant: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<BidResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BidResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettleRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SettleRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettleRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The request ID to settle bids for.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The winner of the auction.
    #[prost(bytes = "vec", tag = "3")]
    pub winner: ::prost::alloc::vec::Vec<u8>,
    /// The domain separator for the request.
    #[prost(bytes = "vec", tag = "4")]
    pub domain: ::prost::alloc::vec::Vec<u8>,
    /// The variant of the transaction.
    #[prost(enumeration = "TransactionVariant", tag = "5")]
    pub variant: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettleResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SettleResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SettleResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetProversByUptimeRequest {
    /// Whether to only return high availability provers.
    #[prost(bool, tag = "1")]
    pub high_availability_only: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProversByUptimeResponse {
    /// The provers that have historically had reliable uptime.
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub provers: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFilteredSettleableRequestsRequest {
    /// Maximum number of results to return.
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// Page number for pagination.
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettleableRequest {
    /// The unique identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The creation time of the request (Unix timestamp).
    #[prost(uint64, tag = "2")]
    pub created_at: u64,
    /// The minimum auction period in seconds.
    #[prost(uint64, tag = "3")]
    pub min_auction_period: u64,
    /// The bids for this request.
    #[prost(message, repeated, tag = "4")]
    pub bids: ::prost::alloc::vec::Vec<Bid>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredSettleableRequestsResponse {
    /// List of settleable proof requests.
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<SettleableRequest>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFilteredSuspendableProversRequest {
    /// Time in seconds to lookback for failed proofs.
    #[prost(uint64, tag = "1")]
    pub lookback: u64,
    /// Time in seconds to count for all failed proofs in.
    #[prost(uint64, tag = "2")]
    pub outer_lookback: u64,
    /// The optional maximum number of provers to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "3")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "4")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuspendableProver {
    /// The prover address.
    #[prost(bytes = "vec", tag = "1")]
    pub prover: ::prost::alloc::vec::Vec<u8>,
    /// The count of failed proofs in the outer lookback period.
    #[prost(uint64, tag = "2")]
    pub failure_count: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredSuspendableProversResponse {
    /// List of suspendable provers.
    #[prost(message, repeated, tag = "1")]
    pub provers: ::prost::alloc::vec::Vec<SuspendableProver>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuspendProverRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SuspendProverRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuspendProverRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the prover to suspend.
    #[prost(bytes = "vec", tag = "2")]
    pub prover: ::prost::alloc::vec::Vec<u8>,
    /// The unix timestamp of when the suspension is over.
    #[prost(uint64, tag = "3")]
    pub suspended_until: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuspendProverResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SuspendProverResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SuspendProverResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Claims {
    /// The subject of the JWT.
    #[prost(bytes = "vec", tag = "1")]
    pub sub: ::prost::alloc::vec::Vec<u8>,
    /// The expiration time of the JWT.
    #[prost(uint64, tag = "2")]
    pub exp: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignInRequest {
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The SIWE message.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignInResponse {
    /// The JSON Web Token (JWT) to use for authentication.
    #[prost(string, tag = "1")]
    pub jwt: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectTwitterRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<ConnectTwitterRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectTwitterRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The callback URI redirected to.
    #[prost(string, tag = "2")]
    pub callback_uri: ::prost::alloc::string::String,
    /// The code from Twitter.
    #[prost(string, tag = "3")]
    pub code: ::prost::alloc::string::String,
    /// The code verifier used in the initial Twitter request.
    #[prost(string, tag = "4")]
    pub code_verifier: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectTwitterResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<ConnectTwitterResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConnectTwitterResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bid {
    /// The address of the bidder.
    #[prost(bytes = "vec", tag = "1")]
    pub bidder: ::prost::alloc::vec::Vec<u8>,
    /// The amount of the bid.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverStatsRequest {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverStatsResponse {
    #[prost(string, tag = "1")]
    pub total_earnings: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub total_cycles: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub total_gas_proved: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub active_provers: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub total_proofs_won: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProverStats {
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, tag = "5")]
    pub total_auction_requests: u64,
    #[prost(uint64, tag = "6")]
    pub successful_requests: u64,
    #[prost(string, tag = "7")]
    pub total_gas_proved: ::prost::alloc::string::String,
    #[prost(uint64, tag = "8")]
    pub last_active_at: u64,
    #[prost(uint64, tag = "9")]
    pub created_at: u64,
    #[prost(string, tag = "10")]
    pub total_earnings: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "11")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "12")]
    pub block_number: u64,
    #[prost(bytes = "vec", tag = "13")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "14")]
    pub lifetime_rewards: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "15")]
    pub image_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "16")]
    pub ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "17")]
    pub staker_fee_bips: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "18")]
    pub staker_rewards_24_hr: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFilteredProverStatsRequest {
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
    /// Whether to include featured provers.
    #[prost(bool, optional, tag = "3")]
    pub is_featured: ::core::option::Option<bool>,
    /// Whether to include whitelisted provers.
    #[prost(bool, optional, tag = "4")]
    pub is_whitelisted: ::core::option::Option<bool>,
    /// Whether to show featured provers first in sorting.
    #[prost(bool, optional, tag = "5")]
    pub featured_first: ::core::option::Option<bool>,
    /// Whether to show whitelisted provers first in sorting.
    #[prost(bool, optional, tag = "6")]
    pub whitelisted_first: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProverStatsResponse {
    #[prost(message, repeated, tag = "1")]
    pub stats: ::prost::alloc::vec::Vec<ProverStats>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverSearchResultsRequest {
    /// The query to search for.
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverSearchResultsResponse {
    #[prost(message, repeated, tag = "1")]
    pub provers: ::prost::alloc::vec::Vec<SearchResult>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StakingProverSearchResult {
    /// The prover address.
    #[prost(bytes = "vec", tag = "1")]
    pub prover_address: ::prost::alloc::vec::Vec<u8>,
    /// The prover name.
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The prover image URL.
    #[prost(string, optional, tag = "3")]
    pub image_url: ::core::option::Option<::prost::alloc::string::String>,
    /// The staked balance.
    #[prost(string, tag = "4")]
    pub stake_balance: ::prost::alloc::string::String,
    /// The staker fee in bips.
    #[prost(string, optional, tag = "5")]
    pub staker_fee_bips: ::core::option::Option<::prost::alloc::string::String>,
    /// The staker rewards in the last 24 hours.
    #[prost(string, tag = "6")]
    pub staker_rewards_24_hr: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStakingProverSearchRequest {
    /// The search query string.
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStakingProverSearchResponse {
    #[prost(message, repeated, tag = "1")]
    pub provers: ::prost::alloc::vec::Vec<StakingProverSearchResult>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidHistory {
    /// The bidder.
    #[prost(bytes = "vec", tag = "1")]
    pub bidder: ::prost::alloc::vec::Vec<u8>,
    /// The amount bid.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
    /// The creation time of the bid.
    #[prost(uint64, tag = "3")]
    pub created_at: u64,
    /// The bidder name.
    #[prost(string, optional, tag = "4")]
    pub bidder_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBidHistoryRequest {
    /// The request id to filter by.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The limit for the number of results.
    #[prost(uint32, optional, tag = "2")]
    pub limit: ::core::option::Option<u32>,
    /// The page for the results.
    #[prost(uint32, optional, tag = "3")]
    pub page: ::core::option::Option<u32>,
    /// Whether to show the winner first in sorting.
    #[prost(bool, optional, tag = "4")]
    pub winner_first: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBidHistoryResponse {
    #[prost(message, repeated, tag = "1")]
    pub bids: ::prost::alloc::vec::Vec<BidHistory>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProverBidHistoryRequest {
    /// The prover address to get bid history for.
    #[prost(bytes = "vec", tag = "1")]
    pub prover_address: ::prost::alloc::vec::Vec<u8>,
    /// The limit for the number of results.
    #[prost(uint32, optional, tag = "2")]
    pub limit: ::core::option::Option<u32>,
    /// The page for the results.
    #[prost(uint32, optional, tag = "3")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProverBidHistoryResponse {
    #[prost(message, repeated, tag = "1")]
    pub bids: ::prost::alloc::vec::Vec<BidHistory>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverStatsDetailRequest {
    /// The prover address to get stats for.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverStatsDetailResponse {
    /// The prover stats.
    #[prost(message, optional, tag = "1")]
    pub stats: ::core::option::Option<ProverStats>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Prover {
    /// The address of the prover.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The owner of the prover.
    #[prost(bytes = "vec", tag = "2")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    /// The name of the prover.
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The block number of the prover was created in.
    #[prost(uint64, tag = "4")]
    pub block_number: u64,
    /// The transaction hash of the prover was created in.
    #[prost(bytes = "vec", tag = "5")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The staker fee in bips.
    #[prost(string, tag = "6")]
    pub staker_fee_bips: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFilteredProversRequest {
    /// The optional maximum number of provers to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProversResponse {
    #[prost(message, repeated, tag = "1")]
    pub provers: ::prost::alloc::vec::Vec<Prover>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStakerStakeBalanceRequest {
    /// The account to get the stake balance for. This can be a prover or the owner of the prover.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStakerStakeBalanceResponse {
    /// The stake balance.
    #[prost(string, tag = "1")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverStakeBalanceRequest {
    /// The address of the prover.
    #[prost(bytes = "vec", tag = "1")]
    pub prover: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverStakeBalanceResponse {
    /// The stake balance.
    #[prost(string, tag = "1")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StakeBalanceLog {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The type of balance change operation.
    #[prost(enumeration = "StakeBalanceOperation", tag = "2")]
    pub operation: i32,
    /// The amount of the change (can be positive or negative).
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    /// The transaction hash that caused this change.
    #[prost(bytes = "vec", tag = "4")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The unix timestamp of when this change occurred.
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredStakerStakeBalanceLogsRequest {
    /// The optional staker address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional type of operations to filter for.
    #[prost(enumeration = "StakeBalanceOperation", optional, tag = "2")]
    pub operation: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp to filter logs from. Only returns
    /// logs after this timestamp.
    #[prost(uint64, optional, tag = "3")]
    pub minimum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum unix timestamp to filter logs to. Only returns
    /// logs before this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub maximum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum number of logs to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "5")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "6")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredStakerStakeBalanceLogsResponse {
    /// The staker balance logs.
    #[prost(message, repeated, tag = "1")]
    pub logs: ::prost::alloc::vec::Vec<StakeBalanceLog>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProverStakeBalanceLogsRequest {
    /// The optional prover address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional type of operations to filter for.
    #[prost(enumeration = "StakeBalanceOperation", optional, tag = "2")]
    pub operation: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp to filter logs from. Only returns
    /// logs after this timestamp.
    #[prost(uint64, optional, tag = "3")]
    pub minimum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum unix timestamp to filter logs to. Only returns
    /// logs before this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub maximum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum number of logs to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "5")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "6")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProverStakeBalanceLogsResponse {
    /// The prover balance logs.
    #[prost(message, repeated, tag = "1")]
    pub logs: ::prost::alloc::vec::Vec<StakeBalanceLog>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetDelegationParamsRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDelegationParamsResponse {
    /// The default auctioneer address.
    #[prost(bytes = "vec", tag = "1")]
    pub auctioneer: ::prost::alloc::vec::Vec<u8>,
    /// The default delegation fee.
    #[prost(string, tag = "2")]
    pub fee: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetDelegationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetDelegationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetDelegationRequestBody {
    /// The nonce of the request.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The delegate address to set.
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
    /// The prover address that the delegation applies to.
    #[prost(bytes = "vec", tag = "3")]
    pub prover: ::prost::alloc::vec::Vec<u8>,
    /// The domain separator bytes for the request.
    #[prost(bytes = "vec", tag = "4")]
    pub domain: ::prost::alloc::vec::Vec<u8>,
    /// The variant of the transaction.
    #[prost(enumeration = "TransactionVariant", tag = "5")]
    pub variant: i32,
    /// The auctioneer address that will receive the fee.
    #[prost(bytes = "vec", tag = "6")]
    pub auctioneer: ::prost::alloc::vec::Vec<u8>,
    /// The fee to pay for the delegation operation.
    #[prost(string, tag = "7")]
    pub fee: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetDelegationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetDelegationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetDelegationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDelegationRequest {
    /// The prover address to get the delegation for.
    #[prost(bytes = "vec", tag = "1")]
    pub prover: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Delegation {
    /// The owner of the delegation.
    #[prost(bytes = "vec", tag = "1")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    /// The delegate address.
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
    /// The date the delegation was created.
    #[prost(uint64, tag = "3")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDelegationResponse {
    /// The delegation.
    #[prost(message, optional, tag = "1")]
    pub delegation: ::core::option::Option<Delegation>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredWithdrawalReceiptsRequest {
    /// The page number to return.
    #[prost(uint32, optional, tag = "1")]
    pub page: ::core::option::Option<u32>,
    /// The optional maximum number of receipts to return.
    #[prost(uint32, optional, tag = "2")]
    pub limit: ::core::option::Option<u32>,
    /// The optional account address to filter for.
    #[prost(bytes = "vec", optional, tag = "3")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawalReceipt {
    /// Withdrawal transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// Withdrawal amount.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
    /// The withdrawal timestamp.
    #[prost(uint64, tag = "3")]
    pub created_at: u64,
    /// The withdrawal type (owner or prover).
    #[prost(enumeration = "WithdrawalType", tag = "4")]
    pub withdrawal_type: i32,
    /// The account address that made the withdrawal.
    #[prost(bytes = "vec", tag = "5")]
    pub account: ::prost::alloc::vec::Vec<u8>,
    /// The balance operation type (2 for withdraw, 6 for withdraw_request).
    #[prost(enumeration = "BalanceOperation", tag = "6")]
    pub operation: i32,
    /// The sender address that initiated the withdrawal.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub sender: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredWithdrawalReceiptsResponse {
    /// The withdrawal receipts.
    #[prost(message, repeated, tag = "1")]
    pub receipts: ::prost::alloc::vec::Vec<WithdrawalReceipt>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetStakingPointsRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PointsPartner {
    /// The partner ID from the points_partners table.
    #[prost(int64, tag = "1")]
    pub id: i64,
    /// The partner title.
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    /// The partner description.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// The partner image URL.
    #[prost(string, optional, tag = "4")]
    pub image_url: ::core::option::Option<::prost::alloc::string::String>,
    /// The partner website URL.
    #[prost(string, optional, tag = "5")]
    pub website_url: ::core::option::Option<::prost::alloc::string::String>,
    /// The aggregated points for the authenticated user for this partner.
    /// If null/empty, the partner has no associated point rules or the user has no points.
    #[prost(double, optional, tag = "6")]
    pub points: ::core::option::Option<f64>,
    /// The prover ID from the point_rules table, if this partner is specific to a prover.
    /// If null, this partner represents general rewards not specific to any prover.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub prover_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStakingPointsResponse {
    /// List of all points partners with their aggregated points for the authenticated user.
    #[prost(message, repeated, tag = "1")]
    pub partners: ::prost::alloc::vec::Vec<PointsPartner>,
}
/// Format to help decode signature in backend.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MessageFormat {
    /// Unspecified message format.
    UnspecifiedMessageFormat = 0,
    /// The message is in binary format.
    Binary = 1,
    /// The message is in JSON format.
    Json = 2,
}
impl MessageFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedMessageFormat => "UNSPECIFIED_MESSAGE_FORMAT",
            Self::Binary => "BINARY",
            Self::Json => "JSON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_MESSAGE_FORMAT" => Some(Self::UnspecifiedMessageFormat),
            "BINARY" => Some(Self::Binary),
            "JSON" => Some(Self::Json),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionVariant {
    RequestVariant = 0,
    BidVariant = 1,
    SettleVariant = 2,
    ExecuteVariant = 3,
    FulfillVariant = 4,
    DelegateVariant = 5,
    TransferVariant = 6,
    WithdrawVariant = 7,
    CancelRequestVariant = 8,
}
impl TransactionVariant {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RequestVariant => "REQUEST_VARIANT",
            Self::BidVariant => "BID_VARIANT",
            Self::SettleVariant => "SETTLE_VARIANT",
            Self::ExecuteVariant => "EXECUTE_VARIANT",
            Self::FulfillVariant => "FULFILL_VARIANT",
            Self::DelegateVariant => "DELEGATE_VARIANT",
            Self::TransferVariant => "TRANSFER_VARIANT",
            Self::WithdrawVariant => "WITHDRAW_VARIANT",
            Self::CancelRequestVariant => "CANCEL_REQUEST_VARIANT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REQUEST_VARIANT" => Some(Self::RequestVariant),
            "BID_VARIANT" => Some(Self::BidVariant),
            "SETTLE_VARIANT" => Some(Self::SettleVariant),
            "EXECUTE_VARIANT" => Some(Self::ExecuteVariant),
            "FULFILL_VARIANT" => Some(Self::FulfillVariant),
            "DELEGATE_VARIANT" => Some(Self::DelegateVariant),
            "TRANSFER_VARIANT" => Some(Self::TransferVariant),
            "WITHDRAW_VARIANT" => Some(Self::WithdrawVariant),
            "CANCEL_REQUEST_VARIANT" => Some(Self::CancelRequestVariant),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProofMode {
    UnspecifiedProofMode = 0,
    /// The core proof mode.
    Core = 1,
    /// The compressed proof mode.
    Compressed = 2,
    /// The plonk proof mode.
    Plonk = 3,
    /// The groth16 proof mode.
    Groth16 = 4,
}
impl ProofMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedProofMode => "UNSPECIFIED_PROOF_MODE",
            Self::Core => "CORE",
            Self::Compressed => "COMPRESSED",
            Self::Plonk => "PLONK",
            Self::Groth16 => "GROTH16",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_PROOF_MODE" => Some(Self::UnspecifiedProofMode),
            "CORE" => Some(Self::Core),
            "COMPRESSED" => Some(Self::Compressed),
            "PLONK" => Some(Self::Plonk),
            "GROTH16" => Some(Self::Groth16),
            _ => None,
        }
    }
}
/// The different strategies that can be used for fulfilling requests.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FulfillmentStrategy {
    UnspecifiedFulfillmentStrategy = 0,
    /// The hosted fulfillment strategy. Uses Succinct's on-demand prover to fulfill requests.
    Hosted = 1,
    /// The reserved fulfillment strategy. Uses an already existing agreement with a
    /// fulfiller to fulfill requests.
    Reserved = 2,
    /// The auction fulfillment strategy. Uses a decentralized proof contest to
    /// fulfill requests.
    Auction = 3,
}
impl FulfillmentStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedFulfillmentStrategy => "UNSPECIFIED_FULFILLMENT_STRATEGY",
            Self::Hosted => "HOSTED",
            Self::Reserved => "RESERVED",
            Self::Auction => "AUCTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_FULFILLMENT_STRATEGY" => {
                Some(Self::UnspecifiedFulfillmentStrategy)
            }
            "HOSTED" => Some(Self::Hosted),
            "RESERVED" => Some(Self::Reserved),
            "AUCTION" => Some(Self::Auction),
            _ => None,
        }
    }
}
/// The different fulfillment statuses that a request can be in.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FulfillmentStatus {
    UnspecifiedFulfillmentStatus = 0,
    /// The request has been requested.
    Requested = 1,
    /// The request has been assigned to a fulfiller.
    Assigned = 2,
    /// The request has been fulfilled.
    Fulfilled = 3,
    /// The request cannot be fulfilled.
    Unfulfillable = 4,
}
impl FulfillmentStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedFulfillmentStatus => "UNSPECIFIED_FULFILLMENT_STATUS",
            Self::Requested => "REQUESTED",
            Self::Assigned => "ASSIGNED",
            Self::Fulfilled => "FULFILLED",
            Self::Unfulfillable => "UNFULFILLABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_FULFILLMENT_STATUS" => Some(Self::UnspecifiedFulfillmentStatus),
            "REQUESTED" => Some(Self::Requested),
            "ASSIGNED" => Some(Self::Assigned),
            "FULFILLED" => Some(Self::Fulfilled),
            "UNFULFILLABLE" => Some(Self::Unfulfillable),
            _ => None,
        }
    }
}
/// The different execution statuses that a request can be in.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecutionStatus {
    UnspecifiedExecutionStatus = 0,
    /// The request has not been executed.
    Unexecuted = 1,
    /// The request has been executed.
    Executed = 2,
    /// The request cannot be executed.
    Unexecutable = 3,
    /// The request was executed, but validation failed.
    ValidationFailed = 4,
}
impl ExecutionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedExecutionStatus => "UNSPECIFIED_EXECUTION_STATUS",
            Self::Unexecuted => "UNEXECUTED",
            Self::Executed => "EXECUTED",
            Self::Unexecutable => "UNEXECUTABLE",
            Self::ValidationFailed => "VALIDATION_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_EXECUTION_STATUS" => Some(Self::UnspecifiedExecutionStatus),
            "UNEXECUTED" => Some(Self::Unexecuted),
            "EXECUTED" => Some(Self::Executed),
            "UNEXECUTABLE" => Some(Self::Unexecutable),
            "VALIDATION_FAILED" => Some(Self::ValidationFailed),
            _ => None,
        }
    }
}
/// The different settlement statuses that a request can be in.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SettlementStatus {
    UnspecifiedSettlementStatus = 0,
    /// The request has not been settled.
    Unsettled = 1,
    /// The request has been settled.
    Settled = 2,
}
impl SettlementStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedSettlementStatus => "UNSPECIFIED_SETTLEMENT_STATUS",
            Self::Unsettled => "UNSETTLED",
            Self::Settled => "SETTLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_SETTLEMENT_STATUS" => Some(Self::UnspecifiedSettlementStatus),
            "UNSETTLED" => Some(Self::Unsettled),
            "SETTLED" => Some(Self::Settled),
            _ => None,
        }
    }
}
/// The different types of balance changes that can occur for credits.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BalanceOperation {
    UnspecifiedBalanceChangeOperation = 0,
    /// A deposit operation (positive).
    Deposit = 1,
    /// A withdraw operation (no effect).
    Withdraw = 2,
    /// A reward operation (positive).
    Reward = 3,
    /// A transfer-out operation (negative).
    TransferOut = 4,
    /// A transfer-in operation (positive).
    TransferIn = 5,
    /// A withdraw request operation (negative).
    WithdrawRequest = 6,
    /// A withdraw fee operation (negative).
    WithdrawFeeOut = 7,
    /// A delegation fee operation (negative).
    DelegateFeeOut = 8,
    /// A request operation (negative).
    Request = 9,
    /// A transfer fee operation (negative).
    TransferFeeOut = 10,
    /// A withdraw fee in operation (positive).
    WithdrawFeeIn = 11,
    /// A delegation fee in operation (positive).
    DelegateFeeIn = 12,
    /// A transfer fee in operation (positive).
    TransferFeeIn = 13,
}
impl BalanceOperation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedBalanceChangeOperation => {
                "UNSPECIFIED_BALANCE_CHANGE_OPERATION"
            }
            Self::Deposit => "DEPOSIT",
            Self::Withdraw => "WITHDRAW",
            Self::Reward => "REWARD",
            Self::TransferOut => "TRANSFER_OUT",
            Self::TransferIn => "TRANSFER_IN",
            Self::WithdrawRequest => "WITHDRAW_REQUEST",
            Self::WithdrawFeeOut => "WITHDRAW_FEE_OUT",
            Self::DelegateFeeOut => "DELEGATE_FEE_OUT",
            Self::Request => "REQUEST",
            Self::TransferFeeOut => "TRANSFER_FEE_OUT",
            Self::WithdrawFeeIn => "WITHDRAW_FEE_IN",
            Self::DelegateFeeIn => "DELEGATE_FEE_IN",
            Self::TransferFeeIn => "TRANSFER_FEE_IN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_BALANCE_CHANGE_OPERATION" => {
                Some(Self::UnspecifiedBalanceChangeOperation)
            }
            "DEPOSIT" => Some(Self::Deposit),
            "WITHDRAW" => Some(Self::Withdraw),
            "REWARD" => Some(Self::Reward),
            "TRANSFER_OUT" => Some(Self::TransferOut),
            "TRANSFER_IN" => Some(Self::TransferIn),
            "WITHDRAW_REQUEST" => Some(Self::WithdrawRequest),
            "WITHDRAW_FEE_OUT" => Some(Self::WithdrawFeeOut),
            "DELEGATE_FEE_OUT" => Some(Self::DelegateFeeOut),
            "REQUEST" => Some(Self::Request),
            "TRANSFER_FEE_OUT" => Some(Self::TransferFeeOut),
            "WITHDRAW_FEE_IN" => Some(Self::WithdrawFeeIn),
            "DELEGATE_FEE_IN" => Some(Self::DelegateFeeIn),
            "TRANSFER_FEE_IN" => Some(Self::TransferFeeIn),
            _ => None,
        }
    }
}
/// The different types of balance changes that can occur for stake.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StakeBalanceOperation {
    UnspecifiedStakeBalanceOperation = 0,
    /// A stake operation (positive).
    Stake = 1,
    /// An unstake operation (negative).
    Unstake = 2,
    /// A slash operation (negative).
    Slash = 3,
    /// A bid operation (negative).
    Bid = 4,
}
impl StakeBalanceOperation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedStakeBalanceOperation => {
                "UNSPECIFIED_STAKE_BALANCE_OPERATION"
            }
            Self::Stake => "STAKE",
            Self::Unstake => "UNSTAKE",
            Self::Slash => "SLASH",
            Self::Bid => "BID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_STAKE_BALANCE_OPERATION" => {
                Some(Self::UnspecifiedStakeBalanceOperation)
            }
            "STAKE" => Some(Self::Stake),
            "UNSTAKE" => Some(Self::Unstake),
            "SLASH" => Some(Self::Slash),
            "BID" => Some(Self::Bid),
            _ => None,
        }
    }
}
/// The different social platforms.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SocialPlatform {
    UnspecifiedPlatform = 0,
    /// The twitter platform.
    Twitter = 1,
    /// The github platform.
    Github = 2,
    /// The discord platform.
    Discord = 3,
}
impl SocialPlatform {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedPlatform => "UNSPECIFIED_PLATFORM",
            Self::Twitter => "TWITTER",
            Self::Github => "GITHUB",
            Self::Discord => "DISCORD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_PLATFORM" => Some(Self::UnspecifiedPlatform),
            "TWITTER" => Some(Self::Twitter),
            "GITHUB" => Some(Self::Github),
            "DISCORD" => Some(Self::Discord),
            _ => None,
        }
    }
}
/// The different gpu variants.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GpuVariant {
    UnspecifiedVariant = 0,
    /// The blueberry variant.
    Blueberry = 1,
    /// The strawberry variant.
    Strawberry = 2,
    /// The lime variant.
    Lime = 3,
    /// The tangerine variant.
    Tangerine = 4,
    /// The grape variant.
    Grape = 5,
}
impl GpuVariant {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedVariant => "UNSPECIFIED_VARIANT",
            Self::Blueberry => "BLUEBERRY",
            Self::Strawberry => "STRAWBERRY",
            Self::Lime => "LIME",
            Self::Tangerine => "TANGERINE",
            Self::Grape => "GRAPE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_VARIANT" => Some(Self::UnspecifiedVariant),
            "BLUEBERRY" => Some(Self::Blueberry),
            "STRAWBERRY" => Some(Self::Strawberry),
            "LIME" => Some(Self::Lime),
            "TANGERINE" => Some(Self::Tangerine),
            "GRAPE" => Some(Self::Grape),
            _ => None,
        }
    }
}
/// The different upgrades that can be purchased with points.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Upgrade {
    UnspecifiedUpgrade = 0,
    /// The earn rate boost upgrade.
    EarnRateBoost = 1,
    /// The click worth boost upgrade.
    ClickValueBoost = 2,
    /// The clicks per period boost upgrade.
    ClicksPerPeriodBoost = 3,
}
impl Upgrade {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedUpgrade => "UNSPECIFIED_UPGRADE",
            Self::EarnRateBoost => "EARN_RATE_BOOST",
            Self::ClickValueBoost => "CLICK_VALUE_BOOST",
            Self::ClicksPerPeriodBoost => "CLICKS_PER_PERIOD_BOOST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_UPGRADE" => Some(Self::UnspecifiedUpgrade),
            "EARN_RATE_BOOST" => Some(Self::EarnRateBoost),
            "CLICK_VALUE_BOOST" => Some(Self::ClickValueBoost),
            "CLICKS_PER_PERIOD_BOOST" => Some(Self::ClicksPerPeriodBoost),
            _ => None,
        }
    }
}
/// The different causes for execution failure.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecuteFailureCause {
    UnspecifiedExecutionFailureCause = 0,
    /// The execution failed with a non-zero exit code.
    HaltWithNonZeroExitCode = 1,
    /// The execution failed with an invalid memory access.
    InvalidMemoryAccess = 2,
    /// The execution failed with an unimplemented syscall.
    UnsupportedSyscall = 3,
    /// The execution failed with a breakpoint.
    Breakpoint = 4,
    /// The execution failed with an exceeded cycle limit.
    ExceededCycleLimit = 5,
    /// The execution failed because the syscall was called in unconstrained mode.
    InvalidSyscallUsage = 6,
    /// The execution failed with an unimplemented feature.
    Unimplemented = 7,
    /// The program ended in unconstrained mode.
    EndInUnconstrained = 8,
    /// The execution failed with an exceeded gas limit.
    ExceededGasLimit = 9,
}
impl ExecuteFailureCause {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedExecutionFailureCause => {
                "UNSPECIFIED_EXECUTION_FAILURE_CAUSE"
            }
            Self::HaltWithNonZeroExitCode => "HALT_WITH_NON_ZERO_EXIT_CODE",
            Self::InvalidMemoryAccess => "INVALID_MEMORY_ACCESS",
            Self::UnsupportedSyscall => "UNSUPPORTED_SYSCALL",
            Self::Breakpoint => "BREAKPOINT",
            Self::ExceededCycleLimit => "EXCEEDED_CYCLE_LIMIT",
            Self::InvalidSyscallUsage => "INVALID_SYSCALL_USAGE",
            Self::Unimplemented => "UNIMPLEMENTED",
            Self::EndInUnconstrained => "END_IN_UNCONSTRAINED",
            Self::ExceededGasLimit => "EXCEEDED_GAS_LIMIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_EXECUTION_FAILURE_CAUSE" => {
                Some(Self::UnspecifiedExecutionFailureCause)
            }
            "HALT_WITH_NON_ZERO_EXIT_CODE" => Some(Self::HaltWithNonZeroExitCode),
            "INVALID_MEMORY_ACCESS" => Some(Self::InvalidMemoryAccess),
            "UNSUPPORTED_SYSCALL" => Some(Self::UnsupportedSyscall),
            "BREAKPOINT" => Some(Self::Breakpoint),
            "EXCEEDED_CYCLE_LIMIT" => Some(Self::ExceededCycleLimit),
            "INVALID_SYSCALL_USAGE" => Some(Self::InvalidSyscallUsage),
            "UNIMPLEMENTED" => Some(Self::Unimplemented),
            "END_IN_UNCONSTRAINED" => Some(Self::EndInUnconstrained),
            "EXCEEDED_GAS_LIMIT" => Some(Self::ExceededGasLimit),
            _ => None,
        }
    }
}
/// The different types of charges for reserved billing.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChargeType {
    UnspecifiedChargeType = 0,
    /// For base reserved cluster usage.
    BaseCluster = 1,
    /// For reserved GPU throughput.
    ProvisionedMgasPerSec = 2,
    /// For usage exceeding reserved.
    ExcessGas = 3,
    /// For groth16 proofs.
    Groth16Proof = 4,
    /// For plonk proofs.
    PlonkProof = 5,
}
impl ChargeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedChargeType => "UNSPECIFIED_CHARGE_TYPE",
            Self::BaseCluster => "BASE_CLUSTER",
            Self::ProvisionedMgasPerSec => "PROVISIONED_MGAS_PER_SEC",
            Self::ExcessGas => "EXCESS_GAS",
            Self::Groth16Proof => "GROTH16_PROOF",
            Self::PlonkProof => "PLONK_PROOF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_CHARGE_TYPE" => Some(Self::UnspecifiedChargeType),
            "BASE_CLUSTER" => Some(Self::BaseCluster),
            "PROVISIONED_MGAS_PER_SEC" => Some(Self::ProvisionedMgasPerSec),
            "EXCESS_GAS" => Some(Self::ExcessGas),
            "GROTH16_PROOF" => Some(Self::Groth16Proof),
            "PLONK_PROOF" => Some(Self::PlonkProof),
            _ => None,
        }
    }
}
/// The different types of withdrawal sources.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WithdrawalType {
    UnspecifiedWithdrawalType = 0,
    /// Withdrawal from user's own account.
    Owner = 1,
    /// Withdrawal from user's prover address.
    Prover = 2,
}
impl WithdrawalType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedWithdrawalType => "UNSPECIFIED_WITHDRAWAL_TYPE",
            Self::Owner => "OWNER",
            Self::Prover => "PROVER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_WITHDRAWAL_TYPE" => Some(Self::UnspecifiedWithdrawalType),
            "OWNER" => Some(Self::Owner),
            "PROVER" => Some(Self::Prover),
            _ => None,
        }
    }
}
/// The different proof request errors. Only one error corresponds to unexecutable/unfulfillable
/// requests. The rest correspond to executable/unfulfillable requests.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProofRequestError {
    UnspecifiedProofRequestFailure = 0,
    /// The proof request failed due to an execution error (unexecutable).
    ExecutionFailure = 1,
    /// The verification key used by the prover does not match the one expected for the program.
    VerificationKeyMismatch = 2,
    /// The proof request failed due to an unknown error (potentially a bug).
    UnknownFailure = 3,
    /// The public values hash provided in the request does not match the hash from the execution
    /// oracle.
    PublicValuesMismatch = 4,
}
impl ProofRequestError {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedProofRequestFailure => "UNSPECIFIED_PROOF_REQUEST_FAILURE",
            Self::ExecutionFailure => "EXECUTION_FAILURE",
            Self::VerificationKeyMismatch => "VERIFICATION_KEY_MISMATCH",
            Self::UnknownFailure => "UNKNOWN_FAILURE",
            Self::PublicValuesMismatch => "PUBLIC_VALUES_MISMATCH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_PROOF_REQUEST_FAILURE" => {
                Some(Self::UnspecifiedProofRequestFailure)
            }
            "EXECUTION_FAILURE" => Some(Self::ExecutionFailure),
            "VERIFICATION_KEY_MISMATCH" => Some(Self::VerificationKeyMismatch),
            "UNKNOWN_FAILURE" => Some(Self::UnknownFailure),
            "PUBLIC_VALUES_MISMATCH" => Some(Self::PublicValuesMismatch),
            _ => None,
        }
    }
}
