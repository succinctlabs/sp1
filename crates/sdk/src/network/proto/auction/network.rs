// This file is @generated by prost-build.
/// Generated client implementations.
pub mod prover_network_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct ProverNetworkClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ProverNetworkClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ProverNetworkClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ProverNetworkClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ProverNetworkClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a proof request.
        pub async fn request_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::RequestProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RequestProofResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/RequestProof",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RequestProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Fulfills a proof request. Only callable by the assigned fulfiller.
        pub async fn fulfill_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::FulfillProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::FulfillProofResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/FulfillProof",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "FulfillProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Executes a proof request. Only callable by the execution oracle.
        pub async fn execute_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::ExecuteProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ExecuteProofResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/ExecuteProof",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "ExecuteProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Fails fulfillment. Only callable by the assigned fulfiller.
        pub async fn fail_fulfillment(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::FailFulfillmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::FailFulfillmentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/FailFulfillment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "FailFulfillment"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the status of a proof request.
        pub async fn get_proof_request_status(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetProofRequestStatusRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProofRequestStatus"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the details of a proof request.
        pub async fn get_proof_request_details(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetProofRequestDetailsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestDetailsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProofRequestDetails"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the proof requests that meet the filter criteria.
        pub async fn get_filtered_proof_requests(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredProofRequestsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProofRequestsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProofRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredProofRequests"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Subscribe to proof requests that meet the filter criteria.
        pub async fn subscribe_proof_requests(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredProofRequestsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::super::types::ProofRequest>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SubscribeProofRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "SubscribeProofRequests"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Search for proof requests, programs, and requesters.
        pub async fn get_search_results(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetSearchResultsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetSearchResultsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetSearchResults",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetSearchResults"));
            self.inner.unary(req, path, codec).await
        }
        /// Get metrics for proof requests.
        pub async fn get_proof_request_metrics(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetProofRequestMetricsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestMetricsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProofRequestMetrics"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get time series data for proof requests.
        pub async fn get_proof_request_graph(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetProofRequestGraphRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestGraphResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestGraph",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProofRequestGraph"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get analytics graphs for proof requests.
        pub async fn get_analytics_graphs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetAnalyticsGraphsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAnalyticsGraphsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetAnalyticsGraphs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetAnalyticsGraphs"));
            self.inner.unary(req, path, codec).await
        }
        /// Get overview graphs for proof requests.
        pub async fn get_overview_graphs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetOverviewGraphsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetOverviewGraphsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetOverviewGraphs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetOverviewGraphs"));
            self.inner.unary(req, path, codec).await
        }
        /// Get network proof request parameters.
        pub async fn get_proof_request_params(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetProofRequestParamsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestParams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProofRequestParams"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the nonce of the account.
        pub async fn get_nonce(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetNonceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetNonceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetNonce",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetNonce"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the name of the account.
        pub async fn set_account_name(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetAccountNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetAccountNameResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetAccountName",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetAccountName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the name of the account.
        pub async fn get_account_name(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetAccountNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAccountNameResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetAccountName",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetAccountName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get whether the account has signed the terms.
        pub async fn get_terms_signature(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetTermsSignatureRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTermsSignatureResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetTermsSignature",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetTermsSignature"));
            self.inner.unary(req, path, codec).await
        }
        /// Set whether the account has signed the terms.
        pub async fn set_terms_signature(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::SetTermsSignatureRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetTermsSignatureResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetTermsSignature",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetTermsSignature"));
            self.inner.unary(req, path, codec).await
        }
        /// Get all the information about an account.
        pub async fn get_account(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetAccount"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the owner of an account. Returns itself if the account is not delegated.
        pub async fn get_owner(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetOwnerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetOwnerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetOwner",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetOwner"));
            self.inner.unary(req, path, codec).await
        }
        /// Get metadata about a program.
        pub async fn get_program(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProgramResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProgram",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProgram"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new program. Must be called before requesting proofs.
        pub async fn create_program(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::CreateProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::CreateProgramResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/CreateProgram",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "CreateProgram"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the name of the program. Only callable by the owner.
        pub async fn set_program_name(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetProgramNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetProgramNameResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetProgramName",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetProgramName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the available balance of an account.
        pub async fn get_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetBalanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetBalance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetBalance"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the balance logs that meet the filter criteria.
        pub async fn get_filtered_balance_logs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredBalanceLogsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredBalanceLogsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredBalanceLogs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredBalanceLogs"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the latest processed block in the bridge.
        pub async fn get_latest_bridge_block(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetLatestBridgeBlockRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLatestBridgeBlockResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetLatestBridgeBlock",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetLatestBridgeBlock"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the gas price estimate for a given fulfillment strategy.
        pub async fn get_gas_price_estimate(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetGasPriceEstimateRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetGasPriceEstimateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetGasPriceEstimate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetGasPriceEstimate"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the details of a transaction.
        pub async fn get_transaction_details(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetTransactionDetailsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTransactionDetailsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetTransactionDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetTransactionDetails"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Transfer $PROVE from one account to another.
        pub async fn transfer(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::TransferRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::TransferResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/Transfer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "Transfer"));
            self.inner.unary(req, path, codec).await
        }
        /// Get transfer parameters.
        pub async fn get_transfer_params(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetTransferParamsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTransferParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetTransferParams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetTransferParams"));
            self.inner.unary(req, path, codec).await
        }
        /// Get withdraw parameters.
        pub async fn get_withdraw_params(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetWithdrawParamsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetWithdrawParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetWithdrawParams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetWithdrawParams"));
            self.inner.unary(req, path, codec).await
        }
        /// Withdraw $PROVE from an account.
        pub async fn withdraw(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::WithdrawRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::WithdrawResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/Withdraw",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "Withdraw"));
            self.inner.unary(req, path, codec).await
        }
        /// Bid for a proof request. Provers that want to be assigned this request must first
        /// bid on it.
        pub async fn bid(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::BidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::BidResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/Bid",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "Bid"));
            self.inner.unary(req, path, codec).await
        }
        /// Settle the bids on a proof request to choose the assigned prover. Only callable by
        /// the approved auctioneer.
        pub async fn settle(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SettleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SettleResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/Settle",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "Settle"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the provers that have historically had reliable uptime.
        pub async fn get_provers_by_uptime(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetProversByUptimeRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProversByUptimeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProversByUptime",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProversByUptime"));
            self.inner.unary(req, path, codec).await
        }
        /// Get settleable proof requests that have passed auction period and have bids.
        pub async fn get_filtered_settleable_requests(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredSettleableRequestsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredSettleableRequestsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredSettleableRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "GetFilteredSettleableRequests",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get suspendable provers that have recently failed proofs.
        pub async fn get_filtered_suspendable_provers(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredSuspendableProversRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredSuspendableProversResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredSuspendableProvers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "GetFilteredSuspendableProvers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Suspend a prover.
        pub async fn suspend_prover(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SuspendProverRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SuspendProverResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SuspendProver",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SuspendProver"));
            self.inner.unary(req, path, codec).await
        }
        /// Sign in with Ethereum
        pub async fn sign_in(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SignInRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SignInResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SignIn",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SignIn"));
            self.inner.unary(req, path, codec).await
        }
        /// Connect a Twitter account.
        pub async fn connect_twitter(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::ConnectTwitterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ConnectTwitterResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/ConnectTwitter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "ConnectTwitter"));
            self.inner.unary(req, path, codec).await
        }
        /// Get metrics for a specific prover
        pub async fn get_prover_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetProverStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProverStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProverStats"));
            self.inner.unary(req, path, codec).await
        }
        /// Get statistics for all provers with pagination
        pub async fn get_filtered_prover_stats(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredProverStatsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProverStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProverStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredProverStats"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get detailed statistics for a single prover by address
        pub async fn get_prover_stats_detail(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetProverStatsDetailRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverStatsDetailResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProverStatsDetail",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProverStatsDetail"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get search results for provers
        pub async fn get_prover_search_results(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetProverSearchResultsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverSearchResultsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProverSearchResults",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProverSearchResults"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Search provers by name or address with staking information
        pub async fn get_staking_prover_search(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetStakingProverSearchRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetStakingProverSearchResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetStakingProverSearch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetStakingProverSearch"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get paginated auction history
        pub async fn get_filtered_bid_history(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredBidHistoryRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredBidHistoryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredBidHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredBidHistory"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get filtered bid history for a prover with pagination
        pub async fn get_filtered_prover_bid_history(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredProverBidHistoryRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProverBidHistoryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProverBidHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "GetFilteredProverBidHistory",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Check if the user is whitelisted to use the TEE service.
        pub async fn get_tee_whitelist_status(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetTeeWhitelistStatusRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTeeWhitelistStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetTEEWhitelistStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetTEEWhitelistStatus"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the provers that meet the filter criteria.
        pub async fn get_filtered_provers(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredProversRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProversResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProvers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredProvers"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the available balance of a prover.
        pub async fn get_prover_stake_balance(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetProverStakeBalanceRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverStakeBalanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProverStakeBalance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProverStakeBalance"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the staker balance logs that meet the filter criteria.
        pub async fn get_filtered_staker_stake_balance_logs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredStakerStakeBalanceLogsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::super::types::GetFilteredStakerStakeBalanceLogsResponse,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredStakerStakeBalanceLogs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "GetFilteredStakerStakeBalanceLogs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the prover balance logs that meet the filter criteria.
        pub async fn get_filtered_prover_stake_balance_logs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredProverStakeBalanceLogsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::super::types::GetFilteredProverStakeBalanceLogsResponse,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProverStakeBalanceLogs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "GetFilteredProverStakeBalanceLogs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the delegation parameters.
        pub async fn get_delegation_params(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetDelegationParamsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetDelegationParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetDelegationParams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetDelegationParams"));
            self.inner.unary(req, path, codec).await
        }
        /// Set a delegation.
        pub async fn set_delegation(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetDelegationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetDelegation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Get a delegation.
        pub async fn get_delegation(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetDelegationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetDelegation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the withdrawal receipts of an account.
        pub async fn get_filtered_withdrawal_receipts(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredWithdrawalReceiptsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredWithdrawalReceiptsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredWithdrawalReceipts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "GetFilteredWithdrawalReceipts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod prover_network_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ProverNetworkServer.
    #[async_trait]
    pub trait ProverNetwork: std::marker::Send + std::marker::Sync + 'static {
        /// Creates a proof request.
        async fn request_proof(
            &self,
            request: tonic::Request<super::super::types::RequestProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RequestProofResponse>,
            tonic::Status,
        >;
        /// Fulfills a proof request. Only callable by the assigned fulfiller.
        async fn fulfill_proof(
            &self,
            request: tonic::Request<super::super::types::FulfillProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::FulfillProofResponse>,
            tonic::Status,
        >;
        /// Executes a proof request. Only callable by the execution oracle.
        async fn execute_proof(
            &self,
            request: tonic::Request<super::super::types::ExecuteProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ExecuteProofResponse>,
            tonic::Status,
        >;
        /// Fails fulfillment. Only callable by the assigned fulfiller.
        async fn fail_fulfillment(
            &self,
            request: tonic::Request<super::super::types::FailFulfillmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::FailFulfillmentResponse>,
            tonic::Status,
        >;
        /// Get the status of a proof request.
        async fn get_proof_request_status(
            &self,
            request: tonic::Request<super::super::types::GetProofRequestStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestStatusResponse>,
            tonic::Status,
        >;
        /// Get the details of a proof request.
        async fn get_proof_request_details(
            &self,
            request: tonic::Request<super::super::types::GetProofRequestDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestDetailsResponse>,
            tonic::Status,
        >;
        /// Get the proof requests that meet the filter criteria.
        async fn get_filtered_proof_requests(
            &self,
            request: tonic::Request<super::super::types::GetFilteredProofRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProofRequestsResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the SubscribeProofRequests method.
        type SubscribeProofRequestsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<
                    super::super::types::ProofRequest,
                    tonic::Status,
                >,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to proof requests that meet the filter criteria.
        async fn subscribe_proof_requests(
            &self,
            request: tonic::Request<super::super::types::GetFilteredProofRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SubscribeProofRequestsStream>,
            tonic::Status,
        >;
        /// Search for proof requests, programs, and requesters.
        async fn get_search_results(
            &self,
            request: tonic::Request<super::super::types::GetSearchResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetSearchResultsResponse>,
            tonic::Status,
        >;
        /// Get metrics for proof requests.
        async fn get_proof_request_metrics(
            &self,
            request: tonic::Request<super::super::types::GetProofRequestMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestMetricsResponse>,
            tonic::Status,
        >;
        /// Get time series data for proof requests.
        async fn get_proof_request_graph(
            &self,
            request: tonic::Request<super::super::types::GetProofRequestGraphRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestGraphResponse>,
            tonic::Status,
        >;
        /// Get analytics graphs for proof requests.
        async fn get_analytics_graphs(
            &self,
            request: tonic::Request<super::super::types::GetAnalyticsGraphsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAnalyticsGraphsResponse>,
            tonic::Status,
        >;
        /// Get overview graphs for proof requests.
        async fn get_overview_graphs(
            &self,
            request: tonic::Request<super::super::types::GetOverviewGraphsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetOverviewGraphsResponse>,
            tonic::Status,
        >;
        /// Get network proof request parameters.
        async fn get_proof_request_params(
            &self,
            request: tonic::Request<super::super::types::GetProofRequestParamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestParamsResponse>,
            tonic::Status,
        >;
        /// Get the nonce of the account.
        async fn get_nonce(
            &self,
            request: tonic::Request<super::super::types::GetNonceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetNonceResponse>,
            tonic::Status,
        >;
        /// Set the name of the account.
        async fn set_account_name(
            &self,
            request: tonic::Request<super::super::types::SetAccountNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetAccountNameResponse>,
            tonic::Status,
        >;
        /// Get the name of the account.
        async fn get_account_name(
            &self,
            request: tonic::Request<super::super::types::GetAccountNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAccountNameResponse>,
            tonic::Status,
        >;
        /// Get whether the account has signed the terms.
        async fn get_terms_signature(
            &self,
            request: tonic::Request<super::super::types::GetTermsSignatureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTermsSignatureResponse>,
            tonic::Status,
        >;
        /// Set whether the account has signed the terms.
        async fn set_terms_signature(
            &self,
            request: tonic::Request<super::super::types::SetTermsSignatureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetTermsSignatureResponse>,
            tonic::Status,
        >;
        /// Get all the information about an account.
        async fn get_account(
            &self,
            request: tonic::Request<super::super::types::GetAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAccountResponse>,
            tonic::Status,
        >;
        /// Get the owner of an account. Returns itself if the account is not delegated.
        async fn get_owner(
            &self,
            request: tonic::Request<super::super::types::GetOwnerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetOwnerResponse>,
            tonic::Status,
        >;
        /// Get metadata about a program.
        async fn get_program(
            &self,
            request: tonic::Request<super::super::types::GetProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProgramResponse>,
            tonic::Status,
        >;
        /// Create a new program. Must be called before requesting proofs.
        async fn create_program(
            &self,
            request: tonic::Request<super::super::types::CreateProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::CreateProgramResponse>,
            tonic::Status,
        >;
        /// Set the name of the program. Only callable by the owner.
        async fn set_program_name(
            &self,
            request: tonic::Request<super::super::types::SetProgramNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetProgramNameResponse>,
            tonic::Status,
        >;
        /// Get the available balance of an account.
        async fn get_balance(
            &self,
            request: tonic::Request<super::super::types::GetBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetBalanceResponse>,
            tonic::Status,
        >;
        /// Get the balance logs that meet the filter criteria.
        async fn get_filtered_balance_logs(
            &self,
            request: tonic::Request<super::super::types::GetFilteredBalanceLogsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredBalanceLogsResponse>,
            tonic::Status,
        >;
        /// Get the latest processed block in the bridge.
        async fn get_latest_bridge_block(
            &self,
            request: tonic::Request<super::super::types::GetLatestBridgeBlockRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLatestBridgeBlockResponse>,
            tonic::Status,
        >;
        /// Get the gas price estimate for a given fulfillment strategy.
        async fn get_gas_price_estimate(
            &self,
            request: tonic::Request<super::super::types::GetGasPriceEstimateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetGasPriceEstimateResponse>,
            tonic::Status,
        >;
        /// Get the details of a transaction.
        async fn get_transaction_details(
            &self,
            request: tonic::Request<super::super::types::GetTransactionDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTransactionDetailsResponse>,
            tonic::Status,
        >;
        /// Transfer $PROVE from one account to another.
        async fn transfer(
            &self,
            request: tonic::Request<super::super::types::TransferRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::TransferResponse>,
            tonic::Status,
        >;
        /// Get transfer parameters.
        async fn get_transfer_params(
            &self,
            request: tonic::Request<super::super::types::GetTransferParamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTransferParamsResponse>,
            tonic::Status,
        >;
        /// Get withdraw parameters.
        async fn get_withdraw_params(
            &self,
            request: tonic::Request<super::super::types::GetWithdrawParamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetWithdrawParamsResponse>,
            tonic::Status,
        >;
        /// Withdraw $PROVE from an account.
        async fn withdraw(
            &self,
            request: tonic::Request<super::super::types::WithdrawRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::WithdrawResponse>,
            tonic::Status,
        >;
        /// Bid for a proof request. Provers that want to be assigned this request must first
        /// bid on it.
        async fn bid(
            &self,
            request: tonic::Request<super::super::types::BidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::BidResponse>,
            tonic::Status,
        >;
        /// Settle the bids on a proof request to choose the assigned prover. Only callable by
        /// the approved auctioneer.
        async fn settle(
            &self,
            request: tonic::Request<super::super::types::SettleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SettleResponse>,
            tonic::Status,
        >;
        /// Get the provers that have historically had reliable uptime.
        async fn get_provers_by_uptime(
            &self,
            request: tonic::Request<super::super::types::GetProversByUptimeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProversByUptimeResponse>,
            tonic::Status,
        >;
        /// Get settleable proof requests that have passed auction period and have bids.
        async fn get_filtered_settleable_requests(
            &self,
            request: tonic::Request<
                super::super::types::GetFilteredSettleableRequestsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredSettleableRequestsResponse>,
            tonic::Status,
        >;
        /// Get suspendable provers that have recently failed proofs.
        async fn get_filtered_suspendable_provers(
            &self,
            request: tonic::Request<
                super::super::types::GetFilteredSuspendableProversRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredSuspendableProversResponse>,
            tonic::Status,
        >;
        /// Suspend a prover.
        async fn suspend_prover(
            &self,
            request: tonic::Request<super::super::types::SuspendProverRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SuspendProverResponse>,
            tonic::Status,
        >;
        /// Sign in with Ethereum
        async fn sign_in(
            &self,
            request: tonic::Request<super::super::types::SignInRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SignInResponse>,
            tonic::Status,
        >;
        /// Connect a Twitter account.
        async fn connect_twitter(
            &self,
            request: tonic::Request<super::super::types::ConnectTwitterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ConnectTwitterResponse>,
            tonic::Status,
        >;
        /// Get metrics for a specific prover
        async fn get_prover_stats(
            &self,
            request: tonic::Request<super::super::types::GetProverStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverStatsResponse>,
            tonic::Status,
        >;
        /// Get statistics for all provers with pagination
        async fn get_filtered_prover_stats(
            &self,
            request: tonic::Request<super::super::types::GetFilteredProverStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProverStatsResponse>,
            tonic::Status,
        >;
        /// Get detailed statistics for a single prover by address
        async fn get_prover_stats_detail(
            &self,
            request: tonic::Request<super::super::types::GetProverStatsDetailRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverStatsDetailResponse>,
            tonic::Status,
        >;
        /// Get search results for provers
        async fn get_prover_search_results(
            &self,
            request: tonic::Request<super::super::types::GetProverSearchResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverSearchResultsResponse>,
            tonic::Status,
        >;
        /// Search provers by name or address with staking information
        async fn get_staking_prover_search(
            &self,
            request: tonic::Request<super::super::types::GetStakingProverSearchRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetStakingProverSearchResponse>,
            tonic::Status,
        >;
        /// Get paginated auction history
        async fn get_filtered_bid_history(
            &self,
            request: tonic::Request<super::super::types::GetFilteredBidHistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredBidHistoryResponse>,
            tonic::Status,
        >;
        /// Get filtered bid history for a prover with pagination
        async fn get_filtered_prover_bid_history(
            &self,
            request: tonic::Request<
                super::super::types::GetFilteredProverBidHistoryRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProverBidHistoryResponse>,
            tonic::Status,
        >;
        /// Check if the user is whitelisted to use the TEE service.
        async fn get_tee_whitelist_status(
            &self,
            request: tonic::Request<super::super::types::GetTeeWhitelistStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTeeWhitelistStatusResponse>,
            tonic::Status,
        >;
        /// Get the provers that meet the filter criteria.
        async fn get_filtered_provers(
            &self,
            request: tonic::Request<super::super::types::GetFilteredProversRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProversResponse>,
            tonic::Status,
        >;
        /// Get the available balance of a prover.
        async fn get_prover_stake_balance(
            &self,
            request: tonic::Request<super::super::types::GetProverStakeBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverStakeBalanceResponse>,
            tonic::Status,
        >;
        /// Get the staker balance logs that meet the filter criteria.
        async fn get_filtered_staker_stake_balance_logs(
            &self,
            request: tonic::Request<
                super::super::types::GetFilteredStakerStakeBalanceLogsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::super::types::GetFilteredStakerStakeBalanceLogsResponse,
            >,
            tonic::Status,
        >;
        /// Get the prover balance logs that meet the filter criteria.
        async fn get_filtered_prover_stake_balance_logs(
            &self,
            request: tonic::Request<
                super::super::types::GetFilteredProverStakeBalanceLogsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::super::types::GetFilteredProverStakeBalanceLogsResponse,
            >,
            tonic::Status,
        >;
        /// Get the delegation parameters.
        async fn get_delegation_params(
            &self,
            request: tonic::Request<super::super::types::GetDelegationParamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetDelegationParamsResponse>,
            tonic::Status,
        >;
        /// Set a delegation.
        async fn set_delegation(
            &self,
            request: tonic::Request<super::super::types::SetDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetDelegationResponse>,
            tonic::Status,
        >;
        /// Get a delegation.
        async fn get_delegation(
            &self,
            request: tonic::Request<super::super::types::GetDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetDelegationResponse>,
            tonic::Status,
        >;
        /// Get the withdrawal receipts of an account.
        async fn get_filtered_withdrawal_receipts(
            &self,
            request: tonic::Request<
                super::super::types::GetFilteredWithdrawalReceiptsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredWithdrawalReceiptsResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct ProverNetworkServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ProverNetworkServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ProverNetworkServer<T>
    where
        T: ProverNetwork,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/network.ProverNetwork/RequestProof" => {
                    #[allow(non_camel_case_types)]
                    struct RequestProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::RequestProofRequest,
                    > for RequestProofSvc<T> {
                        type Response = super::super::types::RequestProofResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::RequestProofRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::request_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RequestProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/FulfillProof" => {
                    #[allow(non_camel_case_types)]
                    struct FulfillProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::FulfillProofRequest,
                    > for FulfillProofSvc<T> {
                        type Response = super::super::types::FulfillProofResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::FulfillProofRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::fulfill_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FulfillProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ExecuteProof" => {
                    #[allow(non_camel_case_types)]
                    struct ExecuteProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::ExecuteProofRequest,
                    > for ExecuteProofSvc<T> {
                        type Response = super::super::types::ExecuteProofResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::ExecuteProofRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::execute_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecuteProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/FailFulfillment" => {
                    #[allow(non_camel_case_types)]
                    struct FailFulfillmentSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::FailFulfillmentRequest,
                    > for FailFulfillmentSvc<T> {
                        type Response = super::super::types::FailFulfillmentResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::FailFulfillmentRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::fail_fulfillment(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FailFulfillmentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestStatusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProofRequestStatusRequest,
                    > for GetProofRequestStatusSvc<T> {
                        type Response = super::super::types::GetProofRequestStatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProofRequestStatusRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_status(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestDetails" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestDetailsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProofRequestDetailsRequest,
                    > for GetProofRequestDetailsSvc<T> {
                        type Response = super::super::types::GetProofRequestDetailsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProofRequestDetailsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_details(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProofRequests" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProofRequestsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredProofRequestsRequest,
                    > for GetFilteredProofRequestsSvc<T> {
                        type Response = super::super::types::GetFilteredProofRequestsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredProofRequestsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_proof_requests(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProofRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SubscribeProofRequests" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeProofRequestsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::ServerStreamingService<
                        super::super::types::GetFilteredProofRequestsRequest,
                    > for SubscribeProofRequestsSvc<T> {
                        type Response = super::super::types::ProofRequest;
                        type ResponseStream = T::SubscribeProofRequestsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredProofRequestsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::subscribe_proof_requests(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeProofRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetSearchResults" => {
                    #[allow(non_camel_case_types)]
                    struct GetSearchResultsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetSearchResultsRequest,
                    > for GetSearchResultsSvc<T> {
                        type Response = super::super::types::GetSearchResultsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetSearchResultsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_search_results(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSearchResultsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestMetricsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProofRequestMetricsRequest,
                    > for GetProofRequestMetricsSvc<T> {
                        type Response = super::super::types::GetProofRequestMetricsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProofRequestMetricsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_metrics(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestGraph" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestGraphSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProofRequestGraphRequest,
                    > for GetProofRequestGraphSvc<T> {
                        type Response = super::super::types::GetProofRequestGraphResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProofRequestGraphRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_graph(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestGraphSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetAnalyticsGraphs" => {
                    #[allow(non_camel_case_types)]
                    struct GetAnalyticsGraphsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetAnalyticsGraphsRequest,
                    > for GetAnalyticsGraphsSvc<T> {
                        type Response = super::super::types::GetAnalyticsGraphsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetAnalyticsGraphsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_analytics_graphs(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAnalyticsGraphsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetOverviewGraphs" => {
                    #[allow(non_camel_case_types)]
                    struct GetOverviewGraphsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetOverviewGraphsRequest,
                    > for GetOverviewGraphsSvc<T> {
                        type Response = super::super::types::GetOverviewGraphsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetOverviewGraphsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_overview_graphs(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOverviewGraphsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestParams" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestParamsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProofRequestParamsRequest,
                    > for GetProofRequestParamsSvc<T> {
                        type Response = super::super::types::GetProofRequestParamsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProofRequestParamsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_params(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestParamsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetNonce" => {
                    #[allow(non_camel_case_types)]
                    struct GetNonceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::GetNonceRequest>
                    for GetNonceSvc<T> {
                        type Response = super::super::types::GetNonceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetNonceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_nonce(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetNonceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetAccountName" => {
                    #[allow(non_camel_case_types)]
                    struct SetAccountNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetAccountNameRequest,
                    > for SetAccountNameSvc<T> {
                        type Response = super::super::types::SetAccountNameResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetAccountNameRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_account_name(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetAccountNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetAccountName" => {
                    #[allow(non_camel_case_types)]
                    struct GetAccountNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetAccountNameRequest,
                    > for GetAccountNameSvc<T> {
                        type Response = super::super::types::GetAccountNameResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetAccountNameRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_account_name(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAccountNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTermsSignature" => {
                    #[allow(non_camel_case_types)]
                    struct GetTermsSignatureSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetTermsSignatureRequest,
                    > for GetTermsSignatureSvc<T> {
                        type Response = super::super::types::GetTermsSignatureResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetTermsSignatureRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_terms_signature(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTermsSignatureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetTermsSignature" => {
                    #[allow(non_camel_case_types)]
                    struct SetTermsSignatureSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetTermsSignatureRequest,
                    > for SetTermsSignatureSvc<T> {
                        type Response = super::super::types::SetTermsSignatureResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetTermsSignatureRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_terms_signature(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetTermsSignatureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetAccount" => {
                    #[allow(non_camel_case_types)]
                    struct GetAccountSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::GetAccountRequest>
                    for GetAccountSvc<T> {
                        type Response = super::super::types::GetAccountResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetAccountRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_account(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAccountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetOwner" => {
                    #[allow(non_camel_case_types)]
                    struct GetOwnerSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::GetOwnerRequest>
                    for GetOwnerSvc<T> {
                        type Response = super::super::types::GetOwnerResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetOwnerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_owner(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOwnerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProgram" => {
                    #[allow(non_camel_case_types)]
                    struct GetProgramSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::GetProgramRequest>
                    for GetProgramSvc<T> {
                        type Response = super::super::types::GetProgramResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProgramRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_program(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProgramSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/CreateProgram" => {
                    #[allow(non_camel_case_types)]
                    struct CreateProgramSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::CreateProgramRequest,
                    > for CreateProgramSvc<T> {
                        type Response = super::super::types::CreateProgramResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::CreateProgramRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::create_program(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateProgramSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetProgramName" => {
                    #[allow(non_camel_case_types)]
                    struct SetProgramNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetProgramNameRequest,
                    > for SetProgramNameSvc<T> {
                        type Response = super::super::types::SetProgramNameResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetProgramNameRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_program_name(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetProgramNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetBalance" => {
                    #[allow(non_camel_case_types)]
                    struct GetBalanceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::GetBalanceRequest>
                    for GetBalanceSvc<T> {
                        type Response = super::super::types::GetBalanceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetBalanceRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_balance(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBalanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredBalanceLogs" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredBalanceLogsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredBalanceLogsRequest,
                    > for GetFilteredBalanceLogsSvc<T> {
                        type Response = super::super::types::GetFilteredBalanceLogsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredBalanceLogsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_balance_logs(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredBalanceLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLatestBridgeBlock" => {
                    #[allow(non_camel_case_types)]
                    struct GetLatestBridgeBlockSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetLatestBridgeBlockRequest,
                    > for GetLatestBridgeBlockSvc<T> {
                        type Response = super::super::types::GetLatestBridgeBlockResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetLatestBridgeBlockRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_latest_bridge_block(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLatestBridgeBlockSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetGasPriceEstimate" => {
                    #[allow(non_camel_case_types)]
                    struct GetGasPriceEstimateSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetGasPriceEstimateRequest,
                    > for GetGasPriceEstimateSvc<T> {
                        type Response = super::super::types::GetGasPriceEstimateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetGasPriceEstimateRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_gas_price_estimate(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetGasPriceEstimateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTransactionDetails" => {
                    #[allow(non_camel_case_types)]
                    struct GetTransactionDetailsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetTransactionDetailsRequest,
                    > for GetTransactionDetailsSvc<T> {
                        type Response = super::super::types::GetTransactionDetailsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetTransactionDetailsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_transaction_details(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTransactionDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Transfer" => {
                    #[allow(non_camel_case_types)]
                    struct TransferSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::TransferRequest>
                    for TransferSvc<T> {
                        type Response = super::super::types::TransferResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::TransferRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::transfer(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TransferSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTransferParams" => {
                    #[allow(non_camel_case_types)]
                    struct GetTransferParamsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetTransferParamsRequest,
                    > for GetTransferParamsSvc<T> {
                        type Response = super::super::types::GetTransferParamsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetTransferParamsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_transfer_params(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTransferParamsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetWithdrawParams" => {
                    #[allow(non_camel_case_types)]
                    struct GetWithdrawParamsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetWithdrawParamsRequest,
                    > for GetWithdrawParamsSvc<T> {
                        type Response = super::super::types::GetWithdrawParamsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetWithdrawParamsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_withdraw_params(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetWithdrawParamsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Withdraw" => {
                    #[allow(non_camel_case_types)]
                    struct WithdrawSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::WithdrawRequest>
                    for WithdrawSvc<T> {
                        type Response = super::super::types::WithdrawResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::WithdrawRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::withdraw(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = WithdrawSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Bid" => {
                    #[allow(non_camel_case_types)]
                    struct BidSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::BidRequest>
                    for BidSvc<T> {
                        type Response = super::super::types::BidResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::BidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::bid(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Settle" => {
                    #[allow(non_camel_case_types)]
                    struct SettleSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::SettleRequest>
                    for SettleSvc<T> {
                        type Response = super::super::types::SettleResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SettleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::settle(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SettleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProversByUptime" => {
                    #[allow(non_camel_case_types)]
                    struct GetProversByUptimeSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProversByUptimeRequest,
                    > for GetProversByUptimeSvc<T> {
                        type Response = super::super::types::GetProversByUptimeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProversByUptimeRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_provers_by_uptime(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProversByUptimeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredSettleableRequests" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredSettleableRequestsSvc<T: ProverNetwork>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredSettleableRequestsRequest,
                    > for GetFilteredSettleableRequestsSvc<T> {
                        type Response = super::super::types::GetFilteredSettleableRequestsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredSettleableRequestsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_settleable_requests(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredSettleableRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredSuspendableProvers" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredSuspendableProversSvc<T: ProverNetwork>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredSuspendableProversRequest,
                    > for GetFilteredSuspendableProversSvc<T> {
                        type Response = super::super::types::GetFilteredSuspendableProversResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredSuspendableProversRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_suspendable_provers(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredSuspendableProversSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SuspendProver" => {
                    #[allow(non_camel_case_types)]
                    struct SuspendProverSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SuspendProverRequest,
                    > for SuspendProverSvc<T> {
                        type Response = super::super::types::SuspendProverResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SuspendProverRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::suspend_prover(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SuspendProverSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SignIn" => {
                    #[allow(non_camel_case_types)]
                    struct SignInSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::SignInRequest>
                    for SignInSvc<T> {
                        type Response = super::super::types::SignInResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SignInRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::sign_in(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SignInSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ConnectTwitter" => {
                    #[allow(non_camel_case_types)]
                    struct ConnectTwitterSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::ConnectTwitterRequest,
                    > for ConnectTwitterSvc<T> {
                        type Response = super::super::types::ConnectTwitterResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::ConnectTwitterRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::connect_twitter(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConnectTwitterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverStatsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProverStatsRequest,
                    > for GetProverStatsSvc<T> {
                        type Response = super::super::types::GetProverStatsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProverStatsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_stats(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProverStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProverStatsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredProverStatsRequest,
                    > for GetFilteredProverStatsSvc<T> {
                        type Response = super::super::types::GetFilteredProverStatsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredProverStatsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_prover_stats(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProverStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverStatsDetail" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverStatsDetailSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProverStatsDetailRequest,
                    > for GetProverStatsDetailSvc<T> {
                        type Response = super::super::types::GetProverStatsDetailResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProverStatsDetailRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_stats_detail(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverStatsDetailSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverSearchResults" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverSearchResultsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProverSearchResultsRequest,
                    > for GetProverSearchResultsSvc<T> {
                        type Response = super::super::types::GetProverSearchResultsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProverSearchResultsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_search_results(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverSearchResultsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetStakingProverSearch" => {
                    #[allow(non_camel_case_types)]
                    struct GetStakingProverSearchSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetStakingProverSearchRequest,
                    > for GetStakingProverSearchSvc<T> {
                        type Response = super::super::types::GetStakingProverSearchResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetStakingProverSearchRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_staking_prover_search(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetStakingProverSearchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredBidHistory" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredBidHistorySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredBidHistoryRequest,
                    > for GetFilteredBidHistorySvc<T> {
                        type Response = super::super::types::GetFilteredBidHistoryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredBidHistoryRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_bid_history(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredBidHistorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProverBidHistory" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProverBidHistorySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredProverBidHistoryRequest,
                    > for GetFilteredProverBidHistorySvc<T> {
                        type Response = super::super::types::GetFilteredProverBidHistoryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredProverBidHistoryRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_prover_bid_history(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProverBidHistorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTEEWhitelistStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetTEEWhitelistStatusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetTeeWhitelistStatusRequest,
                    > for GetTEEWhitelistStatusSvc<T> {
                        type Response = super::super::types::GetTeeWhitelistStatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetTeeWhitelistStatusRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_tee_whitelist_status(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTEEWhitelistStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProvers" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProversSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredProversRequest,
                    > for GetFilteredProversSvc<T> {
                        type Response = super::super::types::GetFilteredProversResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredProversRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_provers(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProversSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverStakeBalance" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverStakeBalanceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProverStakeBalanceRequest,
                    > for GetProverStakeBalanceSvc<T> {
                        type Response = super::super::types::GetProverStakeBalanceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProverStakeBalanceRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_stake_balance(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverStakeBalanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredStakerStakeBalanceLogs" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredStakerStakeBalanceLogsSvc<T: ProverNetwork>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredStakerStakeBalanceLogsRequest,
                    > for GetFilteredStakerStakeBalanceLogsSvc<T> {
                        type Response = super::super::types::GetFilteredStakerStakeBalanceLogsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredStakerStakeBalanceLogsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_staker_stake_balance_logs(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredStakerStakeBalanceLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProverStakeBalanceLogs" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProverStakeBalanceLogsSvc<T: ProverNetwork>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredProverStakeBalanceLogsRequest,
                    > for GetFilteredProverStakeBalanceLogsSvc<T> {
                        type Response = super::super::types::GetFilteredProverStakeBalanceLogsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredProverStakeBalanceLogsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_prover_stake_balance_logs(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProverStakeBalanceLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetDelegationParams" => {
                    #[allow(non_camel_case_types)]
                    struct GetDelegationParamsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetDelegationParamsRequest,
                    > for GetDelegationParamsSvc<T> {
                        type Response = super::super::types::GetDelegationParamsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetDelegationParamsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_delegation_params(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetDelegationParamsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct SetDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetDelegationRequest,
                    > for SetDelegationSvc<T> {
                        type Response = super::super::types::SetDelegationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetDelegationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_delegation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct GetDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetDelegationRequest,
                    > for GetDelegationSvc<T> {
                        type Response = super::super::types::GetDelegationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetDelegationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_delegation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredWithdrawalReceipts" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredWithdrawalReceiptsSvc<T: ProverNetwork>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredWithdrawalReceiptsRequest,
                    > for GetFilteredWithdrawalReceiptsSvc<T> {
                        type Response = super::super::types::GetFilteredWithdrawalReceiptsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredWithdrawalReceiptsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_withdrawal_receipts(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredWithdrawalReceiptsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ProverNetworkServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "network.ProverNetwork";
    impl<T> tonic::server::NamedService for ProverNetworkServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
