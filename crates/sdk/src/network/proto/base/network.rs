// This file is @generated by prost-build.
/// Generated client implementations.
pub mod prover_network_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct ProverNetworkClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ProverNetworkClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ProverNetworkClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ProverNetworkClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ProverNetworkClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a proof request.
        pub async fn request_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::RequestProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RequestProofResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/RequestProof",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RequestProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Fulfills a proof request. Only callable by the assigned fulfiller.
        pub async fn fulfill_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::FulfillProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::FulfillProofResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/FulfillProof",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "FulfillProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Executes a proof request. Only callable by the execution oracle.
        pub async fn execute_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::ExecuteProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ExecuteProofResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/ExecuteProof",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "ExecuteProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Fails fulfillment. Only callable by the assigned fulfiller.
        pub async fn fail_fulfillment(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::FailFulfillmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::FailFulfillmentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/FailFulfillment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "FailFulfillment"));
            self.inner.unary(req, path, codec).await
        }
        /// Fails execution. Only callable by the execution oracle.
        pub async fn fail_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::FailExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::FailExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/FailExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "FailExecution"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the status of a proof request.
        pub async fn get_proof_request_status(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetProofRequestStatusRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProofRequestStatus"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the details of a proof request.
        pub async fn get_proof_request_details(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetProofRequestDetailsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestDetailsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProofRequestDetails"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the proof requests that meet the filter criteria.
        pub async fn get_filtered_proof_requests(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredProofRequestsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProofRequestsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProofRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredProofRequests"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Subscribe to proof requests that meet the filter criteria.
        pub async fn subscribe_proof_requests(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredProofRequestsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::super::types::ProofRequest>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SubscribeProofRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "SubscribeProofRequests"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Search for proof requests, programs, and requesters.
        pub async fn get_search_results(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetSearchResultsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetSearchResultsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetSearchResults",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetSearchResults"));
            self.inner.unary(req, path, codec).await
        }
        /// Get metrics for proof requests.
        pub async fn get_proof_request_metrics(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetProofRequestMetricsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestMetricsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProofRequestMetrics"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get time series data for proof requests.
        pub async fn get_proof_request_graph(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetProofRequestGraphRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestGraphResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestGraph",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProofRequestGraph"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get analytics graphs for proof requests.
        pub async fn get_analytics_graphs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetAnalyticsGraphsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAnalyticsGraphsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetAnalyticsGraphs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetAnalyticsGraphs"));
            self.inner.unary(req, path, codec).await
        }
        /// Get overview graphs for proof requests.
        pub async fn get_overview_graphs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetOverviewGraphsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetOverviewGraphsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetOverviewGraphs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetOverviewGraphs"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the nonce of the account.
        pub async fn get_nonce(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetNonceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetNonceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetNonce",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetNonce"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the delegations of the account.
        pub async fn get_filtered_delegations(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredDelegationsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredDelegationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredDelegations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredDelegations"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Add a delegation. Only callable by the owner of an account.
        pub async fn add_delegation(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::AddDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::AddDelegationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/AddDelegation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "AddDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Remove a delegation. Only callable by the owner of an account.
        pub async fn remove_delegation(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::RemoveDelegationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RemoveDelegationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/RemoveDelegation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RemoveDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Terminate a delegation. Only callable by the delegate of a delegation.
        pub async fn terminate_delegation(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::TerminateDelegationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::TerminateDelegationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/TerminateDelegation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "TerminateDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Accept a delegation. Only callable by the delegate of a delegation.
        pub async fn accept_delegation(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::AcceptDelegationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::AcceptDelegationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/AcceptDelegation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "AcceptDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the name of the account. Only callable by the owner of an account.
        pub async fn set_account_name(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetAccountNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetAccountNameResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetAccountName",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetAccountName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the name of the account.
        pub async fn get_account_name(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetAccountNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAccountNameResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetAccountName",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetAccountName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get whether the account has signed the terms.
        pub async fn get_terms_signature(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetTermsSignatureRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTermsSignatureResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetTermsSignature",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetTermsSignature"));
            self.inner.unary(req, path, codec).await
        }
        /// Set whether the account has signed the terms.
        pub async fn set_terms_signature(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::SetTermsSignatureRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetTermsSignatureResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetTermsSignature",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetTermsSignature"));
            self.inner.unary(req, path, codec).await
        }
        /// Get all the information about an account.
        pub async fn get_account(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetAccount"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the owner of an account. Returns itself if the account is not delegated.
        pub async fn get_owner(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetOwnerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetOwnerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetOwner",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetOwner"));
            self.inner.unary(req, path, codec).await
        }
        /// Get metadata about a program.
        pub async fn get_program(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProgramResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProgram",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProgram"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new program. Must be called before requesting proofs.
        pub async fn create_program(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::CreateProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::CreateProgramResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/CreateProgram",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "CreateProgram"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the name of the program. Only callable by the owner.
        pub async fn set_program_name(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetProgramNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetProgramNameResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetProgramName",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetProgramName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the available balance of an account.
        pub async fn get_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetBalanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetBalance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetBalance"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the balance logs that meet the filter criteria.
        pub async fn get_filtered_balance_logs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredBalanceLogsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredBalanceLogsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredBalanceLogs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredBalanceLogs"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Add credit to an account.
        pub async fn add_credit(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::AddCreditRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::AddCreditResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/AddCredit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "AddCredit"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the latest processed block in the bridge.
        pub async fn get_latest_bridge_block(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetLatestBridgeBlockRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLatestBridgeBlockResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetLatestBridgeBlock",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetLatestBridgeBlock"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the gas price estimate for a given fulfillment strategy.
        pub async fn get_gas_price_estimate(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetGasPriceEstimateRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetGasPriceEstimateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetGasPriceEstimate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetGasPriceEstimate"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the details of a transaction.
        pub async fn get_transaction_details(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetTransactionDetailsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTransactionDetailsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetTransactionDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetTransactionDetails"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Add a charge to an account.
        pub async fn add_reserved_charge(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::AddReservedChargeRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::AddReservedChargeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/AddReservedCharge",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "AddReservedCharge"));
            self.inner.unary(req, path, codec).await
        }
        /// Get prorated billing summary by month for a specified payer.
        pub async fn get_billing_summary(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetBillingSummaryRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetBillingSummaryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetBillingSummary",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetBillingSummary"));
            self.inner.unary(req, path, codec).await
        }
        /// Update the charge type price for a reservation.
        pub async fn update_price(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::UpdatePriceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::UpdatePriceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/UpdatePrice",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "UpdatePrice"));
            self.inner.unary(req, path, codec).await
        }
        /// Get filtered and paginated clusters/fulfillers with prices.
        pub async fn get_filtered_clusters(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredClustersRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredClustersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredClusters",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredClusters"));
            self.inner.unary(req, path, codec).await
        }
        /// Get usage summary by month for a specified payer.
        pub async fn get_usage_summary(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetUsageSummaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetUsageSummaryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetUsageSummary",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetUsageSummary"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the charges that meet the filter criteria.
        pub async fn get_filtered_charges(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredChargesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredChargesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredCharges",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredCharges"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the reservations that meet the filter criteria.
        pub async fn get_filtered_reservations(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredReservationsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredReservationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredReservations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredReservations"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Add a reservation for a requester.
        pub async fn add_reservation(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::AddReservationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::AddReservationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/AddReservation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "AddReservation"));
            self.inner.unary(req, path, codec).await
        }
        /// Remove a reservation for a requester.
        pub async fn remove_reservation(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::RemoveReservationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RemoveReservationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/RemoveReservation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RemoveReservation"));
            self.inner.unary(req, path, codec).await
        }
        /// Bid for a proof request. Provers that want to be assigned this request must first
        /// bid on it.
        pub async fn bid(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::BidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::BidResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/Bid",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "Bid"));
            self.inner.unary(req, path, codec).await
        }
        /// Settle the bids on a proof request to choose the assigned prover. Only callable by
        /// the approved auctioneer.
        pub async fn settle(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SettleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SettleResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/Settle",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "Settle"));
            self.inner.unary(req, path, codec).await
        }
        /// Sign in with Ethereum
        pub async fn sign_in(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SignInRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SignInResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SignIn",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SignIn"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the accounts that meet the filter criteria.
        pub async fn get_onboarded_accounts_count(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetOnboardedAccountsCountRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetOnboardedAccountsCountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetOnboardedAccountsCount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetOnboardedAccountsCount"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the accounts that have joined the leaderboard.
        pub async fn get_filtered_onboarded_accounts(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredOnboardedAccountsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredOnboardedAccountsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredOnboardedAccounts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "GetFilteredOnboardedAccounts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the leaderboard.
        pub async fn get_leaderboard(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLeaderboardResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetLeaderboard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetLeaderboard"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the leaderboard stats for a given account.
        pub async fn get_leaderboard_stats(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetLeaderboardStatsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLeaderboardStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetLeaderboardStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetLeaderboardStats"));
            self.inner.unary(req, path, codec).await
        }
        /// Get codes.
        pub async fn get_codes(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetCodesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetCodesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetCodes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetCodes"));
            self.inner.unary(req, path, codec).await
        }
        /// Redeem a code.
        pub async fn redeem_code(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::RedeemCodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RedeemCodeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/RedeemCode",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RedeemCode"));
            self.inner.unary(req, path, codec).await
        }
        /// Connect a Twitter account.
        pub async fn connect_twitter(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::ConnectTwitterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ConnectTwitterResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/ConnectTwitter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "ConnectTwitter"));
            self.inner.unary(req, path, codec).await
        }
        /// Complete onboarding.
        pub async fn complete_onboarding(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::CompleteOnboardingRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::CompleteOnboardingResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/CompleteOnboarding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "CompleteOnboarding"));
            self.inner.unary(req, path, codec).await
        }
        /// Set if a user should display their Twitter handle.
        pub async fn set_use_twitter_handle(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::SetUseTwitterHandleRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetUseTwitterHandleResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetUseTwitterHandle",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetUseTwitterHandle"));
            self.inner.unary(req, path, codec).await
        }
        /// Set if a user should display their Twitter profile picture.
        pub async fn set_use_twitter_image(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::SetUseTwitterImageRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetUseTwitterImageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetUseTwitterImage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetUseTwitterImage"));
            self.inner.unary(req, path, codec).await
        }
        /// Request a random proof.
        pub async fn request_random_proof(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::RequestRandomProofRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RequestRandomProofResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/RequestRandomProof",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RequestRandomProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit answers for the captcha game.
        pub async fn submit_captcha_game(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::SubmitCaptchaGameRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SubmitCaptchaGameResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SubmitCaptchaGame",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SubmitCaptchaGame"));
            self.inner.unary(req, path, codec).await
        }
        /// Redeem stars.
        pub async fn redeem_stars(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::RedeemStarsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RedeemStarsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/RedeemStars",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RedeemStars"));
            self.inner.unary(req, path, codec).await
        }
        /// Get flappy leaderboard.
        pub async fn get_flappy_leaderboard(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFlappyLeaderboardRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFlappyLeaderboardResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFlappyLeaderboard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFlappyLeaderboard"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set the turbo game high score.
        pub async fn set_turbo_high_score(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::SetTurboHighScoreRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetTurboHighScoreResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetTurboHighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetTurboHighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit answers for the quiz game.
        pub async fn submit_quiz_game(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SubmitQuizGameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SubmitQuizGameResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SubmitQuizGame",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SubmitQuizGame"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the turbo game leaderboard.
        pub async fn get_turbo_leaderboard(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetTurboLeaderboardRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTurboLeaderboardResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetTurboLeaderboard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetTurboLeaderboard"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit ETH block metadata.
        pub async fn submit_eth_block_metadata(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::SubmitEthBlockMetadataRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SubmitEthBlockMetadataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SubmitEthBlockMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "SubmitEthBlockMetadata"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get ETH block requests that meet the filter criteria.
        pub async fn get_filtered_eth_block_requests(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredEthBlockRequestsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredEthBlockRequestsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredEthBlockRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "GetFilteredEthBlockRequests",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set the 2048 game high score.
        pub async fn set2048_high_score(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::Set2048HighScoreRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::Set2048HighScoreResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/Set2048HighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "Set2048HighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the volleyball game high score.
        pub async fn set_volleyball_high_score(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::SetVolleyballHighScoreRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetVolleyballHighScoreResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetVolleyballHighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "SetVolleyballHighScore"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get ETH block proof requests metrics.
        pub async fn get_eth_block_request_metrics(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetEthBlockRequestMetricsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetEthBlockRequestMetricsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetEthBlockRequestMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetEthBlockRequestMetrics"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set the turbo time trial high score.
        pub async fn set_turbo_time_trial_high_score(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::SetTurboTimeTrialHighScoreRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetTurboTimeTrialHighScoreResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetTurboTimeTrialHighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "SetTurboTimeTrialHighScore",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set the coin craze high score.
        pub async fn set_coin_craze_high_score(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::SetCoinCrazeHighScoreRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetCoinCrazeHighScoreResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetCoinCrazeHighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "SetCoinCrazeHighScore"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set the lean high score.
        pub async fn set_lean_high_score(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::SetLeanHighScoreRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetLeanHighScoreResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetLeanHighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetLeanHighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the flow high score.
        pub async fn set_flow_high_score(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::SetFlowHighScoreRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetFlowHighScoreResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetFlowHighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetFlowHighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the rollup high score.
        pub async fn set_rollup_high_score(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::SetRollupHighScoreRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetRollupHighScoreResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetRollupHighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetRollupHighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the pending stars for an account.
        pub async fn get_pending_stars(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetPendingStarsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetPendingStarsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetPendingStars",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetPendingStars"));
            self.inner.unary(req, path, codec).await
        }
        /// Check if address or social identity is whitelisted.
        pub async fn get_whitelist_status(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetWhitelistStatusRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetWhitelistStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetWhitelistStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetWhitelistStatus"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the gpu delegate.
        pub async fn set_gpu_delegate(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetGpuDelegateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetGpuDelegateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetGpuDelegate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetGpuDelegate"));
            self.inner.unary(req, path, codec).await
        }
        /// Claim a gpu.
        pub async fn claim_gpu(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::ClaimGpuRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ClaimGpuResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/ClaimGpu",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "ClaimGpu"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the gpu variant.
        pub async fn set_gpu_variant(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetGpuVariantRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetGpuVariantResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetGpuVariant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetGpuVariant"));
            self.inner.unary(req, path, codec).await
        }
        /// Link a whitelisted twitter account.
        pub async fn link_whitelisted_twitter(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::LinkWhitelistedTwitterRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::LinkWhitelistedTwitterResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/LinkWhitelistedTwitter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "LinkWhitelistedTwitter"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve the proving key for your account. Must have claimed a gpu and self-delegated to
        /// yourself.
        pub async fn retrieve_proving_key(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::RetrieveProvingKeyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RetrieveProvingKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/RetrieveProvingKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RetrieveProvingKey"));
            self.inner.unary(req, path, codec).await
        }
        /// Link a whitelisted github account.
        pub async fn link_whitelisted_github(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::LinkWhitelistedGithubRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::LinkWhitelistedGithubResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/LinkWhitelistedGithub",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "LinkWhitelistedGithub"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Link a whitelisted discord account.
        pub async fn link_whitelisted_discord(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::LinkWhitelistedDiscordRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::LinkWhitelistedDiscordResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/LinkWhitelistedDiscord",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "LinkWhitelistedDiscord"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Link independent Discord account.
        pub async fn link_social_discord(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::LinkSocialDiscordRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::LinkSocialDiscordResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/LinkSocialDiscord",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "LinkSocialDiscord"));
            self.inner.unary(req, path, codec).await
        }
        /// Link independent Twitter account.
        pub async fn link_social_twitter(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::LinkSocialTwitterRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::LinkSocialTwitterResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/LinkSocialTwitter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "LinkSocialTwitter"));
            self.inner.unary(req, path, codec).await
        }
        /// Get linked social accounts for an address.
        pub async fn get_linked_social_accounts(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetLinkedSocialAccountsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLinkedSocialAccountsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetLinkedSocialAccounts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetLinkedSocialAccounts"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get prover leaderboard.
        pub async fn get_prover_leaderboard(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetProverLeaderboardRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverLeaderboardResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProverLeaderboard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProverLeaderboard"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get filtered gpus.
        pub async fn get_filtered_gpus(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetFilteredGpusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredGpusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredGpus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredGpus"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the gpu coordinates.
        pub async fn set_gpu_coordinates(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::SetGpuCoordinatesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetGpuCoordinatesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetGpuCoordinates",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetGpuCoordinates"));
            self.inner.unary(req, path, codec).await
        }
        /// Get points.
        pub async fn get_points(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetPointsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetPointsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetPoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetPoints"));
            self.inner.unary(req, path, codec).await
        }
        /// Process clicks.
        pub async fn process_clicks(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::ProcessClicksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ProcessClicksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/ProcessClicks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "ProcessClicks"));
            self.inner.unary(req, path, codec).await
        }
        /// Purchase upgrade.
        pub async fn purchase_upgrade(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::PurchaseUpgradeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::PurchaseUpgradeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/PurchaseUpgrade",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "PurchaseUpgrade"));
            self.inner.unary(req, path, codec).await
        }
        /// Place a bet.
        pub async fn bet(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::BetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::BetResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/Bet",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "Bet"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the status of a proof contest.
        pub async fn get_contest_details(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetContestDetailsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetContestDetailsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetContestDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetContestDetails"));
            self.inner.unary(req, path, codec).await
        }
        /// Get latest contest id.
        pub async fn get_latest_contest(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetLatestContestRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLatestContestResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetLatestContest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetLatestContest"));
            self.inner.unary(req, path, codec).await
        }
        /// Get contest bettors.
        pub async fn get_contest_bettors(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetContestBettorsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetContestBettorsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetContestBettors",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetContestBettors"));
            self.inner.unary(req, path, codec).await
        }
        /// Get gpu metrics.
        pub async fn get_gpu_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetGpuMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetGpuMetricsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetGpuMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetGpuMetrics"));
            self.inner.unary(req, path, codec).await
        }
        /// Get filtered prover activity.
        pub async fn get_filtered_prover_activity(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredProverActivityRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProverActivityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProverActivity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredProverActivity"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get prover metrics.
        pub async fn get_prover_metrics(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetProverMetricsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverMetricsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProverMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProverMetrics"));
            self.inner.unary(req, path, codec).await
        }
        /// Get filtered bet history.
        pub async fn get_filtered_bet_history(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredBetHistoryRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredBetHistoryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredBetHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredBetHistory"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get gpu team stats.
        pub async fn get_gpu_team_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetGpuTeamStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetGpuTeamStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetGpuTeamStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetGpuTeamStats"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the config values.
        pub async fn get_config_values(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetConfigValuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetConfigValuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetConfigValues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetConfigValues"));
            self.inner.unary(req, path, codec).await
        }
        /// Get metrics for a specific prover
        pub async fn get_prover_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetProverStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProverStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProverStats"));
            self.inner.unary(req, path, codec).await
        }
        /// Get statistics for all provers with pagination
        pub async fn get_filtered_prover_stats(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredProverStatsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProverStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProverStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredProverStats"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get search results for provers
        pub async fn get_prover_search_results(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetProverSearchResultsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverSearchResultsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProverSearchResults",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProverSearchResults"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get paginated auction history
        pub async fn get_filtered_bid_history(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredBidHistoryRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredBidHistoryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredBidHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredBidHistory"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Check if the user is whitelisted to use the TEE service.
        pub async fn get_tee_whitelist_status(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetTeeWhitelistStatusRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTeeWhitelistStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetTEEWhitelistStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetTEEWhitelistStatus"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        /// Settlement
        ///
        /// These methods are for settling orders to L1.
        pub async fn get_settlement_request(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetSettlementRequestRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetSettlementRequestResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetSettlementRequest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetSettlementRequest"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_filtered_settlement_requests(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredSettlementRequestsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredSettlementRequestsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredSettlementRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "GetFilteredSettlementRequests",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the provers that meet the filter criteria.
        pub async fn get_filtered_provers(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredProversRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProversResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProvers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredProvers"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the available balance of a staker.
        pub async fn get_staker_stake_balance(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetStakerStakeBalanceRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetStakerStakeBalanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetStakerStakeBalance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetStakerStakeBalance"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the available balance of a prover.
        pub async fn get_prover_stake_balance(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetProverStakeBalanceRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverStakeBalanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProverStakeBalance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProverStakeBalance"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the staker balance logs that meet the filter criteria.
        pub async fn get_filtered_staker_stake_balance_logs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredStakerStakeBalanceLogsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::super::types::GetFilteredStakerStakeBalanceLogsResponse,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredStakerStakeBalanceLogs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "GetFilteredStakerStakeBalanceLogs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the prover balance logs that meet the filter criteria.
        pub async fn get_filtered_prover_stake_balance_logs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredProverStakeBalanceLogsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::super::types::GetFilteredProverStakeBalanceLogsResponse,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProverStakeBalanceLogs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "GetFilteredProverStakeBalanceLogs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod prover_network_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ProverNetworkServer.
    #[async_trait]
    pub trait ProverNetwork: std::marker::Send + std::marker::Sync + 'static {
        /// Creates a proof request.
        async fn request_proof(
            &self,
            request: tonic::Request<super::super::types::RequestProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RequestProofResponse>,
            tonic::Status,
        >;
        /// Fulfills a proof request. Only callable by the assigned fulfiller.
        async fn fulfill_proof(
            &self,
            request: tonic::Request<super::super::types::FulfillProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::FulfillProofResponse>,
            tonic::Status,
        >;
        /// Executes a proof request. Only callable by the execution oracle.
        async fn execute_proof(
            &self,
            request: tonic::Request<super::super::types::ExecuteProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ExecuteProofResponse>,
            tonic::Status,
        >;
        /// Fails fulfillment. Only callable by the assigned fulfiller.
        async fn fail_fulfillment(
            &self,
            request: tonic::Request<super::super::types::FailFulfillmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::FailFulfillmentResponse>,
            tonic::Status,
        >;
        /// Fails execution. Only callable by the execution oracle.
        async fn fail_execution(
            &self,
            request: tonic::Request<super::super::types::FailExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::FailExecutionResponse>,
            tonic::Status,
        >;
        /// Get the status of a proof request.
        async fn get_proof_request_status(
            &self,
            request: tonic::Request<super::super::types::GetProofRequestStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestStatusResponse>,
            tonic::Status,
        >;
        /// Get the details of a proof request.
        async fn get_proof_request_details(
            &self,
            request: tonic::Request<super::super::types::GetProofRequestDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestDetailsResponse>,
            tonic::Status,
        >;
        /// Get the proof requests that meet the filter criteria.
        async fn get_filtered_proof_requests(
            &self,
            request: tonic::Request<super::super::types::GetFilteredProofRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProofRequestsResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the SubscribeProofRequests method.
        type SubscribeProofRequestsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<
                    super::super::types::ProofRequest,
                    tonic::Status,
                >,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to proof requests that meet the filter criteria.
        async fn subscribe_proof_requests(
            &self,
            request: tonic::Request<super::super::types::GetFilteredProofRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SubscribeProofRequestsStream>,
            tonic::Status,
        >;
        /// Search for proof requests, programs, and requesters.
        async fn get_search_results(
            &self,
            request: tonic::Request<super::super::types::GetSearchResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetSearchResultsResponse>,
            tonic::Status,
        >;
        /// Get metrics for proof requests.
        async fn get_proof_request_metrics(
            &self,
            request: tonic::Request<super::super::types::GetProofRequestMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestMetricsResponse>,
            tonic::Status,
        >;
        /// Get time series data for proof requests.
        async fn get_proof_request_graph(
            &self,
            request: tonic::Request<super::super::types::GetProofRequestGraphRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestGraphResponse>,
            tonic::Status,
        >;
        /// Get analytics graphs for proof requests.
        async fn get_analytics_graphs(
            &self,
            request: tonic::Request<super::super::types::GetAnalyticsGraphsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAnalyticsGraphsResponse>,
            tonic::Status,
        >;
        /// Get overview graphs for proof requests.
        async fn get_overview_graphs(
            &self,
            request: tonic::Request<super::super::types::GetOverviewGraphsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetOverviewGraphsResponse>,
            tonic::Status,
        >;
        /// Get the nonce of the account.
        async fn get_nonce(
            &self,
            request: tonic::Request<super::super::types::GetNonceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetNonceResponse>,
            tonic::Status,
        >;
        /// Get the delegations of the account.
        async fn get_filtered_delegations(
            &self,
            request: tonic::Request<super::super::types::GetFilteredDelegationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredDelegationsResponse>,
            tonic::Status,
        >;
        /// Add a delegation. Only callable by the owner of an account.
        async fn add_delegation(
            &self,
            request: tonic::Request<super::super::types::AddDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::AddDelegationResponse>,
            tonic::Status,
        >;
        /// Remove a delegation. Only callable by the owner of an account.
        async fn remove_delegation(
            &self,
            request: tonic::Request<super::super::types::RemoveDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RemoveDelegationResponse>,
            tonic::Status,
        >;
        /// Terminate a delegation. Only callable by the delegate of a delegation.
        async fn terminate_delegation(
            &self,
            request: tonic::Request<super::super::types::TerminateDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::TerminateDelegationResponse>,
            tonic::Status,
        >;
        /// Accept a delegation. Only callable by the delegate of a delegation.
        async fn accept_delegation(
            &self,
            request: tonic::Request<super::super::types::AcceptDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::AcceptDelegationResponse>,
            tonic::Status,
        >;
        /// Set the name of the account. Only callable by the owner of an account.
        async fn set_account_name(
            &self,
            request: tonic::Request<super::super::types::SetAccountNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetAccountNameResponse>,
            tonic::Status,
        >;
        /// Get the name of the account.
        async fn get_account_name(
            &self,
            request: tonic::Request<super::super::types::GetAccountNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAccountNameResponse>,
            tonic::Status,
        >;
        /// Get whether the account has signed the terms.
        async fn get_terms_signature(
            &self,
            request: tonic::Request<super::super::types::GetTermsSignatureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTermsSignatureResponse>,
            tonic::Status,
        >;
        /// Set whether the account has signed the terms.
        async fn set_terms_signature(
            &self,
            request: tonic::Request<super::super::types::SetTermsSignatureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetTermsSignatureResponse>,
            tonic::Status,
        >;
        /// Get all the information about an account.
        async fn get_account(
            &self,
            request: tonic::Request<super::super::types::GetAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAccountResponse>,
            tonic::Status,
        >;
        /// Get the owner of an account. Returns itself if the account is not delegated.
        async fn get_owner(
            &self,
            request: tonic::Request<super::super::types::GetOwnerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetOwnerResponse>,
            tonic::Status,
        >;
        /// Get metadata about a program.
        async fn get_program(
            &self,
            request: tonic::Request<super::super::types::GetProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProgramResponse>,
            tonic::Status,
        >;
        /// Create a new program. Must be called before requesting proofs.
        async fn create_program(
            &self,
            request: tonic::Request<super::super::types::CreateProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::CreateProgramResponse>,
            tonic::Status,
        >;
        /// Set the name of the program. Only callable by the owner.
        async fn set_program_name(
            &self,
            request: tonic::Request<super::super::types::SetProgramNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetProgramNameResponse>,
            tonic::Status,
        >;
        /// Get the available balance of an account.
        async fn get_balance(
            &self,
            request: tonic::Request<super::super::types::GetBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetBalanceResponse>,
            tonic::Status,
        >;
        /// Get the balance logs that meet the filter criteria.
        async fn get_filtered_balance_logs(
            &self,
            request: tonic::Request<super::super::types::GetFilteredBalanceLogsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredBalanceLogsResponse>,
            tonic::Status,
        >;
        /// Add credit to an account.
        async fn add_credit(
            &self,
            request: tonic::Request<super::super::types::AddCreditRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::AddCreditResponse>,
            tonic::Status,
        >;
        /// Get the latest processed block in the bridge.
        async fn get_latest_bridge_block(
            &self,
            request: tonic::Request<super::super::types::GetLatestBridgeBlockRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLatestBridgeBlockResponse>,
            tonic::Status,
        >;
        /// Get the gas price estimate for a given fulfillment strategy.
        async fn get_gas_price_estimate(
            &self,
            request: tonic::Request<super::super::types::GetGasPriceEstimateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetGasPriceEstimateResponse>,
            tonic::Status,
        >;
        /// Get the details of a transaction.
        async fn get_transaction_details(
            &self,
            request: tonic::Request<super::super::types::GetTransactionDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTransactionDetailsResponse>,
            tonic::Status,
        >;
        /// Add a charge to an account.
        async fn add_reserved_charge(
            &self,
            request: tonic::Request<super::super::types::AddReservedChargeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::AddReservedChargeResponse>,
            tonic::Status,
        >;
        /// Get prorated billing summary by month for a specified payer.
        async fn get_billing_summary(
            &self,
            request: tonic::Request<super::super::types::GetBillingSummaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetBillingSummaryResponse>,
            tonic::Status,
        >;
        /// Update the charge type price for a reservation.
        async fn update_price(
            &self,
            request: tonic::Request<super::super::types::UpdatePriceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::UpdatePriceResponse>,
            tonic::Status,
        >;
        /// Get filtered and paginated clusters/fulfillers with prices.
        async fn get_filtered_clusters(
            &self,
            request: tonic::Request<super::super::types::GetFilteredClustersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredClustersResponse>,
            tonic::Status,
        >;
        /// Get usage summary by month for a specified payer.
        async fn get_usage_summary(
            &self,
            request: tonic::Request<super::super::types::GetUsageSummaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetUsageSummaryResponse>,
            tonic::Status,
        >;
        /// Get the charges that meet the filter criteria.
        async fn get_filtered_charges(
            &self,
            request: tonic::Request<super::super::types::GetFilteredChargesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredChargesResponse>,
            tonic::Status,
        >;
        /// Get the reservations that meet the filter criteria.
        async fn get_filtered_reservations(
            &self,
            request: tonic::Request<super::super::types::GetFilteredReservationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredReservationsResponse>,
            tonic::Status,
        >;
        /// Add a reservation for a requester.
        async fn add_reservation(
            &self,
            request: tonic::Request<super::super::types::AddReservationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::AddReservationResponse>,
            tonic::Status,
        >;
        /// Remove a reservation for a requester.
        async fn remove_reservation(
            &self,
            request: tonic::Request<super::super::types::RemoveReservationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RemoveReservationResponse>,
            tonic::Status,
        >;
        /// Bid for a proof request. Provers that want to be assigned this request must first
        /// bid on it.
        async fn bid(
            &self,
            request: tonic::Request<super::super::types::BidRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::BidResponse>,
            tonic::Status,
        >;
        /// Settle the bids on a proof request to choose the assigned prover. Only callable by
        /// the approved auctioneer.
        async fn settle(
            &self,
            request: tonic::Request<super::super::types::SettleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SettleResponse>,
            tonic::Status,
        >;
        /// Sign in with Ethereum
        async fn sign_in(
            &self,
            request: tonic::Request<super::super::types::SignInRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SignInResponse>,
            tonic::Status,
        >;
        /// Get the accounts that meet the filter criteria.
        async fn get_onboarded_accounts_count(
            &self,
            request: tonic::Request<
                super::super::types::GetOnboardedAccountsCountRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetOnboardedAccountsCountResponse>,
            tonic::Status,
        >;
        /// Get the accounts that have joined the leaderboard.
        async fn get_filtered_onboarded_accounts(
            &self,
            request: tonic::Request<
                super::super::types::GetFilteredOnboardedAccountsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredOnboardedAccountsResponse>,
            tonic::Status,
        >;
        /// Get the leaderboard.
        async fn get_leaderboard(
            &self,
            request: tonic::Request<super::super::types::GetLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLeaderboardResponse>,
            tonic::Status,
        >;
        /// Get the leaderboard stats for a given account.
        async fn get_leaderboard_stats(
            &self,
            request: tonic::Request<super::super::types::GetLeaderboardStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLeaderboardStatsResponse>,
            tonic::Status,
        >;
        /// Get codes.
        async fn get_codes(
            &self,
            request: tonic::Request<super::super::types::GetCodesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetCodesResponse>,
            tonic::Status,
        >;
        /// Redeem a code.
        async fn redeem_code(
            &self,
            request: tonic::Request<super::super::types::RedeemCodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RedeemCodeResponse>,
            tonic::Status,
        >;
        /// Connect a Twitter account.
        async fn connect_twitter(
            &self,
            request: tonic::Request<super::super::types::ConnectTwitterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ConnectTwitterResponse>,
            tonic::Status,
        >;
        /// Complete onboarding.
        async fn complete_onboarding(
            &self,
            request: tonic::Request<super::super::types::CompleteOnboardingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::CompleteOnboardingResponse>,
            tonic::Status,
        >;
        /// Set if a user should display their Twitter handle.
        async fn set_use_twitter_handle(
            &self,
            request: tonic::Request<super::super::types::SetUseTwitterHandleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetUseTwitterHandleResponse>,
            tonic::Status,
        >;
        /// Set if a user should display their Twitter profile picture.
        async fn set_use_twitter_image(
            &self,
            request: tonic::Request<super::super::types::SetUseTwitterImageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetUseTwitterImageResponse>,
            tonic::Status,
        >;
        /// Request a random proof.
        async fn request_random_proof(
            &self,
            request: tonic::Request<super::super::types::RequestRandomProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RequestRandomProofResponse>,
            tonic::Status,
        >;
        /// Submit answers for the captcha game.
        async fn submit_captcha_game(
            &self,
            request: tonic::Request<super::super::types::SubmitCaptchaGameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SubmitCaptchaGameResponse>,
            tonic::Status,
        >;
        /// Redeem stars.
        async fn redeem_stars(
            &self,
            request: tonic::Request<super::super::types::RedeemStarsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RedeemStarsResponse>,
            tonic::Status,
        >;
        /// Get flappy leaderboard.
        async fn get_flappy_leaderboard(
            &self,
            request: tonic::Request<super::super::types::GetFlappyLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFlappyLeaderboardResponse>,
            tonic::Status,
        >;
        /// Set the turbo game high score.
        async fn set_turbo_high_score(
            &self,
            request: tonic::Request<super::super::types::SetTurboHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetTurboHighScoreResponse>,
            tonic::Status,
        >;
        /// Submit answers for the quiz game.
        async fn submit_quiz_game(
            &self,
            request: tonic::Request<super::super::types::SubmitQuizGameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SubmitQuizGameResponse>,
            tonic::Status,
        >;
        /// Get the turbo game leaderboard.
        async fn get_turbo_leaderboard(
            &self,
            request: tonic::Request<super::super::types::GetTurboLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTurboLeaderboardResponse>,
            tonic::Status,
        >;
        /// Submit ETH block metadata.
        async fn submit_eth_block_metadata(
            &self,
            request: tonic::Request<super::super::types::SubmitEthBlockMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SubmitEthBlockMetadataResponse>,
            tonic::Status,
        >;
        /// Get ETH block requests that meet the filter criteria.
        async fn get_filtered_eth_block_requests(
            &self,
            request: tonic::Request<
                super::super::types::GetFilteredEthBlockRequestsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredEthBlockRequestsResponse>,
            tonic::Status,
        >;
        /// Set the 2048 game high score.
        async fn set2048_high_score(
            &self,
            request: tonic::Request<super::super::types::Set2048HighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::Set2048HighScoreResponse>,
            tonic::Status,
        >;
        /// Set the volleyball game high score.
        async fn set_volleyball_high_score(
            &self,
            request: tonic::Request<super::super::types::SetVolleyballHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetVolleyballHighScoreResponse>,
            tonic::Status,
        >;
        /// Get ETH block proof requests metrics.
        async fn get_eth_block_request_metrics(
            &self,
            request: tonic::Request<
                super::super::types::GetEthBlockRequestMetricsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetEthBlockRequestMetricsResponse>,
            tonic::Status,
        >;
        /// Set the turbo time trial high score.
        async fn set_turbo_time_trial_high_score(
            &self,
            request: tonic::Request<
                super::super::types::SetTurboTimeTrialHighScoreRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetTurboTimeTrialHighScoreResponse>,
            tonic::Status,
        >;
        /// Set the coin craze high score.
        async fn set_coin_craze_high_score(
            &self,
            request: tonic::Request<super::super::types::SetCoinCrazeHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetCoinCrazeHighScoreResponse>,
            tonic::Status,
        >;
        /// Set the lean high score.
        async fn set_lean_high_score(
            &self,
            request: tonic::Request<super::super::types::SetLeanHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetLeanHighScoreResponse>,
            tonic::Status,
        >;
        /// Set the flow high score.
        async fn set_flow_high_score(
            &self,
            request: tonic::Request<super::super::types::SetFlowHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetFlowHighScoreResponse>,
            tonic::Status,
        >;
        /// Set the rollup high score.
        async fn set_rollup_high_score(
            &self,
            request: tonic::Request<super::super::types::SetRollupHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetRollupHighScoreResponse>,
            tonic::Status,
        >;
        /// Get the pending stars for an account.
        async fn get_pending_stars(
            &self,
            request: tonic::Request<super::super::types::GetPendingStarsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetPendingStarsResponse>,
            tonic::Status,
        >;
        /// Check if address or social identity is whitelisted.
        async fn get_whitelist_status(
            &self,
            request: tonic::Request<super::super::types::GetWhitelistStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetWhitelistStatusResponse>,
            tonic::Status,
        >;
        /// Set the gpu delegate.
        async fn set_gpu_delegate(
            &self,
            request: tonic::Request<super::super::types::SetGpuDelegateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetGpuDelegateResponse>,
            tonic::Status,
        >;
        /// Claim a gpu.
        async fn claim_gpu(
            &self,
            request: tonic::Request<super::super::types::ClaimGpuRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ClaimGpuResponse>,
            tonic::Status,
        >;
        /// Set the gpu variant.
        async fn set_gpu_variant(
            &self,
            request: tonic::Request<super::super::types::SetGpuVariantRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetGpuVariantResponse>,
            tonic::Status,
        >;
        /// Link a whitelisted twitter account.
        async fn link_whitelisted_twitter(
            &self,
            request: tonic::Request<super::super::types::LinkWhitelistedTwitterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::LinkWhitelistedTwitterResponse>,
            tonic::Status,
        >;
        /// Retrieve the proving key for your account. Must have claimed a gpu and self-delegated to
        /// yourself.
        async fn retrieve_proving_key(
            &self,
            request: tonic::Request<super::super::types::RetrieveProvingKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RetrieveProvingKeyResponse>,
            tonic::Status,
        >;
        /// Link a whitelisted github account.
        async fn link_whitelisted_github(
            &self,
            request: tonic::Request<super::super::types::LinkWhitelistedGithubRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::LinkWhitelistedGithubResponse>,
            tonic::Status,
        >;
        /// Link a whitelisted discord account.
        async fn link_whitelisted_discord(
            &self,
            request: tonic::Request<super::super::types::LinkWhitelistedDiscordRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::LinkWhitelistedDiscordResponse>,
            tonic::Status,
        >;
        /// Link independent Discord account.
        async fn link_social_discord(
            &self,
            request: tonic::Request<super::super::types::LinkSocialDiscordRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::LinkSocialDiscordResponse>,
            tonic::Status,
        >;
        /// Link independent Twitter account.
        async fn link_social_twitter(
            &self,
            request: tonic::Request<super::super::types::LinkSocialTwitterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::LinkSocialTwitterResponse>,
            tonic::Status,
        >;
        /// Get linked social accounts for an address.
        async fn get_linked_social_accounts(
            &self,
            request: tonic::Request<super::super::types::GetLinkedSocialAccountsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLinkedSocialAccountsResponse>,
            tonic::Status,
        >;
        /// Get prover leaderboard.
        async fn get_prover_leaderboard(
            &self,
            request: tonic::Request<super::super::types::GetProverLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverLeaderboardResponse>,
            tonic::Status,
        >;
        /// Get filtered gpus.
        async fn get_filtered_gpus(
            &self,
            request: tonic::Request<super::super::types::GetFilteredGpusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredGpusResponse>,
            tonic::Status,
        >;
        /// Set the gpu coordinates.
        async fn set_gpu_coordinates(
            &self,
            request: tonic::Request<super::super::types::SetGpuCoordinatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetGpuCoordinatesResponse>,
            tonic::Status,
        >;
        /// Get points.
        async fn get_points(
            &self,
            request: tonic::Request<super::super::types::GetPointsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetPointsResponse>,
            tonic::Status,
        >;
        /// Process clicks.
        async fn process_clicks(
            &self,
            request: tonic::Request<super::super::types::ProcessClicksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ProcessClicksResponse>,
            tonic::Status,
        >;
        /// Purchase upgrade.
        async fn purchase_upgrade(
            &self,
            request: tonic::Request<super::super::types::PurchaseUpgradeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::PurchaseUpgradeResponse>,
            tonic::Status,
        >;
        /// Place a bet.
        async fn bet(
            &self,
            request: tonic::Request<super::super::types::BetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::BetResponse>,
            tonic::Status,
        >;
        /// Get the status of a proof contest.
        async fn get_contest_details(
            &self,
            request: tonic::Request<super::super::types::GetContestDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetContestDetailsResponse>,
            tonic::Status,
        >;
        /// Get latest contest id.
        async fn get_latest_contest(
            &self,
            request: tonic::Request<super::super::types::GetLatestContestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLatestContestResponse>,
            tonic::Status,
        >;
        /// Get contest bettors.
        async fn get_contest_bettors(
            &self,
            request: tonic::Request<super::super::types::GetContestBettorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetContestBettorsResponse>,
            tonic::Status,
        >;
        /// Get gpu metrics.
        async fn get_gpu_metrics(
            &self,
            request: tonic::Request<super::super::types::GetGpuMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetGpuMetricsResponse>,
            tonic::Status,
        >;
        /// Get filtered prover activity.
        async fn get_filtered_prover_activity(
            &self,
            request: tonic::Request<
                super::super::types::GetFilteredProverActivityRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProverActivityResponse>,
            tonic::Status,
        >;
        /// Get prover metrics.
        async fn get_prover_metrics(
            &self,
            request: tonic::Request<super::super::types::GetProverMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverMetricsResponse>,
            tonic::Status,
        >;
        /// Get filtered bet history.
        async fn get_filtered_bet_history(
            &self,
            request: tonic::Request<super::super::types::GetFilteredBetHistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredBetHistoryResponse>,
            tonic::Status,
        >;
        /// Get gpu team stats.
        async fn get_gpu_team_stats(
            &self,
            request: tonic::Request<super::super::types::GetGpuTeamStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetGpuTeamStatsResponse>,
            tonic::Status,
        >;
        /// Get the config values.
        async fn get_config_values(
            &self,
            request: tonic::Request<super::super::types::GetConfigValuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetConfigValuesResponse>,
            tonic::Status,
        >;
        /// Get metrics for a specific prover
        async fn get_prover_stats(
            &self,
            request: tonic::Request<super::super::types::GetProverStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverStatsResponse>,
            tonic::Status,
        >;
        /// Get statistics for all provers with pagination
        async fn get_filtered_prover_stats(
            &self,
            request: tonic::Request<super::super::types::GetFilteredProverStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProverStatsResponse>,
            tonic::Status,
        >;
        /// Get search results for provers
        async fn get_prover_search_results(
            &self,
            request: tonic::Request<super::super::types::GetProverSearchResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverSearchResultsResponse>,
            tonic::Status,
        >;
        /// Get paginated auction history
        async fn get_filtered_bid_history(
            &self,
            request: tonic::Request<super::super::types::GetFilteredBidHistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredBidHistoryResponse>,
            tonic::Status,
        >;
        /// Check if the user is whitelisted to use the TEE service.
        async fn get_tee_whitelist_status(
            &self,
            request: tonic::Request<super::super::types::GetTeeWhitelistStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTeeWhitelistStatusResponse>,
            tonic::Status,
        >;
        ///
        /// Settlement
        ///
        /// These methods are for settling orders to L1.
        async fn get_settlement_request(
            &self,
            request: tonic::Request<super::super::types::GetSettlementRequestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetSettlementRequestResponse>,
            tonic::Status,
        >;
        async fn get_filtered_settlement_requests(
            &self,
            request: tonic::Request<
                super::super::types::GetFilteredSettlementRequestsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredSettlementRequestsResponse>,
            tonic::Status,
        >;
        /// Get the provers that meet the filter criteria.
        async fn get_filtered_provers(
            &self,
            request: tonic::Request<super::super::types::GetFilteredProversRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProversResponse>,
            tonic::Status,
        >;
        /// Get the available balance of a staker.
        async fn get_staker_stake_balance(
            &self,
            request: tonic::Request<super::super::types::GetStakerStakeBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetStakerStakeBalanceResponse>,
            tonic::Status,
        >;
        /// Get the available balance of a prover.
        async fn get_prover_stake_balance(
            &self,
            request: tonic::Request<super::super::types::GetProverStakeBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverStakeBalanceResponse>,
            tonic::Status,
        >;
        /// Get the staker balance logs that meet the filter criteria.
        async fn get_filtered_staker_stake_balance_logs(
            &self,
            request: tonic::Request<
                super::super::types::GetFilteredStakerStakeBalanceLogsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::super::types::GetFilteredStakerStakeBalanceLogsResponse,
            >,
            tonic::Status,
        >;
        /// Get the prover balance logs that meet the filter criteria.
        async fn get_filtered_prover_stake_balance_logs(
            &self,
            request: tonic::Request<
                super::super::types::GetFilteredProverStakeBalanceLogsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::super::types::GetFilteredProverStakeBalanceLogsResponse,
            >,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct ProverNetworkServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ProverNetworkServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ProverNetworkServer<T>
    where
        T: ProverNetwork,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/network.ProverNetwork/RequestProof" => {
                    #[allow(non_camel_case_types)]
                    struct RequestProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::RequestProofRequest,
                    > for RequestProofSvc<T> {
                        type Response = super::super::types::RequestProofResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::RequestProofRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::request_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RequestProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/FulfillProof" => {
                    #[allow(non_camel_case_types)]
                    struct FulfillProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::FulfillProofRequest,
                    > for FulfillProofSvc<T> {
                        type Response = super::super::types::FulfillProofResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::FulfillProofRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::fulfill_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FulfillProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ExecuteProof" => {
                    #[allow(non_camel_case_types)]
                    struct ExecuteProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::ExecuteProofRequest,
                    > for ExecuteProofSvc<T> {
                        type Response = super::super::types::ExecuteProofResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::ExecuteProofRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::execute_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecuteProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/FailFulfillment" => {
                    #[allow(non_camel_case_types)]
                    struct FailFulfillmentSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::FailFulfillmentRequest,
                    > for FailFulfillmentSvc<T> {
                        type Response = super::super::types::FailFulfillmentResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::FailFulfillmentRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::fail_fulfillment(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FailFulfillmentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/FailExecution" => {
                    #[allow(non_camel_case_types)]
                    struct FailExecutionSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::FailExecutionRequest,
                    > for FailExecutionSvc<T> {
                        type Response = super::super::types::FailExecutionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::FailExecutionRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::fail_execution(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FailExecutionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestStatusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProofRequestStatusRequest,
                    > for GetProofRequestStatusSvc<T> {
                        type Response = super::super::types::GetProofRequestStatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProofRequestStatusRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_status(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestDetails" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestDetailsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProofRequestDetailsRequest,
                    > for GetProofRequestDetailsSvc<T> {
                        type Response = super::super::types::GetProofRequestDetailsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProofRequestDetailsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_details(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProofRequests" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProofRequestsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredProofRequestsRequest,
                    > for GetFilteredProofRequestsSvc<T> {
                        type Response = super::super::types::GetFilteredProofRequestsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredProofRequestsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_proof_requests(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProofRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SubscribeProofRequests" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeProofRequestsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::ServerStreamingService<
                        super::super::types::GetFilteredProofRequestsRequest,
                    > for SubscribeProofRequestsSvc<T> {
                        type Response = super::super::types::ProofRequest;
                        type ResponseStream = T::SubscribeProofRequestsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredProofRequestsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::subscribe_proof_requests(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeProofRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetSearchResults" => {
                    #[allow(non_camel_case_types)]
                    struct GetSearchResultsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetSearchResultsRequest,
                    > for GetSearchResultsSvc<T> {
                        type Response = super::super::types::GetSearchResultsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetSearchResultsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_search_results(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSearchResultsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestMetricsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProofRequestMetricsRequest,
                    > for GetProofRequestMetricsSvc<T> {
                        type Response = super::super::types::GetProofRequestMetricsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProofRequestMetricsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_metrics(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestGraph" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestGraphSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProofRequestGraphRequest,
                    > for GetProofRequestGraphSvc<T> {
                        type Response = super::super::types::GetProofRequestGraphResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProofRequestGraphRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_graph(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestGraphSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetAnalyticsGraphs" => {
                    #[allow(non_camel_case_types)]
                    struct GetAnalyticsGraphsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetAnalyticsGraphsRequest,
                    > for GetAnalyticsGraphsSvc<T> {
                        type Response = super::super::types::GetAnalyticsGraphsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetAnalyticsGraphsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_analytics_graphs(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAnalyticsGraphsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetOverviewGraphs" => {
                    #[allow(non_camel_case_types)]
                    struct GetOverviewGraphsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetOverviewGraphsRequest,
                    > for GetOverviewGraphsSvc<T> {
                        type Response = super::super::types::GetOverviewGraphsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetOverviewGraphsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_overview_graphs(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOverviewGraphsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetNonce" => {
                    #[allow(non_camel_case_types)]
                    struct GetNonceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::GetNonceRequest>
                    for GetNonceSvc<T> {
                        type Response = super::super::types::GetNonceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetNonceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_nonce(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetNonceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredDelegations" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredDelegationsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredDelegationsRequest,
                    > for GetFilteredDelegationsSvc<T> {
                        type Response = super::super::types::GetFilteredDelegationsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredDelegationsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_delegations(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredDelegationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AddDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct AddDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::AddDelegationRequest,
                    > for AddDelegationSvc<T> {
                        type Response = super::super::types::AddDelegationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::AddDelegationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::add_delegation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RemoveDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::RemoveDelegationRequest,
                    > for RemoveDelegationSvc<T> {
                        type Response = super::super::types::RemoveDelegationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::RemoveDelegationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::remove_delegation(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/TerminateDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct TerminateDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::TerminateDelegationRequest,
                    > for TerminateDelegationSvc<T> {
                        type Response = super::super::types::TerminateDelegationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::TerminateDelegationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::terminate_delegation(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TerminateDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AcceptDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct AcceptDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::AcceptDelegationRequest,
                    > for AcceptDelegationSvc<T> {
                        type Response = super::super::types::AcceptDelegationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::AcceptDelegationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::accept_delegation(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AcceptDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetAccountName" => {
                    #[allow(non_camel_case_types)]
                    struct SetAccountNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetAccountNameRequest,
                    > for SetAccountNameSvc<T> {
                        type Response = super::super::types::SetAccountNameResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetAccountNameRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_account_name(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetAccountNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetAccountName" => {
                    #[allow(non_camel_case_types)]
                    struct GetAccountNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetAccountNameRequest,
                    > for GetAccountNameSvc<T> {
                        type Response = super::super::types::GetAccountNameResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetAccountNameRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_account_name(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAccountNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTermsSignature" => {
                    #[allow(non_camel_case_types)]
                    struct GetTermsSignatureSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetTermsSignatureRequest,
                    > for GetTermsSignatureSvc<T> {
                        type Response = super::super::types::GetTermsSignatureResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetTermsSignatureRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_terms_signature(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTermsSignatureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetTermsSignature" => {
                    #[allow(non_camel_case_types)]
                    struct SetTermsSignatureSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetTermsSignatureRequest,
                    > for SetTermsSignatureSvc<T> {
                        type Response = super::super::types::SetTermsSignatureResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetTermsSignatureRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_terms_signature(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetTermsSignatureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetAccount" => {
                    #[allow(non_camel_case_types)]
                    struct GetAccountSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::GetAccountRequest>
                    for GetAccountSvc<T> {
                        type Response = super::super::types::GetAccountResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetAccountRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_account(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAccountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetOwner" => {
                    #[allow(non_camel_case_types)]
                    struct GetOwnerSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::GetOwnerRequest>
                    for GetOwnerSvc<T> {
                        type Response = super::super::types::GetOwnerResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetOwnerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_owner(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOwnerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProgram" => {
                    #[allow(non_camel_case_types)]
                    struct GetProgramSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::GetProgramRequest>
                    for GetProgramSvc<T> {
                        type Response = super::super::types::GetProgramResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProgramRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_program(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProgramSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/CreateProgram" => {
                    #[allow(non_camel_case_types)]
                    struct CreateProgramSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::CreateProgramRequest,
                    > for CreateProgramSvc<T> {
                        type Response = super::super::types::CreateProgramResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::CreateProgramRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::create_program(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateProgramSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetProgramName" => {
                    #[allow(non_camel_case_types)]
                    struct SetProgramNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetProgramNameRequest,
                    > for SetProgramNameSvc<T> {
                        type Response = super::super::types::SetProgramNameResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetProgramNameRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_program_name(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetProgramNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetBalance" => {
                    #[allow(non_camel_case_types)]
                    struct GetBalanceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::GetBalanceRequest>
                    for GetBalanceSvc<T> {
                        type Response = super::super::types::GetBalanceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetBalanceRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_balance(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBalanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredBalanceLogs" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredBalanceLogsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredBalanceLogsRequest,
                    > for GetFilteredBalanceLogsSvc<T> {
                        type Response = super::super::types::GetFilteredBalanceLogsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredBalanceLogsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_balance_logs(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredBalanceLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AddCredit" => {
                    #[allow(non_camel_case_types)]
                    struct AddCreditSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::AddCreditRequest>
                    for AddCreditSvc<T> {
                        type Response = super::super::types::AddCreditResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::AddCreditRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::add_credit(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddCreditSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLatestBridgeBlock" => {
                    #[allow(non_camel_case_types)]
                    struct GetLatestBridgeBlockSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetLatestBridgeBlockRequest,
                    > for GetLatestBridgeBlockSvc<T> {
                        type Response = super::super::types::GetLatestBridgeBlockResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetLatestBridgeBlockRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_latest_bridge_block(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLatestBridgeBlockSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetGasPriceEstimate" => {
                    #[allow(non_camel_case_types)]
                    struct GetGasPriceEstimateSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetGasPriceEstimateRequest,
                    > for GetGasPriceEstimateSvc<T> {
                        type Response = super::super::types::GetGasPriceEstimateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetGasPriceEstimateRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_gas_price_estimate(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetGasPriceEstimateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTransactionDetails" => {
                    #[allow(non_camel_case_types)]
                    struct GetTransactionDetailsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetTransactionDetailsRequest,
                    > for GetTransactionDetailsSvc<T> {
                        type Response = super::super::types::GetTransactionDetailsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetTransactionDetailsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_transaction_details(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTransactionDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AddReservedCharge" => {
                    #[allow(non_camel_case_types)]
                    struct AddReservedChargeSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::AddReservedChargeRequest,
                    > for AddReservedChargeSvc<T> {
                        type Response = super::super::types::AddReservedChargeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::AddReservedChargeRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::add_reserved_charge(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddReservedChargeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetBillingSummary" => {
                    #[allow(non_camel_case_types)]
                    struct GetBillingSummarySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetBillingSummaryRequest,
                    > for GetBillingSummarySvc<T> {
                        type Response = super::super::types::GetBillingSummaryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetBillingSummaryRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_billing_summary(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBillingSummarySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/UpdatePrice" => {
                    #[allow(non_camel_case_types)]
                    struct UpdatePriceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::UpdatePriceRequest,
                    > for UpdatePriceSvc<T> {
                        type Response = super::super::types::UpdatePriceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::UpdatePriceRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::update_price(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdatePriceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredClusters" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredClustersSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredClustersRequest,
                    > for GetFilteredClustersSvc<T> {
                        type Response = super::super::types::GetFilteredClustersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredClustersRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_clusters(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredClustersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetUsageSummary" => {
                    #[allow(non_camel_case_types)]
                    struct GetUsageSummarySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetUsageSummaryRequest,
                    > for GetUsageSummarySvc<T> {
                        type Response = super::super::types::GetUsageSummaryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetUsageSummaryRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_usage_summary(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetUsageSummarySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredCharges" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredChargesSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredChargesRequest,
                    > for GetFilteredChargesSvc<T> {
                        type Response = super::super::types::GetFilteredChargesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredChargesRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_charges(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredChargesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredReservations" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredReservationsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredReservationsRequest,
                    > for GetFilteredReservationsSvc<T> {
                        type Response = super::super::types::GetFilteredReservationsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredReservationsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_reservations(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredReservationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AddReservation" => {
                    #[allow(non_camel_case_types)]
                    struct AddReservationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::AddReservationRequest,
                    > for AddReservationSvc<T> {
                        type Response = super::super::types::AddReservationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::AddReservationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::add_reservation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddReservationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RemoveReservation" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveReservationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::RemoveReservationRequest,
                    > for RemoveReservationSvc<T> {
                        type Response = super::super::types::RemoveReservationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::RemoveReservationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::remove_reservation(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveReservationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Bid" => {
                    #[allow(non_camel_case_types)]
                    struct BidSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::BidRequest>
                    for BidSvc<T> {
                        type Response = super::super::types::BidResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::BidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::bid(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Settle" => {
                    #[allow(non_camel_case_types)]
                    struct SettleSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::SettleRequest>
                    for SettleSvc<T> {
                        type Response = super::super::types::SettleResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SettleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::settle(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SettleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SignIn" => {
                    #[allow(non_camel_case_types)]
                    struct SignInSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::SignInRequest>
                    for SignInSvc<T> {
                        type Response = super::super::types::SignInResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SignInRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::sign_in(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SignInSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetOnboardedAccountsCount" => {
                    #[allow(non_camel_case_types)]
                    struct GetOnboardedAccountsCountSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetOnboardedAccountsCountRequest,
                    > for GetOnboardedAccountsCountSvc<T> {
                        type Response = super::super::types::GetOnboardedAccountsCountResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetOnboardedAccountsCountRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_onboarded_accounts_count(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOnboardedAccountsCountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredOnboardedAccounts" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredOnboardedAccountsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredOnboardedAccountsRequest,
                    > for GetFilteredOnboardedAccountsSvc<T> {
                        type Response = super::super::types::GetFilteredOnboardedAccountsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredOnboardedAccountsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_onboarded_accounts(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredOnboardedAccountsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLeaderboard" => {
                    #[allow(non_camel_case_types)]
                    struct GetLeaderboardSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetLeaderboardRequest,
                    > for GetLeaderboardSvc<T> {
                        type Response = super::super::types::GetLeaderboardResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetLeaderboardRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_leaderboard(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLeaderboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLeaderboardStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetLeaderboardStatsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetLeaderboardStatsRequest,
                    > for GetLeaderboardStatsSvc<T> {
                        type Response = super::super::types::GetLeaderboardStatsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetLeaderboardStatsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_leaderboard_stats(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLeaderboardStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetCodes" => {
                    #[allow(non_camel_case_types)]
                    struct GetCodesSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::GetCodesRequest>
                    for GetCodesSvc<T> {
                        type Response = super::super::types::GetCodesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetCodesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_codes(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCodesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RedeemCode" => {
                    #[allow(non_camel_case_types)]
                    struct RedeemCodeSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::RedeemCodeRequest>
                    for RedeemCodeSvc<T> {
                        type Response = super::super::types::RedeemCodeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::RedeemCodeRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::redeem_code(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RedeemCodeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ConnectTwitter" => {
                    #[allow(non_camel_case_types)]
                    struct ConnectTwitterSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::ConnectTwitterRequest,
                    > for ConnectTwitterSvc<T> {
                        type Response = super::super::types::ConnectTwitterResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::ConnectTwitterRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::connect_twitter(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConnectTwitterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/CompleteOnboarding" => {
                    #[allow(non_camel_case_types)]
                    struct CompleteOnboardingSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::CompleteOnboardingRequest,
                    > for CompleteOnboardingSvc<T> {
                        type Response = super::super::types::CompleteOnboardingResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::CompleteOnboardingRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::complete_onboarding(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CompleteOnboardingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetUseTwitterHandle" => {
                    #[allow(non_camel_case_types)]
                    struct SetUseTwitterHandleSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetUseTwitterHandleRequest,
                    > for SetUseTwitterHandleSvc<T> {
                        type Response = super::super::types::SetUseTwitterHandleResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetUseTwitterHandleRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_use_twitter_handle(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetUseTwitterHandleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetUseTwitterImage" => {
                    #[allow(non_camel_case_types)]
                    struct SetUseTwitterImageSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetUseTwitterImageRequest,
                    > for SetUseTwitterImageSvc<T> {
                        type Response = super::super::types::SetUseTwitterImageResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetUseTwitterImageRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_use_twitter_image(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetUseTwitterImageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RequestRandomProof" => {
                    #[allow(non_camel_case_types)]
                    struct RequestRandomProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::RequestRandomProofRequest,
                    > for RequestRandomProofSvc<T> {
                        type Response = super::super::types::RequestRandomProofResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::RequestRandomProofRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::request_random_proof(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RequestRandomProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SubmitCaptchaGame" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitCaptchaGameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SubmitCaptchaGameRequest,
                    > for SubmitCaptchaGameSvc<T> {
                        type Response = super::super::types::SubmitCaptchaGameResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SubmitCaptchaGameRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::submit_captcha_game(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitCaptchaGameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RedeemStars" => {
                    #[allow(non_camel_case_types)]
                    struct RedeemStarsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::RedeemStarsRequest,
                    > for RedeemStarsSvc<T> {
                        type Response = super::super::types::RedeemStarsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::RedeemStarsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::redeem_stars(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RedeemStarsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFlappyLeaderboard" => {
                    #[allow(non_camel_case_types)]
                    struct GetFlappyLeaderboardSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFlappyLeaderboardRequest,
                    > for GetFlappyLeaderboardSvc<T> {
                        type Response = super::super::types::GetFlappyLeaderboardResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFlappyLeaderboardRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_flappy_leaderboard(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFlappyLeaderboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetTurboHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetTurboHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetTurboHighScoreRequest,
                    > for SetTurboHighScoreSvc<T> {
                        type Response = super::super::types::SetTurboHighScoreResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetTurboHighScoreRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_turbo_high_score(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetTurboHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SubmitQuizGame" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitQuizGameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SubmitQuizGameRequest,
                    > for SubmitQuizGameSvc<T> {
                        type Response = super::super::types::SubmitQuizGameResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SubmitQuizGameRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::submit_quiz_game(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitQuizGameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTurboLeaderboard" => {
                    #[allow(non_camel_case_types)]
                    struct GetTurboLeaderboardSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetTurboLeaderboardRequest,
                    > for GetTurboLeaderboardSvc<T> {
                        type Response = super::super::types::GetTurboLeaderboardResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetTurboLeaderboardRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_turbo_leaderboard(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTurboLeaderboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SubmitEthBlockMetadata" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitEthBlockMetadataSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SubmitEthBlockMetadataRequest,
                    > for SubmitEthBlockMetadataSvc<T> {
                        type Response = super::super::types::SubmitEthBlockMetadataResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SubmitEthBlockMetadataRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::submit_eth_block_metadata(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitEthBlockMetadataSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredEthBlockRequests" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredEthBlockRequestsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredEthBlockRequestsRequest,
                    > for GetFilteredEthBlockRequestsSvc<T> {
                        type Response = super::super::types::GetFilteredEthBlockRequestsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredEthBlockRequestsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_eth_block_requests(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredEthBlockRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Set2048HighScore" => {
                    #[allow(non_camel_case_types)]
                    struct Set2048HighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::Set2048HighScoreRequest,
                    > for Set2048HighScoreSvc<T> {
                        type Response = super::super::types::Set2048HighScoreResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::Set2048HighScoreRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set2048_high_score(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = Set2048HighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetVolleyballHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetVolleyballHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetVolleyballHighScoreRequest,
                    > for SetVolleyballHighScoreSvc<T> {
                        type Response = super::super::types::SetVolleyballHighScoreResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetVolleyballHighScoreRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_volleyball_high_score(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetVolleyballHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetEthBlockRequestMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct GetEthBlockRequestMetricsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetEthBlockRequestMetricsRequest,
                    > for GetEthBlockRequestMetricsSvc<T> {
                        type Response = super::super::types::GetEthBlockRequestMetricsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetEthBlockRequestMetricsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_eth_block_request_metrics(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetEthBlockRequestMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetTurboTimeTrialHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetTurboTimeTrialHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetTurboTimeTrialHighScoreRequest,
                    > for SetTurboTimeTrialHighScoreSvc<T> {
                        type Response = super::super::types::SetTurboTimeTrialHighScoreResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetTurboTimeTrialHighScoreRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_turbo_time_trial_high_score(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetTurboTimeTrialHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetCoinCrazeHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetCoinCrazeHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetCoinCrazeHighScoreRequest,
                    > for SetCoinCrazeHighScoreSvc<T> {
                        type Response = super::super::types::SetCoinCrazeHighScoreResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetCoinCrazeHighScoreRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_coin_craze_high_score(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetCoinCrazeHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetLeanHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetLeanHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetLeanHighScoreRequest,
                    > for SetLeanHighScoreSvc<T> {
                        type Response = super::super::types::SetLeanHighScoreResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetLeanHighScoreRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_lean_high_score(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetLeanHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetFlowHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetFlowHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetFlowHighScoreRequest,
                    > for SetFlowHighScoreSvc<T> {
                        type Response = super::super::types::SetFlowHighScoreResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetFlowHighScoreRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_flow_high_score(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetFlowHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetRollupHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetRollupHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetRollupHighScoreRequest,
                    > for SetRollupHighScoreSvc<T> {
                        type Response = super::super::types::SetRollupHighScoreResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetRollupHighScoreRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_rollup_high_score(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetRollupHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetPendingStars" => {
                    #[allow(non_camel_case_types)]
                    struct GetPendingStarsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetPendingStarsRequest,
                    > for GetPendingStarsSvc<T> {
                        type Response = super::super::types::GetPendingStarsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetPendingStarsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_pending_stars(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPendingStarsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetWhitelistStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetWhitelistStatusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetWhitelistStatusRequest,
                    > for GetWhitelistStatusSvc<T> {
                        type Response = super::super::types::GetWhitelistStatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetWhitelistStatusRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_whitelist_status(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetWhitelistStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetGpuDelegate" => {
                    #[allow(non_camel_case_types)]
                    struct SetGpuDelegateSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetGpuDelegateRequest,
                    > for SetGpuDelegateSvc<T> {
                        type Response = super::super::types::SetGpuDelegateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetGpuDelegateRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_gpu_delegate(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetGpuDelegateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ClaimGpu" => {
                    #[allow(non_camel_case_types)]
                    struct ClaimGpuSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::ClaimGpuRequest>
                    for ClaimGpuSvc<T> {
                        type Response = super::super::types::ClaimGpuResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::ClaimGpuRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::claim_gpu(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ClaimGpuSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetGpuVariant" => {
                    #[allow(non_camel_case_types)]
                    struct SetGpuVariantSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetGpuVariantRequest,
                    > for SetGpuVariantSvc<T> {
                        type Response = super::super::types::SetGpuVariantResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetGpuVariantRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_gpu_variant(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetGpuVariantSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/LinkWhitelistedTwitter" => {
                    #[allow(non_camel_case_types)]
                    struct LinkWhitelistedTwitterSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::LinkWhitelistedTwitterRequest,
                    > for LinkWhitelistedTwitterSvc<T> {
                        type Response = super::super::types::LinkWhitelistedTwitterResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::LinkWhitelistedTwitterRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::link_whitelisted_twitter(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkWhitelistedTwitterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RetrieveProvingKey" => {
                    #[allow(non_camel_case_types)]
                    struct RetrieveProvingKeySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::RetrieveProvingKeyRequest,
                    > for RetrieveProvingKeySvc<T> {
                        type Response = super::super::types::RetrieveProvingKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::RetrieveProvingKeyRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::retrieve_proving_key(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RetrieveProvingKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/LinkWhitelistedGithub" => {
                    #[allow(non_camel_case_types)]
                    struct LinkWhitelistedGithubSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::LinkWhitelistedGithubRequest,
                    > for LinkWhitelistedGithubSvc<T> {
                        type Response = super::super::types::LinkWhitelistedGithubResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::LinkWhitelistedGithubRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::link_whitelisted_github(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkWhitelistedGithubSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/LinkWhitelistedDiscord" => {
                    #[allow(non_camel_case_types)]
                    struct LinkWhitelistedDiscordSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::LinkWhitelistedDiscordRequest,
                    > for LinkWhitelistedDiscordSvc<T> {
                        type Response = super::super::types::LinkWhitelistedDiscordResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::LinkWhitelistedDiscordRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::link_whitelisted_discord(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkWhitelistedDiscordSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/LinkSocialDiscord" => {
                    #[allow(non_camel_case_types)]
                    struct LinkSocialDiscordSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::LinkSocialDiscordRequest,
                    > for LinkSocialDiscordSvc<T> {
                        type Response = super::super::types::LinkSocialDiscordResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::LinkSocialDiscordRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::link_social_discord(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkSocialDiscordSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/LinkSocialTwitter" => {
                    #[allow(non_camel_case_types)]
                    struct LinkSocialTwitterSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::LinkSocialTwitterRequest,
                    > for LinkSocialTwitterSvc<T> {
                        type Response = super::super::types::LinkSocialTwitterResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::LinkSocialTwitterRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::link_social_twitter(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkSocialTwitterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLinkedSocialAccounts" => {
                    #[allow(non_camel_case_types)]
                    struct GetLinkedSocialAccountsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetLinkedSocialAccountsRequest,
                    > for GetLinkedSocialAccountsSvc<T> {
                        type Response = super::super::types::GetLinkedSocialAccountsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetLinkedSocialAccountsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_linked_social_accounts(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLinkedSocialAccountsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverLeaderboard" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverLeaderboardSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProverLeaderboardRequest,
                    > for GetProverLeaderboardSvc<T> {
                        type Response = super::super::types::GetProverLeaderboardResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProverLeaderboardRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_leaderboard(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverLeaderboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredGpus" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredGpusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredGpusRequest,
                    > for GetFilteredGpusSvc<T> {
                        type Response = super::super::types::GetFilteredGpusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredGpusRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_gpus(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredGpusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetGpuCoordinates" => {
                    #[allow(non_camel_case_types)]
                    struct SetGpuCoordinatesSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::SetGpuCoordinatesRequest,
                    > for SetGpuCoordinatesSvc<T> {
                        type Response = super::super::types::SetGpuCoordinatesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetGpuCoordinatesRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_gpu_coordinates(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetGpuCoordinatesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetPoints" => {
                    #[allow(non_camel_case_types)]
                    struct GetPointsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::GetPointsRequest>
                    for GetPointsSvc<T> {
                        type Response = super::super::types::GetPointsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetPointsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_points(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPointsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ProcessClicks" => {
                    #[allow(non_camel_case_types)]
                    struct ProcessClicksSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::ProcessClicksRequest,
                    > for ProcessClicksSvc<T> {
                        type Response = super::super::types::ProcessClicksResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::ProcessClicksRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::process_clicks(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ProcessClicksSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/PurchaseUpgrade" => {
                    #[allow(non_camel_case_types)]
                    struct PurchaseUpgradeSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::PurchaseUpgradeRequest,
                    > for PurchaseUpgradeSvc<T> {
                        type Response = super::super::types::PurchaseUpgradeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::PurchaseUpgradeRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::purchase_upgrade(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PurchaseUpgradeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Bet" => {
                    #[allow(non_camel_case_types)]
                    struct BetSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::super::types::BetRequest>
                    for BetSvc<T> {
                        type Response = super::super::types::BetResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::BetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::bet(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetContestDetails" => {
                    #[allow(non_camel_case_types)]
                    struct GetContestDetailsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetContestDetailsRequest,
                    > for GetContestDetailsSvc<T> {
                        type Response = super::super::types::GetContestDetailsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetContestDetailsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_contest_details(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetContestDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLatestContest" => {
                    #[allow(non_camel_case_types)]
                    struct GetLatestContestSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetLatestContestRequest,
                    > for GetLatestContestSvc<T> {
                        type Response = super::super::types::GetLatestContestResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetLatestContestRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_latest_contest(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLatestContestSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetContestBettors" => {
                    #[allow(non_camel_case_types)]
                    struct GetContestBettorsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetContestBettorsRequest,
                    > for GetContestBettorsSvc<T> {
                        type Response = super::super::types::GetContestBettorsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetContestBettorsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_contest_bettors(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetContestBettorsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetGpuMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct GetGpuMetricsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetGpuMetricsRequest,
                    > for GetGpuMetricsSvc<T> {
                        type Response = super::super::types::GetGpuMetricsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetGpuMetricsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_gpu_metrics(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetGpuMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProverActivity" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProverActivitySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredProverActivityRequest,
                    > for GetFilteredProverActivitySvc<T> {
                        type Response = super::super::types::GetFilteredProverActivityResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredProverActivityRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_prover_activity(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProverActivitySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverMetricsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProverMetricsRequest,
                    > for GetProverMetricsSvc<T> {
                        type Response = super::super::types::GetProverMetricsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProverMetricsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_metrics(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredBetHistory" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredBetHistorySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredBetHistoryRequest,
                    > for GetFilteredBetHistorySvc<T> {
                        type Response = super::super::types::GetFilteredBetHistoryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredBetHistoryRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_bet_history(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredBetHistorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetGpuTeamStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetGpuTeamStatsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetGpuTeamStatsRequest,
                    > for GetGpuTeamStatsSvc<T> {
                        type Response = super::super::types::GetGpuTeamStatsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetGpuTeamStatsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_gpu_team_stats(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetGpuTeamStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetConfigValues" => {
                    #[allow(non_camel_case_types)]
                    struct GetConfigValuesSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetConfigValuesRequest,
                    > for GetConfigValuesSvc<T> {
                        type Response = super::super::types::GetConfigValuesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetConfigValuesRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_config_values(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetConfigValuesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverStatsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProverStatsRequest,
                    > for GetProverStatsSvc<T> {
                        type Response = super::super::types::GetProverStatsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProverStatsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_stats(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProverStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProverStatsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredProverStatsRequest,
                    > for GetFilteredProverStatsSvc<T> {
                        type Response = super::super::types::GetFilteredProverStatsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredProverStatsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_prover_stats(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProverStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverSearchResults" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverSearchResultsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProverSearchResultsRequest,
                    > for GetProverSearchResultsSvc<T> {
                        type Response = super::super::types::GetProverSearchResultsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProverSearchResultsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_search_results(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverSearchResultsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredBidHistory" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredBidHistorySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredBidHistoryRequest,
                    > for GetFilteredBidHistorySvc<T> {
                        type Response = super::super::types::GetFilteredBidHistoryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredBidHistoryRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_bid_history(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredBidHistorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTEEWhitelistStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetTEEWhitelistStatusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetTeeWhitelistStatusRequest,
                    > for GetTEEWhitelistStatusSvc<T> {
                        type Response = super::super::types::GetTeeWhitelistStatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetTeeWhitelistStatusRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_tee_whitelist_status(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTEEWhitelistStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetSettlementRequest" => {
                    #[allow(non_camel_case_types)]
                    struct GetSettlementRequestSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetSettlementRequestRequest,
                    > for GetSettlementRequestSvc<T> {
                        type Response = super::super::types::GetSettlementRequestResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetSettlementRequestRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_settlement_request(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSettlementRequestSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredSettlementRequests" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredSettlementRequestsSvc<T: ProverNetwork>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredSettlementRequestsRequest,
                    > for GetFilteredSettlementRequestsSvc<T> {
                        type Response = super::super::types::GetFilteredSettlementRequestsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredSettlementRequestsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_settlement_requests(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredSettlementRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProvers" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProversSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredProversRequest,
                    > for GetFilteredProversSvc<T> {
                        type Response = super::super::types::GetFilteredProversResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredProversRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_provers(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProversSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetStakerStakeBalance" => {
                    #[allow(non_camel_case_types)]
                    struct GetStakerStakeBalanceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetStakerStakeBalanceRequest,
                    > for GetStakerStakeBalanceSvc<T> {
                        type Response = super::super::types::GetStakerStakeBalanceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetStakerStakeBalanceRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_staker_stake_balance(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetStakerStakeBalanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverStakeBalance" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverStakeBalanceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetProverStakeBalanceRequest,
                    > for GetProverStakeBalanceSvc<T> {
                        type Response = super::super::types::GetProverStakeBalanceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProverStakeBalanceRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_stake_balance(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverStakeBalanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredStakerStakeBalanceLogs" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredStakerStakeBalanceLogsSvc<T: ProverNetwork>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredStakerStakeBalanceLogsRequest,
                    > for GetFilteredStakerStakeBalanceLogsSvc<T> {
                        type Response = super::super::types::GetFilteredStakerStakeBalanceLogsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredStakerStakeBalanceLogsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_staker_stake_balance_logs(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredStakerStakeBalanceLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProverStakeBalanceLogs" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProverStakeBalanceLogsSvc<T: ProverNetwork>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::super::types::GetFilteredProverStakeBalanceLogsRequest,
                    > for GetFilteredProverStakeBalanceLogsSvc<T> {
                        type Response = super::super::types::GetFilteredProverStakeBalanceLogsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredProverStakeBalanceLogsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_prover_stake_balance_logs(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProverStakeBalanceLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", tonic::Code::Unimplemented as i32)
                                .header(
                                    http::header::CONTENT_TYPE,
                                    tonic::metadata::GRPC_CONTENT_TYPE,
                                )
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T> Clone for ProverNetworkServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "network.ProverNetwork";
    impl<T> tonic::server::NamedService for ProverNetworkServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}