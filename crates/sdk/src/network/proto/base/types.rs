// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RequestProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The version of the prover to use.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// The mode for the request.
    #[prost(enumeration = "ProofMode", tag = "4")]
    pub mode: i32,
    /// The strategy for fulfiller assignment.
    #[prost(enumeration = "FulfillmentStrategy", tag = "5")]
    pub strategy: i32,
    /// The stdin resource identifier.
    #[prost(string, tag = "6")]
    pub stdin_uri: ::prost::alloc::string::String,
    /// The deadline for the request.
    #[prost(uint64, tag = "7")]
    pub deadline: u64,
    /// The cycle limit for the request.
    #[prost(uint64, tag = "8")]
    pub cycle_limit: u64,
    /// The gas limit for the request. If 0, the cycle_limit is used.
    #[prost(uint64, tag = "9")]
    pub gas_limit: u64,
    /// The minimum period a request can be in auction in seconds. Zero indicates no minimum. Only
    /// applicable if the strategy is auction.
    #[prost(uint64, tag = "10")]
    pub min_auction_period: u64,
    /// The whitelist of provers that can bid and prove this request. An empty list indicates that
    /// any prover can participate. Only applicable if the strategy is auction.
    #[prost(bytes = "vec", repeated, tag = "11")]
    pub whitelist: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RequestProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestProofResponseBody {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReservedMetadata {
    /// The optional ratio of gpu time the proof used on-demand resources versus reserved.
    #[prost(float, optional, tag = "1")]
    pub on_demand_ratio: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FulfillProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<FulfillProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FulfillProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The proof bytes.
    #[prost(bytes = "vec", tag = "3")]
    pub proof: ::prost::alloc::vec::Vec<u8>,
    /// The optional metadata for reserved proofs.
    #[prost(message, optional, tag = "4")]
    pub reserved_metadata: ::core::option::Option<ReservedMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FulfillProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<FulfillProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FulfillProofResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<ExecuteProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "3")]
    pub execution_status: i32,
    /// The optional public values hash of the request execution, only included if
    /// the request is valid.
    #[prost(bytes = "vec", optional, tag = "4")]
    pub public_values_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional cycles used when executing the request, only included if the
    /// request is valid.
    #[prost(uint64, optional, tag = "5")]
    pub cycles: ::core::option::Option<u64>,
    /// The optional amount of gas used when executing the request, only included if
    /// the request is valid.
    #[prost(uint64, optional, tag = "6")]
    pub gas_used: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<ExecuteProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExecuteProofResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailFulfillmentRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<FailFulfillmentRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailFulfillmentRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailFulfillmentResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<FailFulfillmentResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FailFulfillmentResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailExecutionRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<FailExecutionRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailExecutionRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The cause of execution failure.
    #[prost(enumeration = "ExecuteFailureCause", tag = "3")]
    pub execute_fail_cause: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailExecutionResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<FailExecutionResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FailExecutionResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProofRequest {
    /// The request identifier.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The version of the prover to use.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// The mode for the proof.
    #[prost(enumeration = "ProofMode", tag = "4")]
    pub mode: i32,
    /// The strategy for fulfiller assignment.
    #[prost(enumeration = "FulfillmentStrategy", tag = "5")]
    pub strategy: i32,
    /// The program resource identifier.
    #[prost(string, tag = "6")]
    pub program_uri: ::prost::alloc::string::String,
    /// The stdin resource identifier.
    #[prost(string, tag = "7")]
    pub stdin_uri: ::prost::alloc::string::String,
    /// The deadline for the request.
    #[prost(uint64, tag = "8")]
    pub deadline: u64,
    /// The cycle limit for the request.
    #[prost(uint64, tag = "9")]
    pub cycle_limit: u64,
    /// The gas price for the request.
    #[prost(uint64, optional, tag = "10")]
    pub gas_price: ::core::option::Option<u64>,
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "11")]
    pub fulfillment_status: i32,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "12")]
    pub execution_status: i32,
    /// The requester address that signed the request.
    #[prost(bytes = "vec", tag = "13")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
    /// The fulfiller address that fulfilled the request.
    #[prost(bytes = "vec", optional, tag = "14")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional name to refer to an alias of the program id.
    #[prost(string, optional, tag = "15")]
    pub program_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the requester address.
    #[prost(string, optional, tag = "16")]
    pub requester_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "17")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the request was created.
    #[prost(uint64, tag = "18")]
    pub created_at: u64,
    /// The unix timestamp of when the request was updated.
    #[prost(uint64, tag = "19")]
    pub updated_at: u64,
    /// The unix timestamp of when the request was fulfilled. Only included if
    /// the request has a fulfillment status of FULFILLED.
    #[prost(uint64, optional, tag = "20")]
    pub fulfilled_at: ::core::option::Option<u64>,
    /// The transaction hash of the request.
    #[prost(bytes = "vec", tag = "21")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The cycle used during the execution of the request. Only included if the
    /// request has an execution status of EXECUTED.
    #[prost(uint64, optional, tag = "22")]
    pub cycles: ::core::option::Option<u64>,
    /// The public values hash from the execution of the request. Only included if
    /// the request has an execution status of EXECUTED.
    #[prost(bytes = "vec", optional, tag = "23")]
    pub public_values_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The amount deducted from the fulfiller's balance. Only included if the
    /// request has a fulfillment status of ASSIGNED.
    #[prost(string, optional, tag = "24")]
    pub deduction_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// The amount refunded to the fulfiller's balance. Only included if the
    /// request has a fulfillment status of EXECUTED.
    #[prost(string, optional, tag = "25")]
    pub refund_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// The gas limit for the request.
    #[prost(uint64, tag = "26")]
    pub gas_limit: u64,
    /// The amount of gas used for the request.
    #[prost(uint64, optional, tag = "27")]
    pub gas_used: ::core::option::Option<u64>,
    /// The cause of execution failure, if any.
    #[prost(enumeration = "ExecuteFailureCause", tag = "28")]
    pub execute_fail_cause: i32,
    /// The settlement status of the request.
    #[prost(enumeration = "SettlementStatus", tag = "29")]
    pub settlement_status: i32,
    /// The public program resource identifier.
    #[prost(string, tag = "30")]
    pub program_public_uri: ::prost::alloc::string::String,
    /// The public stdin resource identifier.
    #[prost(string, tag = "31")]
    pub stdin_public_uri: ::prost::alloc::string::String,
    /// The minimum period a request can be in auction in seconds. Zero indicates no minimum. Only
    /// applicable if the strategy is auction.
    #[prost(uint64, tag = "32")]
    pub min_auction_period: u64,
    /// The whitelist of provers that can bid and prove this request. An empty list indicates that
    /// any prover can participate. Only applicable if the strategy is auction.
    #[prost(bytes = "vec", repeated, tag = "33")]
    pub whitelist: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestStatusRequest {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestStatusResponse {
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "1")]
    pub fulfillment_status: i32,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "2")]
    pub execution_status: i32,
    /// The transaction hash of the request.
    #[prost(bytes = "vec", tag = "3")]
    pub request_tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The deadline of the request. A request should be ignored if it is past
    /// its deadline.
    #[prost(uint64, tag = "4")]
    pub deadline: u64,
    /// The optional transaction hash of the proof fulfill. Only included if the
    /// request has a fulfillment status of FULFILLED.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub fulfill_tx_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional proof URI, where you can download the result of the request.
    /// Only included if the request has a fulfillment status of FULFILLED.
    #[prost(string, optional, tag = "6")]
    pub proof_uri: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional public values hash from the execution of the request. Only
    /// included if the request has an execution status of EXECUTED.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub public_values_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional public proof URI, where you can download the result of the
    /// request. Only included if the request has a fulfillment status of FULFILLED.
    #[prost(string, optional, tag = "8")]
    pub proof_public_uri: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestDetailsRequest {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestDetailsResponse {
    /// The detailed request.
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<ProofRequest>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProofRequestsRequest {
    /// The optional version of the requests to filter for.
    #[prost(string, optional, tag = "1")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional fulfillment status of the requests to filter for.
    #[prost(enumeration = "FulfillmentStatus", optional, tag = "2")]
    pub fulfillment_status: ::core::option::Option<i32>,
    /// The optional execution status of the requests to filter for.
    #[prost(enumeration = "ExecutionStatus", optional, tag = "3")]
    pub execution_status: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp deadline of the requests to filter for.
    /// Only returns requests with deadlines after this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub minimum_deadline: ::core::option::Option<u64>,
    /// The optional verification key hash of the program to filter for.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub vk_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional requester address to filter for.
    #[prost(bytes = "vec", optional, tag = "6")]
    pub requester: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional fulfiller address to filter for.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional minimum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "8")]
    pub from: ::core::option::Option<u64>,
    /// The optional maximum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "9")]
    pub to: ::core::option::Option<u64>,
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "10")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "11")]
    pub page: ::core::option::Option<u32>,
    /// The optional mode of the requests to filter for.
    #[prost(enumeration = "ProofMode", optional, tag = "12")]
    pub mode: ::core::option::Option<i32>,
    /// The optional bidder address to filter out. Only returns requests that
    /// have not been bid by this address.
    #[prost(bytes = "vec", optional, tag = "13")]
    pub not_bid_by: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional cause of execution failure.
    #[prost(enumeration = "ExecuteFailureCause", optional, tag = "14")]
    pub execute_fail_cause: ::core::option::Option<i32>,
    /// The optional settlement status of the requests to filter for.
    #[prost(enumeration = "SettlementStatus", optional, tag = "15")]
    pub settlement_status: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProofRequestsResponse {
    /// The requests that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<ProofRequest>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSearchResultsRequest {
    /// The search query string.
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResult {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSearchResultsResponse {
    /// List of matching request IDs with optional names.
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<SearchResult>,
    /// List of matching program IDs with optional names.
    #[prost(message, repeated, tag = "2")]
    pub programs: ::prost::alloc::vec::Vec<SearchResult>,
    /// List of matching requester IDs with optional names.
    #[prost(message, repeated, tag = "3")]
    pub requesters: ::prost::alloc::vec::Vec<SearchResult>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestMetricsRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetProofRequestMetricsResponse {
    /// The total number of proofs.
    #[prost(uint64, tag = "1")]
    pub total_proofs: u64,
    /// The total number of cycles.
    #[prost(uint64, tag = "2")]
    pub total_cycles: u64,
    /// The total number of programs.
    #[prost(uint64, tag = "4")]
    pub total_programs: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestGraphRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional interval in days for the graph range.
    #[prost(uint64, optional, tag = "2")]
    pub range_interval_days: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphData {
    /// The timestamp of the data point.
    #[prost(string, tag = "1")]
    pub timestamp: ::prost::alloc::string::String,
    /// The value at this timestamp.
    #[prost(uint64, tag = "2")]
    pub value: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestGraphResponse {
    /// The time series data points.
    #[prost(message, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<GraphData>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnalyticsGraphsRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional interval in days for the graph range.
    #[prost(uint64, optional, tag = "2")]
    pub range_interval_days: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnalyticsGraphsResponse {
    /// The daily time series data points for auction success rate.
    #[prost(message, repeated, tag = "4")]
    pub auction_success_rate: ::prost::alloc::vec::Vec<GraphData>,
    /// The daily time series data points for proof count.
    #[prost(message, repeated, tag = "5")]
    pub proofs: ::prost::alloc::vec::Vec<GraphData>,
    /// The daily time series data points for PROVE / M gas ratio.
    #[prost(message, repeated, tag = "6")]
    pub rewards_mgas: ::prost::alloc::vec::Vec<GraphData>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOverviewGraphsRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOverviewGraphsResponse {
    /// The daily time series data points for proof count.
    #[prost(message, repeated, tag = "1")]
    pub proofs: ::prost::alloc::vec::Vec<GraphData>,
    /// The daily time series data points for cycle count.
    #[prost(message, repeated, tag = "2")]
    pub cycles: ::prost::alloc::vec::Vec<GraphData>,
    /// The daily time series data points for program count.
    #[prost(message, repeated, tag = "3")]
    pub programs: ::prost::alloc::vec::Vec<GraphData>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNonceRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetNonceResponse {
    /// The nonce of the account.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Delegation {
    /// The address of the owner.
    #[prost(bytes = "vec", tag = "1")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    /// The address of the delegate (the account with granted permissions).
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
    /// Whether the delegation has been accepted.
    #[prost(bool, tag = "3")]
    pub accepted: bool,
    /// The unix timestamp of when the delegation was created.
    #[prost(uint64, tag = "4")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredDelegationsRequest {
    /// The optional owner address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub owner: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "2")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "3")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredDelegationsResponse {
    /// The delegations that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub delegations: ::prost::alloc::vec::Vec<Delegation>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddDelegationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AddDelegationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddDelegationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The delegate address to add.
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddDelegationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AddDelegationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddDelegationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveDelegationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RemoveDelegationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveDelegationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The delegate address to remove.
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveDelegationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RemoveDelegationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveDelegationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminateDelegationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<TerminateDelegationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminateDelegationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the owner whose delegation to terminate.
    #[prost(bytes = "vec", tag = "2")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminateDelegationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<TerminateDelegationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TerminateDelegationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceptDelegationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AcceptDelegationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceptDelegationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the owner who requested the delegation
    #[prost(bytes = "vec", tag = "2")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceptDelegationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AcceptDelegationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AcceptDelegationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAccountNameRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetAccountNameRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAccountNameRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the account to update the name of. Only the sender can
    /// update the name unless authorized.
    #[prost(bytes = "vec", tag = "2")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The name of the account. Must be unique.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAccountNameResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetAccountNameResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetAccountNameResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountNameRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountNameResponse {
    /// The name of the account.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOwnerRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOwnerResponse {
    /// The owner of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTermsSignatureRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTermsSignatureResponse {
    /// Whether the account has signed the terms.
    #[prost(bool, tag = "1")]
    pub is_signed: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetTermsSignatureRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The message accepting the terms of service.
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetTermsSignatureResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Account {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The custom name of the account (optional).
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter handle of the account (optional).
    #[prost(string, optional, tag = "3")]
    pub twitter_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter name of the account (optional).
    #[prost(string, optional, tag = "4")]
    pub twitter_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter username of the account (optional).
    #[prost(string, optional, tag = "5")]
    pub twitter_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter image of the account (optional).
    #[prost(string, optional, tag = "6")]
    pub twitter_image: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether the account wants to use their twitter handle to set their name.
    #[prost(bool, tag = "7")]
    pub use_twitter_handle: bool,
    /// Whether the account wants to use their twitter image to set their image.
    #[prost(bool, tag = "8")]
    pub use_twitter_image: bool,
    /// The code of the account (optional).
    #[prost(string, optional, tag = "9")]
    pub code: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether the account has completed onboarding.
    #[prost(bool, tag = "10")]
    pub is_onboarded: bool,
    /// The version of the captcha game the account has completed.
    #[prost(int32, optional, tag = "11")]
    pub last_captcha_version: ::core::option::Option<i32>,
    /// The turbo high score of the account.
    #[prost(int32, optional, tag = "12")]
    pub turbo_high_score: ::core::option::Option<i32>,
    /// The version of the quiz game the account has completed.
    #[prost(int32, optional, tag = "13")]
    pub last_quiz_version: ::core::option::Option<i32>,
    /// The whitelist id of the account (optional).
    #[prost(int64, optional, tag = "14")]
    pub whitelist_id: ::core::option::Option<i64>,
    /// The social platform type from the whitelist (optional).
    #[prost(enumeration = "SocialPlatform", optional, tag = "15")]
    pub whitelist_social_platform: ::core::option::Option<i32>,
    /// The social handle from the whitelist (optional).
    #[prost(string, optional, tag = "16")]
    pub whitelist_social_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The social id from the whitelist (optional).
    #[prost(string, optional, tag = "17")]
    pub whitelist_social_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The social image from the whitelist (optional).
    #[prost(string, optional, tag = "18")]
    pub whitelist_social_image: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether the user completed whitelist social auth.
    #[prost(bool, optional, tag = "19")]
    pub whitelist_has_social_auth: ::core::option::Option<bool>,
    /// The gpu ID of the account (optional).
    #[prost(int64, optional, tag = "20")]
    pub gpu_id: ::core::option::Option<i64>,
    /// The gpu delegate address (optional).
    #[prost(bytes = "vec", optional, tag = "21")]
    pub gpu_delegate: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The gpu variant type (optional).
    #[prost(enumeration = "GpuVariant", optional, tag = "22")]
    pub gpu_variant: ::core::option::Option<i32>,
    /// The proving address of the account (optional). Only included if not delegating to Succinct's
    /// auction fulfiller.
    #[prost(bytes = "vec", optional, tag = "23")]
    pub proving_address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The 2048 high score of the account.
    #[prost(int32, optional, tag = "24")]
    pub high_score_2048: ::core::option::Option<i32>,
    /// The crab volleyball high score of the account.
    #[prost(int32, optional, tag = "25")]
    pub high_score_volleyball: ::core::option::Option<i32>,
    /// The coin craze high score of the account.
    #[prost(int32, optional, tag = "26")]
    pub high_score_coin_craze: ::core::option::Option<i32>,
    /// The turbo time trial high score of the account.
    #[prost(int32, optional, tag = "27")]
    pub high_score_turbo_trials: ::core::option::Option<i32>,
    /// The turbo time trial best rate of the account.
    #[prost(float, optional, tag = "28")]
    pub best_rate_turbo_trials: ::core::option::Option<f32>,
    /// The gpu coordinates (optional).
    #[prost(string, optional, tag = "29")]
    pub gpu_coordinates: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the gpu was created (optional).
    #[prost(uint64, optional, tag = "30")]
    pub gpu_created_at: ::core::option::Option<u64>,
    /// The lean high score of the account.
    #[prost(int32, optional, tag = "31")]
    pub high_score_lean: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountResponse {
    /// The account details.
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Account>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTeeWhitelistStatusRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTeeWhitelistStatusResponse {
    /// The whitelist status.
    #[prost(bool, tag = "1")]
    pub is_whitelisted: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Program {
    /// The verification key hash.
    #[prost(bytes = "vec", tag = "1")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The verification key.
    #[prost(bytes = "vec", tag = "2")]
    pub vk: ::prost::alloc::vec::Vec<u8>,
    /// The program resource identifier.
    #[prost(string, tag = "3")]
    pub program_uri: ::prost::alloc::string::String,
    /// The optional name of the program.
    #[prost(string, optional, tag = "4")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The owner of the program.
    #[prost(bytes = "vec", tag = "5")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    /// The unix timestamp of when the program was created.
    #[prost(uint64, tag = "6")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProgramRequest {
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "1")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProgramResponse {
    /// The program details.
    #[prost(message, optional, tag = "1")]
    pub program: ::core::option::Option<Program>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProgramRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<CreateProgramRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProgramRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The verification key hash.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The verification key.
    #[prost(bytes = "vec", tag = "3")]
    pub vk: ::prost::alloc::vec::Vec<u8>,
    /// The program resource identifier.
    #[prost(string, tag = "4")]
    pub program_uri: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProgramResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<CreateProgramResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateProgramResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetProgramNameRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetProgramNameRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetProgramNameRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier of the program to update the name of. Only the original
    /// program creator can update the name unless authorized.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The name of the program. Must be unique.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetProgramNameResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetProgramNameResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetProgramNameResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceResponse {
    /// The amount of credits owned by the account.
    #[prost(string, tag = "1")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BalanceLog {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The type of balance change operation.
    #[prost(enumeration = "BalanceOperation", tag = "2")]
    pub operation: i32,
    /// The amount of the change (can be positive or negative).
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    /// The transaction hash that caused this change.
    #[prost(bytes = "vec", tag = "4")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The unix timestamp of when this change occurred.
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBalanceLogsRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional type of operations to filter for.
    #[prost(enumeration = "BalanceOperation", optional, tag = "2")]
    pub operation: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp to filter logs from. Only returns
    /// logs after this timestamp.
    #[prost(uint64, optional, tag = "3")]
    pub minimum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum unix timestamp to filter logs to. Only returns
    /// logs before this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub maximum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum number of logs to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "5")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "6")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBalanceLogsResponse {
    /// The balance logs that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub logs: ::prost::alloc::vec::Vec<BalanceLog>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddCreditRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AddCreditRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddCreditRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the account to add credits to.
    #[prost(bytes = "vec", tag = "2")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The amount of credits to add.
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddCreditResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AddCreditResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddCreditResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLatestBridgeBlockRequest {
    /// The chain ID of the bridge.
    #[prost(uint32, tag = "1")]
    pub chain_id: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLatestBridgeBlockResponse {
    /// The latest processed block in the bridge.
    #[prost(uint64, tag = "1")]
    pub block_number: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGasPriceEstimateRequest {
    #[prost(enumeration = "FulfillmentStrategy", tag = "1")]
    pub strategy: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGasPriceEstimateResponse {
    #[prost(uint64, tag = "1")]
    pub gas_price: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionDetailsRequest {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionDetails {
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "4")]
    pub nonce: u64,
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
    #[prost(string, optional, tag = "6")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "7")]
    pub request_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionDetailsResponse {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<TransactionDetails>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddReservedChargeRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AddReservedChargeRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddReservedChargeRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The type of charge.
    #[prost(enumeration = "ChargeType", tag = "2")]
    pub charge_type: i32,
    /// The quantity of the charge.
    #[prost(string, tag = "3")]
    pub quantity: ::prost::alloc::string::String,
    /// The unix timestamp of the charge start time.
    #[prost(uint64, tag = "4")]
    pub start_time: u64,
    /// The unix timestamp of the charge end time.
    #[prost(uint64, tag = "5")]
    pub end_time: u64,
    /// The address of the fulfiller.
    #[prost(bytes = "vec", tag = "6")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddReservedChargeResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AddReservedChargeResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddReservedChargeResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChargeDetails {
    /// The identifier for the charge.
    #[prost(uint64, tag = "1")]
    pub charge_id: u64,
    /// The transaction hash of the charge.
    #[prost(bytes = "vec", tag = "2")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The type of charge.
    #[prost(enumeration = "ChargeType", tag = "3")]
    pub charge_type: i32,
    /// The quantity of the charge.
    #[prost(string, tag = "4")]
    pub quantity: ::prost::alloc::string::String,
    /// The effective price of the charge in USDC.
    #[prost(string, tag = "5")]
    pub effective_price: ::prost::alloc::string::String,
    /// Whether the charge is instant or not.
    #[prost(bool, tag = "6")]
    pub is_instant: bool,
    /// The address of the fulfiller the charge is associated with.
    #[prost(bytes = "vec", tag = "7")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The optional request ID associated with an instant charge.
    #[prost(bytes = "vec", optional, tag = "8")]
    pub request_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional unix timestamp of a non-instant charge start time.
    #[prost(uint64, optional, tag = "9")]
    pub start_time: ::core::option::Option<u64>,
    /// The optional unix timestamp of a non-instant charge end time.
    #[prost(uint64, optional, tag = "10")]
    pub end_time: ::core::option::Option<u64>,
    /// The unix timestamp of when the charge was created.
    #[prost(uint64, tag = "11")]
    pub created_at: u64,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "12")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChargeSummary {
    /// The type of charge.
    #[prost(enumeration = "ChargeType", tag = "1")]
    pub charge_type: i32,
    /// The total prorated amount.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterBillingSummary {
    /// The address of the fulfiller.
    #[prost(bytes = "vec", tag = "1")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "2")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The details of each active reserved charge.
    #[prost(message, repeated, tag = "3")]
    pub reserved_charges_details: ::prost::alloc::vec::Vec<ChargeDetails>,
    /// The summary of each reserved charge type associated with this fulfiller.
    #[prost(message, repeated, tag = "4")]
    pub reserved_charges: ::prost::alloc::vec::Vec<ChargeSummary>,
    /// The summary of each instant charge type associated with this fulfiller.
    #[prost(message, repeated, tag = "5")]
    pub instant_charges: ::prost::alloc::vec::Vec<ChargeSummary>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PayerBillingSummary {
    /// The month, formatted as "mm/yyyy".
    #[prost(string, tag = "1")]
    pub month: ::prost::alloc::string::String,
    /// The sum of all instant charges and prorated reserved charges for the month.
    #[prost(string, tag = "2")]
    pub total: ::prost::alloc::string::String,
    /// The clusters with a billing summary for the month.
    #[prost(message, repeated, tag = "3")]
    pub clusters: ::prost::alloc::vec::Vec<ClusterBillingSummary>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBillingSummaryRequest {
    /// The optional starting month to filter from (inclusive), formatted as "mm/yyyy".
    #[prost(string, optional, tag = "1")]
    pub from_month: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional ending month to filter to (inclusive), formatted as "mm/yyyy".
    #[prost(string, optional, tag = "2")]
    pub to_month: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional maximum number of months to return per page (default is 3, max is 10).
    #[prost(uint32, optional, tag = "3")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "4")]
    pub page: ::core::option::Option<u32>,
    /// The payer to filter for.
    #[prost(bytes = "vec", tag = "5")]
    pub payer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBillingSummaryResponse {
    /// A list summarizing charges by month and clusters for the specified payer.
    #[prost(message, repeated, tag = "1")]
    pub billing_summary: ::prost::alloc::vec::Vec<PayerBillingSummary>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Price {
    /// The address of the fulfiller the price is for.
    #[prost(bytes = "vec", tag = "1")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The type of charge the price is for.
    #[prost(enumeration = "ChargeType", tag = "2")]
    pub charge_type: i32,
    /// The price of the charge type in USDC.
    #[prost(string, tag = "3")]
    pub price: ::prost::alloc::string::String,
    /// Whether the price is the default price.
    #[prost(bool, tag = "4")]
    pub is_default: bool,
    /// The optional note associated with the price.
    #[prost(string, optional, tag = "5")]
    pub note: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the price was created.
    #[prost(uint64, tag = "6")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cluster {
    /// The address of the fulfiller.
    #[prost(bytes = "vec", tag = "1")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The address of the payer.
    #[prost(bytes = "vec", tag = "2")]
    pub payer: ::prost::alloc::vec::Vec<u8>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "3")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the payer address.
    #[prost(string, optional, tag = "4")]
    pub payer_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the fulfiller was created.
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
    /// The current prices for all charge types in this reservation.
    #[prost(message, repeated, tag = "6")]
    pub prices: ::prost::alloc::vec::Vec<Price>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredClustersRequest {
    /// The optional fulfiller address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional payer address to filter for.
    #[prost(bytes = "vec", optional, tag = "2")]
    pub payer: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional maximum number of clusters to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "3")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "4")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredClustersResponse {
    /// The clusters that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub clusters: ::prost::alloc::vec::Vec<Cluster>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePriceRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<UpdatePriceRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePriceRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the fulfiller the price is for.
    #[prost(bytes = "vec", tag = "2")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The type of charge to update the price for.
    #[prost(enumeration = "ChargeType", tag = "3")]
    pub charge_type: i32,
    /// The price to update to.
    #[prost(string, tag = "4")]
    pub price: ::prost::alloc::string::String,
    /// The optional note for the price.
    #[prost(string, optional, tag = "5")]
    pub note: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePriceResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<UpdatePriceResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdatePriceResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsageSummary {
    /// The total amount of gas (reserved + on-demand).
    #[prost(string, tag = "1")]
    pub total_gas: ::prost::alloc::string::String,
    /// The total amount of reserved gas.
    #[prost(string, tag = "2")]
    pub reserved_gas: ::prost::alloc::string::String,
    /// The total amount of on-demand gas.
    #[prost(string, tag = "3")]
    pub on_demand_gas: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterUsageSummary {
    /// The address of the fulfiller.
    #[prost(bytes = "vec", tag = "1")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "2")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The usage summary associated with this fulfiller.
    #[prost(message, optional, tag = "3")]
    pub usage_summary: ::core::option::Option<UsageSummary>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PayerUsageSummary {
    /// The month, formatted as "mm/yyyy".
    #[prost(string, tag = "1")]
    pub month: ::prost::alloc::string::String,
    /// The sum of all reserved and on-demand gas for the month.
    #[prost(string, tag = "2")]
    pub total_gas: ::prost::alloc::string::String,
    /// The sum of all reserved gas for the month.
    #[prost(string, tag = "3")]
    pub total_reserved_gas: ::prost::alloc::string::String,
    /// The sum of all on-demand gas for the month.
    #[prost(string, tag = "4")]
    pub total_on_demand_gas: ::prost::alloc::string::String,
    /// The clusters with a usage summary for the month.
    #[prost(message, repeated, tag = "5")]
    pub clusters: ::prost::alloc::vec::Vec<ClusterUsageSummary>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUsageSummaryRequest {
    /// The optional starting month to filter from (inclusive), formatted as "mm/yyyy".
    #[prost(string, optional, tag = "1")]
    pub from_month: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional ending month to filter to (inclusive), formatted as "mm/yyyy".
    #[prost(string, optional, tag = "2")]
    pub to_month: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional maximum number of months to return per page (default is 3, max is 12).
    #[prost(uint32, optional, tag = "3")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "4")]
    pub page: ::core::option::Option<u32>,
    /// The optional payer to filter for.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub payer: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUsageSummaryResponse {
    /// A list summarizing usage by month and clusters for the specified payer.
    #[prost(message, repeated, tag = "1")]
    pub usage_summary: ::prost::alloc::vec::Vec<PayerUsageSummary>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredChargesRequest {
    /// The optional starting month to filter from (inclusive), formatted as "mm/yyyy".
    #[prost(string, optional, tag = "1")]
    pub from_month: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional ending month to filter to (inclusive), formatted as "mm/yyyy".
    #[prost(string, optional, tag = "2")]
    pub to_month: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional maximum number of months to return per page (default is 3, max is 20).
    #[prost(uint32, optional, tag = "3")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "4")]
    pub page: ::core::option::Option<u32>,
    /// The payer to filter for.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub payer: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The charge types to filter for (empty includes all types).
    #[prost(enumeration = "ChargeType", repeated, tag = "6")]
    pub charge_types: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredChargesResponse {
    /// The charges that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub charges: ::prost::alloc::vec::Vec<ChargeDetails>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reservation {
    /// The address of the requester.
    #[prost(bytes = "vec", tag = "1")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
    /// The address of the fulfiller.
    #[prost(bytes = "vec", tag = "2")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The optional name to refer to an alias of the requester address.
    #[prost(string, optional, tag = "3")]
    pub requester_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "4")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the reservation was created.
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredReservationsRequest {
    /// Requester address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub requester: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional maximum number of reservations to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "2")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "3")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredReservationsResponse {
    /// The reservations that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub reservations: ::prost::alloc::vec::Vec<Reservation>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddReservationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AddReservationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddReservationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the requester to add reservation for.
    #[prost(bytes = "vec", tag = "2")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
    /// The address of the fulfiller to reserve.
    #[prost(bytes = "vec", tag = "3")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddReservationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AddReservationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddReservationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveReservationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RemoveReservationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveReservationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the requester to remove reservation for.
    #[prost(bytes = "vec", tag = "2")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveReservationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RemoveReservationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveReservationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<BidRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The request ID to bid on.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The amount to bid.
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<BidResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BidResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettleRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SettleRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettleRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The request ID to settle bids for.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The winner of the auction.
    #[prost(bytes = "vec", tag = "3")]
    pub winner: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettleResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SettleResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SettleResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Claims {
    /// The subject of the JWT.
    #[prost(bytes = "vec", tag = "1")]
    pub sub: ::prost::alloc::vec::Vec<u8>,
    /// The expiration time of the JWT.
    #[prost(uint64, tag = "2")]
    pub exp: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignInRequest {
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The SIWE message.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignInResponse {
    /// The JSON Web Token (JWT) to use for authentication.
    #[prost(string, tag = "1")]
    pub jwt: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetOnboardedAccountsCountRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetOnboardedAccountsCountResponse {
    /// The number of accounts that have been onboarded.
    #[prost(uint64, tag = "1")]
    pub count: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnboardedAccount {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The unix timestamp of when the account was onboarded.
    #[prost(uint64, tag = "2")]
    pub created_at: u64,
    /// The optional name of the account.
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional twitter handle of the account.
    #[prost(string, optional, tag = "4")]
    pub image: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional invite code referrer of the account.
    #[prost(string, optional, tag = "5")]
    pub referrer: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFilteredOnboardedAccountsRequest {
    /// The optional maximum number of entries to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredOnboardedAccountsResponse {
    /// The accounts that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub accounts: ::prost::alloc::vec::Vec<OnboardedAccount>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaderboardRow {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The rank of the account.
    #[prost(uint64, tag = "2")]
    pub rank: u64,
    /// The optional name of the account.
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional twitter handle of the account.
    #[prost(string, optional, tag = "4")]
    pub image: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional invite code referrer of the account.
    #[prost(string, optional, tag = "5")]
    pub referrer: ::core::option::Option<::prost::alloc::string::String>,
    /// The number of requests.
    #[prost(uint64, tag = "6")]
    pub requests: u64,
    /// The number of cycles.
    #[prost(uint64, tag = "7")]
    pub cycles: u64,
    /// The number of redeemed stars.
    #[prost(uint64, tag = "8")]
    pub redeemed_stars: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaderboardRowWithExtraStars {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The rank of the account.
    #[prost(uint64, tag = "2")]
    pub rank: u64,
    /// The optional name of the account.
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional twitter handle of the account.
    #[prost(string, optional, tag = "4")]
    pub image: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional invite code referrer of the account.
    #[prost(string, optional, tag = "5")]
    pub referrer: ::core::option::Option<::prost::alloc::string::String>,
    /// The number of requests.
    #[prost(uint64, tag = "6")]
    pub requests: u64,
    /// The number of cycles.
    #[prost(uint64, tag = "7")]
    pub cycles: u64,
    /// The number of redeemed stars.
    #[prost(uint64, tag = "8")]
    pub redeemed_stars: u64,
    /// The number of pending stars (total - redeemed).
    #[prost(uint64, tag = "9")]
    pub pending_stars: u64,
    /// The number of referral stars (already counted in pending stars / redeemed stars).
    #[prost(uint64, tag = "10")]
    pub referral_stars: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLeaderboardRequest {
    /// The optional maximum number of entries to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLeaderboardResponse {
    /// The leaderboard entries.
    #[prost(message, repeated, tag = "1")]
    pub leaderboard: ::prost::alloc::vec::Vec<LeaderboardRow>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLeaderboardStatsRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLeaderboardStatsResponse {
    /// The leaderboard stats for the account.
    #[prost(message, optional, tag = "1")]
    pub stats: ::core::option::Option<LeaderboardRowWithExtraStars>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReferralCode {
    /// The code.
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    /// The optional account's address that redeemed the code.
    #[prost(bytes = "vec", optional, tag = "2")]
    pub referred_account: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional account's name that redeemed the code.
    #[prost(string, optional, tag = "3")]
    pub referred_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional account's image that redeemed the code.
    #[prost(string, optional, tag = "4")]
    pub referred_image: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the code was created.
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCodesRequest {
    /// The account to get the codes for.
    #[prost(bytes = "vec", tag = "1")]
    pub account: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCodesResponse {
    /// The codes that the account has.
    #[prost(message, repeated, tag = "1")]
    pub codes: ::prost::alloc::vec::Vec<ReferralCode>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedeemCodeRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RedeemCodeRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedeemCodeRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The code to redeem.
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedeemCodeResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RedeemCodeResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RedeemCodeResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectTwitterRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<ConnectTwitterRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectTwitterRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The callback URI redirected to.
    #[prost(string, tag = "2")]
    pub callback_uri: ::prost::alloc::string::String,
    /// The code from Twitter.
    #[prost(string, tag = "3")]
    pub code: ::prost::alloc::string::String,
    /// The code verifier used in the initial Twitter request.
    #[prost(string, tag = "4")]
    pub code_verifier: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectTwitterResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<ConnectTwitterResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConnectTwitterResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteOnboardingRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<CompleteOnboardingRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CompleteOnboardingRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteOnboardingResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<CompleteOnboardingResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CompleteOnboardingResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUseTwitterHandleRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetUseTwitterHandleRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetUseTwitterHandleRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// Whether to display the Twitter handle.
    #[prost(bool, tag = "2")]
    pub should_display: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUseTwitterHandleResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetUseTwitterHandleResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetUseTwitterHandleResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUseTwitterImageRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetUseTwitterImageRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetUseTwitterImageRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// Whether to display the Twitter profile picture.
    #[prost(bool, tag = "2")]
    pub should_display: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUseTwitterImageResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetUseTwitterImageResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetUseTwitterImageResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestRandomProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RequestRandomProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestRandomProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestRandomProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RequestRandomProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestRandomProofResponseBody {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The name of the randomly selected program.
    #[prost(string, tag = "2")]
    pub program_name: ::prost::alloc::string::String,
    /// The number of bonus stars earned.
    #[prost(uint64, tag = "3")]
    pub stars: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitCaptchaGameRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SubmitCaptchaGameRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitCaptchaGameRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The list of integer answers for the captcha game.
    #[prost(int32, repeated, tag = "2")]
    pub fake_images: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitCaptchaGameResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SubmitCaptchaGameResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitCaptchaGameResponseBody {
    /// The number of correct answers submitted.
    #[prost(uint32, tag = "1")]
    pub correct_count: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedeemStarsRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RedeemStarsRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RedeemStarsRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedeemStarsResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RedeemStarsResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedeemStarsResponseBody {
    /// The base number of stars that were redeemed.
    #[prost(uint64, tag = "1")]
    pub base_stars: u64,
    /// The multiplier that was applied.
    #[prost(string, tag = "2")]
    pub multiplier: ::prost::alloc::string::String,
    /// The final number of stars after applying the multiplier.
    #[prost(uint64, tag = "3")]
    pub final_stars: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFlappyLeaderboardRequest {
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlappyBirdEntry {
    /// The unique ID of the proof request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The account that submitted the proof request.
    #[prost(bytes = "vec", tag = "2")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
    /// The number of cycles used.
    #[prost(uint64, tag = "3")]
    pub cycles: u64,
    /// The player's score.
    #[prost(uint64, tag = "4")]
    pub score: u64,
    /// The twitter username of the account.
    #[prost(string, optional, tag = "5")]
    pub twitter_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter image of the account.
    #[prost(string, optional, tag = "6")]
    pub twitter_image: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether the account wants to use their twitter handle to set their name.
    #[prost(bool, tag = "7")]
    pub use_twitter_handle: bool,
    /// Whether the account wants to use their twitter image to set their image.
    #[prost(bool, tag = "8")]
    pub use_twitter_image: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFlappyLeaderboardResponse {
    /// List of flappy bird leaderboard entries.
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<FlappyBirdEntry>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTurboHighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetTurboHighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetTurboHighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTurboHighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetTurboHighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetTurboHighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitQuizGameRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SubmitQuizGameRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitQuizGameRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The list of integer answers for the quiz game.
    #[prost(int32, repeated, tag = "2")]
    pub answers: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitQuizGameResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SubmitQuizGameResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitQuizGameResponseBody {
    /// The number of correct answers submitted.
    #[prost(uint32, tag = "1")]
    pub correct_count: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTurboLeaderboardRequest {
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TurboLeaderboardEntry {
    /// The account that submitted the proof request.
    #[prost(bytes = "vec", tag = "1")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
    /// The player's score.
    #[prost(uint64, tag = "2")]
    pub score: u64,
    /// The twitter username of the account.
    #[prost(string, optional, tag = "3")]
    pub twitter_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter image of the account.
    #[prost(string, optional, tag = "4")]
    pub twitter_image: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether the account wants to use their twitter handle to set their name.
    #[prost(bool, tag = "5")]
    pub use_twitter_handle: bool,
    /// Whether the account wants to use their twitter image to set their image.
    #[prost(bool, tag = "6")]
    pub use_twitter_image: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTurboLeaderboardResponse {
    /// List of turbo leaderboard entries.
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<TurboLeaderboardEntry>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitEthBlockMetadataRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SubmitEthBlockMetadataBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitEthBlockMetadataBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The request identifier for which this metadata is for.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The chain identifier.
    #[prost(uint32, tag = "3")]
    pub chain_id: u32,
    /// The block hash.
    #[prost(bytes = "vec", tag = "4")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    /// The block number.
    #[prost(uint64, tag = "5")]
    pub number: u64,
    /// The block timestamp.
    #[prost(uint64, tag = "6")]
    pub timestamp: u64,
    /// The block transaction count.
    #[prost(uint64, tag = "7")]
    pub tx_count: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitEthBlockMetadataResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SubmitEthBlockMetadataResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitEthBlockMetadataResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bid {
    /// The address of the bidder.
    #[prost(bytes = "vec", tag = "1")]
    pub bidder: ::prost::alloc::vec::Vec<u8>,
    /// The amount of the bid.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bet {
    /// The address of the bettor.
    #[prost(bytes = "vec", tag = "1")]
    pub bettor: ::prost::alloc::vec::Vec<u8>,
    /// The amount of the bet.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EthBlockRequest {
    /// The request identifier.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The version of the prover to use.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// The mode for the proof.
    #[prost(enumeration = "ProofMode", tag = "4")]
    pub mode: i32,
    /// The strategy for fulfiller assignment.
    #[prost(enumeration = "FulfillmentStrategy", tag = "5")]
    pub strategy: i32,
    /// The program resource identifier.
    #[prost(string, tag = "6")]
    pub program_uri: ::prost::alloc::string::String,
    /// The stdin resource identifier.
    #[prost(string, tag = "7")]
    pub stdin_uri: ::prost::alloc::string::String,
    /// The deadline for the request.
    #[prost(uint64, tag = "8")]
    pub deadline: u64,
    /// The cycle limit for the request.
    #[prost(uint64, tag = "9")]
    pub cycle_limit: u64,
    /// The gas price for the request.
    #[prost(uint64, optional, tag = "10")]
    pub gas_price: ::core::option::Option<u64>,
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "11")]
    pub fulfillment_status: i32,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "12")]
    pub execution_status: i32,
    /// The requester address that signed the request.
    #[prost(bytes = "vec", tag = "13")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
    /// The fulfiller address that fulfilled the request.
    #[prost(bytes = "vec", optional, tag = "14")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional name to refer to an alias of the program id.
    #[prost(string, optional, tag = "15")]
    pub program_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the requester address.
    #[prost(string, optional, tag = "16")]
    pub requester_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "17")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the request was created.
    #[prost(uint64, tag = "18")]
    pub created_at: u64,
    /// The unix timestamp of when the request was updated.
    #[prost(uint64, tag = "19")]
    pub updated_at: u64,
    /// The unix timestamp of when the request was fulfilled. Only included if
    /// the request has a fulfillment status of FULFILLED.
    #[prost(uint64, optional, tag = "20")]
    pub fulfilled_at: ::core::option::Option<u64>,
    /// The transaction hash of the request.
    #[prost(bytes = "vec", tag = "21")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The cycle used during the execution of the request. Only included if the
    /// request has an execution status of EXECUTED.
    #[prost(uint64, optional, tag = "22")]
    pub cycles: ::core::option::Option<u64>,
    /// The public values hash from the execution of the request. Only included if
    /// the request has an execution status of EXECUTED.
    #[prost(bytes = "vec", optional, tag = "23")]
    pub public_values_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The amount deducted from the fulfiller's balance. Only included if the
    /// request has a fulfillment status of ASSIGNED.
    #[prost(string, optional, tag = "24")]
    pub deduction_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// The amount refunded to the fulfiller's balance. Only included if the
    /// request has a fulfillment status of EXECUTED.
    #[prost(string, optional, tag = "25")]
    pub refund_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// The chain id of the request.
    #[prost(uint32, tag = "26")]
    pub chain_id: u32,
    /// The block hash of the request.
    #[prost(bytes = "vec", tag = "27")]
    pub block_hash: ::prost::alloc::vec::Vec<u8>,
    /// The block number of the request.
    #[prost(uint64, tag = "28")]
    pub block_number: u64,
    /// The block timestamp of the request.
    #[prost(uint64, tag = "29")]
    pub block_timestamp: u64,
    /// The block transaction count of the request.
    #[prost(uint64, tag = "30")]
    pub block_tx_count: u64,
    /// The bids for the request.
    #[prost(message, repeated, tag = "31")]
    pub bids: ::prost::alloc::vec::Vec<Bid>,
    /// When the auction was settled.
    #[prost(uint64, optional, tag = "32")]
    pub settled_at: ::core::option::Option<u64>,
    /// The fulfiller social platform.
    #[prost(enumeration = "SocialPlatform", optional, tag = "33")]
    pub fulfiller_social_platform: ::core::option::Option<i32>,
    /// The fulfiller social id.
    #[prost(string, optional, tag = "34")]
    pub fulfiller_social_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The fulfiller social handle.
    #[prost(string, optional, tag = "35")]
    pub fulfiller_social_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The fulfiller social image.
    #[prost(string, optional, tag = "36")]
    pub fulfiller_social_image: ::core::option::Option<::prost::alloc::string::String>,
    /// The bets for the request.
    #[prost(message, repeated, tag = "37")]
    pub bets: ::prost::alloc::vec::Vec<BettorDetails>,
    /// The public program resource identifier.
    #[prost(string, tag = "38")]
    pub program_public_uri: ::prost::alloc::string::String,
    /// The public stdin resource identifier.
    #[prost(string, tag = "39")]
    pub stdin_public_uri: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredEthBlockRequestsRequest {
    /// The optional version of the requests to filter for.
    #[prost(string, optional, tag = "1")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional fulfillment status of the requests to filter for.
    #[prost(enumeration = "FulfillmentStatus", optional, tag = "2")]
    pub fulfillment_status: ::core::option::Option<i32>,
    /// The optional execution status of the requests to filter for.
    #[prost(enumeration = "ExecutionStatus", optional, tag = "3")]
    pub execution_status: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp deadline of the requests to filter for.
    /// Only returns requests with deadlines after this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub minimum_deadline: ::core::option::Option<u64>,
    /// The optional verification key hash of the program to filter for.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub vk_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional requester address to filter for.
    #[prost(bytes = "vec", optional, tag = "6")]
    pub requester: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional fulfiller address to filter for.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional minimum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "8")]
    pub from: ::core::option::Option<u64>,
    /// The optional maximum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "9")]
    pub to: ::core::option::Option<u64>,
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "10")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "11")]
    pub page: ::core::option::Option<u32>,
    /// The optional mode of the requests to filter for.
    #[prost(enumeration = "ProofMode", optional, tag = "12")]
    pub mode: ::core::option::Option<i32>,
    /// The optional bidder address to filter out. Only returns requests that
    /// have not been bid by this address.
    #[prost(bytes = "vec", optional, tag = "13")]
    pub not_bid_by: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredEthBlockRequestsResponse {
    /// The list of filtered requests.
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<EthBlockRequest>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Set2048HighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<Set2048HighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Set2048HighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Set2048HighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<Set2048HighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Set2048HighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetVolleyballHighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetVolleyballHighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetVolleyballHighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
    /// The difficulty of the game.
    #[prost(enumeration = "VolleyballDifficulty", tag = "3")]
    pub difficulty: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetVolleyballHighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetVolleyballHighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetVolleyballHighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTurboTimeTrialHighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetTurboTimeTrialHighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetTurboTimeTrialHighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
    /// The best rate to set.
    #[prost(float, tag = "3")]
    pub best_rate: f32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTurboTimeTrialHighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetTurboTimeTrialHighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetTurboTimeTrialHighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetCoinCrazeHighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetCoinCrazeHighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetCoinCrazeHighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetCoinCrazeHighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetCoinCrazeHighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetCoinCrazeHighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLeanHighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetLeanHighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetLeanHighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLeanHighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetLeanHighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetLeanHighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetFlowHighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetFlowHighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetFlowHighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetFlowHighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetFlowHighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetFlowHighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRollupHighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetRollupHighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetRollupHighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
    /// The victory status for the game.
    #[prost(bool, tag = "3")]
    pub is_victory: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRollupHighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetRollupHighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetRollupHighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPendingStarsRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetPendingStarsResponse {
    /// The pending stars for the account.
    #[prost(uint64, tag = "1")]
    pub pending_stars: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SocialIdentity {
    /// The social platform.
    #[prost(enumeration = "SocialPlatform", tag = "1")]
    pub platform: i32,
    /// The social handle to check.
    #[prost(string, tag = "2")]
    pub handle: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWhitelistStatusRequest {
    #[prost(oneof = "get_whitelist_status_request::Identifier", tags = "1, 2")]
    pub identifier: ::core::option::Option<get_whitelist_status_request::Identifier>,
}
/// Nested message and enum types in `GetWhitelistStatusRequest`.
pub mod get_whitelist_status_request {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Identifier {
        /// The ethereum address to check.
        #[prost(bytes, tag = "1")]
        Address(::prost::alloc::vec::Vec<u8>),
        /// The social identity to check.
        #[prost(message, tag = "2")]
        SocialIdentity(super::SocialIdentity),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetWhitelistStatusResponse {
    /// Whether the user is whitelisted.
    #[prost(bool, tag = "1")]
    pub is_whitelisted: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGpuDelegateRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetGpuDelegateRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGpuDelegateRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The ethereum address to delegate to.
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGpuDelegateResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetGpuDelegateResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetGpuDelegateResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimGpuRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<ClaimGpuRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimGpuRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The ethereum address to delegate to.
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
    /// The gpu variant.
    #[prost(enumeration = "GpuVariant", tag = "3")]
    pub variant: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimGpuResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<ClaimGpuResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClaimGpuResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGpuVariantRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetGpuVariantRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetGpuVariantRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The gpu variant.
    #[prost(enumeration = "GpuVariant", tag = "2")]
    pub variant: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGpuVariantResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetGpuVariantResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetGpuVariantResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedTwitterRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<LinkWhitelistedTwitterRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedTwitterRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The callback URI redirected to.
    #[prost(string, tag = "2")]
    pub callback_uri: ::prost::alloc::string::String,
    /// The code from Twitter.
    #[prost(string, tag = "3")]
    pub code: ::prost::alloc::string::String,
    /// The code verifier used in the initial Twitter request.
    #[prost(string, tag = "4")]
    pub code_verifier: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedTwitterResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<LinkWhitelistedTwitterResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedTwitterResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveProvingKeyRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RetrieveProvingKeyRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RetrieveProvingKeyRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveProvingKeyResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RetrieveProvingKeyResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveProvingKeyResponseBody {
    /// The proving key.
    #[prost(bytes = "vec", tag = "1")]
    pub proving_key: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedGithubRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<LinkWhitelistedGithubRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedGithubRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The callback URI redirected to.
    #[prost(string, tag = "2")]
    pub callback_uri: ::prost::alloc::string::String,
    /// The code from GitHub.
    #[prost(string, tag = "3")]
    pub code: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedGithubResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<LinkWhitelistedGithubResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedGithubResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedDiscordRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<LinkWhitelistedDiscordRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedDiscordRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The callback URI redirected to.
    #[prost(string, tag = "2")]
    pub callback_uri: ::prost::alloc::string::String,
    /// The code from Discord.
    #[prost(string, tag = "3")]
    pub code: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedDiscordResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<LinkWhitelistedDiscordResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedDiscordResponseBody {}
/// Link independent social account (Discord)
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkSocialDiscordRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<LinkSocialDiscordRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkSocialDiscordRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The OAuth callback URI.
    #[prost(string, tag = "2")]
    pub callback_uri: ::prost::alloc::string::String,
    /// The OAuth authorization code.
    #[prost(string, tag = "3")]
    pub code: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkSocialDiscordResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<LinkSocialDiscordResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LinkSocialDiscordResponseBody {}
/// Link independent social account (Twitter)
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkSocialTwitterRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<LinkSocialTwitterRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkSocialTwitterRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The OAuth callback URI.
    #[prost(string, tag = "2")]
    pub callback_uri: ::prost::alloc::string::String,
    /// The OAuth authorization code.
    #[prost(string, tag = "3")]
    pub code: ::prost::alloc::string::String,
    /// The OAuth code verifier for PKCE.
    #[prost(string, tag = "4")]
    pub code_verifier: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkSocialTwitterResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<LinkSocialTwitterResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LinkSocialTwitterResponseBody {}
/// Get linked social accounts
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLinkedSocialAccountsRequest {
    /// The account address to get linked accounts for.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkedSocialAccount {
    /// The social platform.
    #[prost(enumeration = "SocialPlatform", tag = "1")]
    pub platform: i32,
    /// The social handle.
    #[prost(string, tag = "2")]
    pub social_handle: ::prost::alloc::string::String,
    /// The social ID.
    #[prost(string, tag = "3")]
    pub social_id: ::prost::alloc::string::String,
    /// The social profile image URL.
    #[prost(string, tag = "4")]
    pub social_image: ::prost::alloc::string::String,
    /// When the account was linked.
    #[prost(uint64, tag = "5")]
    pub linked_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestnetTwitterAccount {
    /// The Twitter ID.
    #[prost(string, tag = "1")]
    pub social_id: ::prost::alloc::string::String,
    /// The Twitter handle.
    #[prost(string, tag = "2")]
    pub social_handle: ::prost::alloc::string::String,
    /// The Twitter name.
    #[prost(string, tag = "3")]
    pub social_name: ::prost::alloc::string::String,
    /// The Twitter profile image URL.
    #[prost(string, tag = "4")]
    pub social_image: ::prost::alloc::string::String,
    /// Whether the user wants to use their Twitter handle.
    #[prost(bool, tag = "5")]
    pub use_twitter_handle: bool,
    /// Whether the user wants to use their Twitter image.
    #[prost(bool, tag = "6")]
    pub use_twitter_image: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WhitelistSocialAccount {
    /// The social platform.
    #[prost(enumeration = "SocialPlatform", tag = "1")]
    pub platform: i32,
    /// The social handle.
    #[prost(string, tag = "2")]
    pub social_handle: ::prost::alloc::string::String,
    /// The social ID.
    #[prost(string, tag = "3")]
    pub social_id: ::prost::alloc::string::String,
    /// The social profile image URL.
    #[prost(string, tag = "4")]
    pub social_image: ::prost::alloc::string::String,
    /// Whether the user completed whitelist social auth.
    #[prost(bool, tag = "5")]
    pub has_social_auth: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLinkedSocialAccountsResponse {
    /// The linked social accounts (new independent system).
    #[prost(message, repeated, tag = "1")]
    pub accounts: ::prost::alloc::vec::Vec<LinkedSocialAccount>,
    /// The testnet Twitter account (legacy system via accounts.twitter -> twitters.id).
    #[prost(message, optional, tag = "2")]
    pub testnet_twitter: ::core::option::Option<TestnetTwitterAccount>,
    /// The whitelist social account (whitelist system).
    #[prost(message, optional, tag = "3")]
    pub whitelist_social: ::core::option::Option<WhitelistSocialAccount>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProverEntry {
    /// The social platform.
    #[prost(enumeration = "SocialPlatform", optional, tag = "1")]
    pub social_platform: ::core::option::Option<i32>,
    /// The social handle.
    #[prost(string, optional, tag = "2")]
    pub social_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The social id.
    #[prost(string, optional, tag = "3")]
    pub social_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The social image.
    #[prost(string, optional, tag = "4")]
    pub social_image: ::core::option::Option<::prost::alloc::string::String>,
    /// The gpu variant.
    #[prost(enumeration = "GpuVariant", tag = "5")]
    pub gpu_variant: i32,
    /// The ethereum address of the gpu owner;
    #[prost(bytes = "vec", tag = "6")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    /// The ethereum address of the gpu delegate;
    #[prost(bytes = "vec", tag = "7")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
    /// The total number of proofs.
    #[prost(uint64, tag = "8")]
    pub total_proofs: u64,
    /// The total number of cycles.
    #[prost(uint64, tag = "9")]
    pub total_cycles: u64,
    /// The optional gpu coordinates.
    #[prost(string, optional, tag = "10")]
    pub gpu_coordinates: ::core::option::Option<::prost::alloc::string::String>,
    /// The total number of points;
    #[prost(uint64, tag = "11")]
    pub total_points: u64,
    /// The total number of stars.
    #[prost(uint64, tag = "12")]
    pub total_stars: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEthBlockRequestMetricsRequest {
    /// The optional version of the requests to filter for.
    #[prost(string, optional, tag = "1")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional verification key hash of the program to filter for.
    #[prost(bytes = "vec", optional, tag = "2")]
    pub vk_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional execution status of the requests to filter for.
    #[prost(enumeration = "ExecutionStatus", optional, tag = "3")]
    pub execution_status: ::core::option::Option<i32>,
    /// The optional fulfillment status of the requests to filter for.
    #[prost(enumeration = "FulfillmentStatus", optional, tag = "4")]
    pub fulfillment_status: ::core::option::Option<i32>,
    /// The optional requester address to filter for.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub requester: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional fulfiller address to filter for.
    #[prost(bytes = "vec", optional, tag = "6")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional mode of the requests to filter for.
    #[prost(enumeration = "ProofMode", optional, tag = "7")]
    pub mode: ::core::option::Option<i32>,
    /// The optional minimum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "8")]
    pub from: ::core::option::Option<u64>,
    /// The optional maximum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "9")]
    pub to: ::core::option::Option<u64>,
    /// The optional bidder address to filter out. Only returns requests that
    /// have not been bid by this address.
    #[prost(bytes = "vec", optional, tag = "10")]
    pub not_bid_by: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetEthBlockRequestMetricsResponse {
    /// The total number of requests.
    #[prost(uint64, tag = "1")]
    pub total_requests: u64,
    /// The total number of cycles.
    #[prost(uint64, tag = "2")]
    pub total_cycles: u64,
    /// The total number of bids.
    #[prost(uint64, tag = "3")]
    pub total_bids: u64,
    /// The total number of bets.
    #[prost(uint64, tag = "4")]
    pub total_bets: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetProverLeaderboardRequest {
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
    /// The optional gpu variant to filter by.
    #[prost(enumeration = "GpuVariant", optional, tag = "3")]
    pub gpu_variant: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverLeaderboardResponse {
    /// List of prover leaderboard entries.
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<ProverEntry>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Gpu {
    /// The address of the gpu owner.
    #[prost(bytes = "vec", tag = "1")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    /// The address of the gpu delegate.
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
    /// The gpu variant.
    #[prost(enumeration = "GpuVariant", tag = "3")]
    pub gpu_variant: i32,
    /// The unix timestamp of when the gpu was created.
    #[prost(uint64, tag = "4")]
    pub created_at: u64,
    /// The optional social platform of the gpu owner.
    #[prost(enumeration = "SocialPlatform", optional, tag = "5")]
    pub social_platform: ::core::option::Option<i32>,
    /// The optional social handle of the gpu owner.
    #[prost(string, optional, tag = "6")]
    pub social_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional social id of the gpu owner.
    #[prost(string, optional, tag = "7")]
    pub social_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The social image of the gpu owner.
    #[prost(string, optional, tag = "8")]
    pub social_image: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFilteredGpusRequest {
    /// The optional maximum number of entries to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredGpusResponse {
    /// The gpus that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub gpus: ::prost::alloc::vec::Vec<Gpu>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGpuCoordinatesRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetGpuCoordinatesRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGpuCoordinatesRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The gpu longitude coordinate.
    #[prost(string, tag = "2")]
    pub longitude: ::prost::alloc::string::String,
    /// The gpu latitude coordinate.
    #[prost(string, tag = "3")]
    pub latitude: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGpuCoordinatesResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetGpuCoordinatesResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetGpuCoordinatesResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeDetails {
    /// The type of upgrade.
    #[prost(enumeration = "Upgrade", tag = "1")]
    pub upgrade: i32,
    /// The amount of times the upgrade has been purchased.
    #[prost(uint32, tag = "2")]
    pub count: u32,
    /// The base cost of the upgrade.
    #[prost(string, tag = "3")]
    pub base_cost: ::prost::alloc::string::String,
    /// The cost to purchase the next upgrade level.
    #[prost(string, tag = "4")]
    pub next_level_cost: ::prost::alloc::string::String,
    /// The upgrade amount;
    #[prost(string, tag = "5")]
    pub amount: ::prost::alloc::string::String,
    /// The max level allowed for the upgrade.
    #[prost(uint32, tag = "6")]
    pub max_level: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPointsRequest {
    /// The address of the account to get points for.
    #[prost(bytes = "vec", tag = "1")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPointsResponse {
    /// The amount of points owned by the account.
    #[prost(string, tag = "2")]
    pub points_from_rate: ::prost::alloc::string::String,
    /// The amount of points owned by the account.
    #[prost(string, tag = "3")]
    pub total_points: ::prost::alloc::string::String,
    /// The owner's current earn rate.
    #[prost(string, tag = "4")]
    pub earn_rate: ::prost::alloc::string::String,
    /// The owner's current click value.
    #[prost(string, tag = "5")]
    pub click_value: ::prost::alloc::string::String,
    /// The owner's maximum clicks allowed per period.
    #[prost(uint32, tag = "6")]
    pub max_clicks_per_period: u32,
    /// The owner's amount of clicks in the current period.
    #[prost(uint32, tag = "7")]
    pub clicks_current_period: u32,
    /// The unix timestamp of when click period resets.
    #[prost(uint64, tag = "8")]
    pub clicks_reset_date: u64,
    /// The unix timestamp of the last time clicks were processed.
    #[prost(uint64, tag = "9")]
    pub last_click_date: u64,
    /// Whether the owner is in overclocked state for the current period.
    #[prost(bool, tag = "10")]
    pub overclocked: bool,
    /// Detailed information about each upgrade.
    #[prost(message, repeated, tag = "11")]
    pub upgrades: ::prost::alloc::vec::Vec<UpgradeDetails>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessClicksRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<ProcessClicksRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProcessClicksRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The number of clicks to process.
    #[prost(uint32, tag = "2")]
    pub clicks: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessClicksResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<ProcessClicksResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProcessClicksResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurchaseUpgradeRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<PurchaseUpgradeRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PurchaseUpgradeRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The upgrade to purchase.
    #[prost(enumeration = "Upgrade", tag = "2")]
    pub upgrade: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurchaseUpgradeResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<PurchaseUpgradeResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PurchaseUpgradeResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BetRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<BetRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BetRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The amount to bet.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "3")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BetResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<BetResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BetResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BettorDetails {
    /// The address of the bettor.
    #[prost(bytes = "vec", tag = "1")]
    pub bettor: ::prost::alloc::vec::Vec<u8>,
    /// The amount of the bet.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
    /// The probability of the bettor winning.
    #[prost(string, tag = "3")]
    pub probability: ::prost::alloc::string::String,
    /// The optional social platform of the bettor.
    #[prost(enumeration = "SocialPlatform", optional, tag = "4")]
    pub social_platform: ::core::option::Option<i32>,
    /// The optional social handle of the bettor.
    #[prost(string, optional, tag = "5")]
    pub social_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional social id of the bettor.
    #[prost(string, optional, tag = "6")]
    pub social_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The social image of the bettor.
    #[prost(string, optional, tag = "7")]
    pub social_image: ::core::option::Option<::prost::alloc::string::String>,
    /// The gpu variant of the bettor.
    #[prost(enumeration = "GpuVariant", optional, tag = "8")]
    pub gpu_variant: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetContestDetailsRequest {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetContestDetailsResponse {
    /// The block number of the request.
    #[prost(uint64, tag = "1")]
    pub block_number: u64,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "2")]
    pub execution_status: i32,
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "3")]
    pub fulfillment_status: i32,
    /// The credits reward amount.
    #[prost(string, tag = "4")]
    pub credits_reward: ::prost::alloc::string::String,
    /// The points reward amount.
    #[prost(string, tag = "5")]
    pub points_reward: ::prost::alloc::string::String,
    /// Detailed information about the winner.
    #[prost(message, optional, tag = "6")]
    pub winner: ::core::option::Option<BettorDetails>,
    /// Detailed information about each loser.
    #[prost(message, repeated, tag = "11")]
    pub losers: ::prost::alloc::vec::Vec<BettorDetails>,
    /// The stars reward amount.
    #[prost(string, tag = "12")]
    pub stars_reward: ::prost::alloc::string::String,
    /// The base stars amount.
    #[prost(string, tag = "13")]
    pub base_stars: ::prost::alloc::string::String,
    /// The multiplier amount.
    #[prost(string, tag = "14")]
    pub multiplier: ::prost::alloc::string::String,
    /// The total amount of bets in the contest.
    #[prost(string, tag = "15")]
    pub total_bets: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContestRequestDetails {
    /// The latest contest id.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub request_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The latest contest creation time.
    #[prost(uint64, optional, tag = "2")]
    pub created_at: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLatestContestRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLatestContestResponse {
    /// The latest contest id.
    #[prost(message, optional, tag = "1")]
    pub new_contest: ::core::option::Option<ContestRequestDetails>,
    /// The current contest id.
    #[prost(message, optional, tag = "2")]
    pub current_contest: ::core::option::Option<ContestRequestDetails>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetContestBettorsRequest {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetContestBettorsResponse {
    /// The bettors.
    #[prost(message, repeated, tag = "1")]
    pub bettors: ::prost::alloc::vec::Vec<BettorDetails>,
    /// The total pool of the contest.
    #[prost(string, tag = "2")]
    pub total_pool: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGpuMetricsRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGpuMetricsResponse {
    /// The total number of gpus.
    #[prost(uint32, tag = "1")]
    pub total_gpus: u32,
    /// The total number of proofs by gpus.
    #[prost(uint32, tag = "2")]
    pub total_proofs: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProverActivity {
    /// The request id.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "2")]
    pub fulfillment_status: i32,
    /// The fulfiller address.
    #[prost(bytes = "vec", tag = "3")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The optional social platform of the fulfiller.
    #[prost(enumeration = "SocialPlatform", optional, tag = "4")]
    pub fulfiller_social_platform: ::core::option::Option<i32>,
    /// The optional social handle of the fulfiller.
    #[prost(string, optional, tag = "5")]
    pub fulfiller_social_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional social id of the fulfiller.
    #[prost(string, optional, tag = "6")]
    pub fulfiller_social_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The social image of the fulfiller.
    #[prost(string, optional, tag = "7")]
    pub fulfiller_social_image: ::core::option::Option<::prost::alloc::string::String>,
    /// The creation time of the request.
    #[prost(uint64, optional, tag = "8")]
    pub created_at: ::core::option::Option<u64>,
    /// The total number of bets placed for this proof.
    #[prost(uint64, tag = "9")]
    pub total_bets: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProverActivityRequest {
    /// The limit for the number of results.
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The page for the results.
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
    /// The optional address to filter by.
    #[prost(bytes = "vec", optional, tag = "3")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProverActivityResponse {
    /// The prover activity.
    #[prost(message, repeated, tag = "1")]
    pub prover_activity: ::prost::alloc::vec::Vec<ProverActivity>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverMetricsRequest {
    /// The address to filter by.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverMetricsResponse {
    /// The total number of proofs.
    #[prost(uint32, tag = "1")]
    pub total_proofs: u32,
    /// Number of contests participated in.
    #[prost(uint32, tag = "2")]
    pub total_contests: u32,
    /// Stars earned.
    #[prost(string, tag = "3")]
    pub stars_earned: ::prost::alloc::string::String,
    /// Average multiplier.
    #[prost(string, tag = "4")]
    pub average_multiplier: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BetHistory {
    /// The request id.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// Points bet.
    #[prost(string, tag = "2")]
    pub points_bet: ::prost::alloc::string::String,
    /// Stars pool.
    #[prost(string, tag = "3")]
    pub star_pool: ::prost::alloc::string::String,
    /// Multiplier.
    #[prost(string, tag = "4")]
    pub multiplier: ::prost::alloc::string::String,
    /// Probability.
    #[prost(string, tag = "5")]
    pub probability: ::prost::alloc::string::String,
    /// Stars reward.
    #[prost(string, tag = "6")]
    pub star_reward: ::prost::alloc::string::String,
    /// The winner.
    #[prost(message, optional, tag = "7")]
    pub winner: ::core::option::Option<BettorDetails>,
    /// The creation time of the bet.
    #[prost(uint64, tag = "8")]
    pub created_at: u64,
    /// The total number of bettors.
    #[prost(uint32, tag = "9")]
    pub total_bettors: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBetHistoryRequest {
    /// The address to filter by.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The limit for the number of results.
    #[prost(uint32, optional, tag = "2")]
    pub limit: ::core::option::Option<u32>,
    /// The page for the results.
    #[prost(uint32, optional, tag = "3")]
    pub page: ::core::option::Option<u32>,
    /// Filter by victory.
    #[prost(bool, optional, tag = "4")]
    pub is_victory: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBetHistoryResponse {
    /// The bet history.
    #[prost(message, repeated, tag = "1")]
    pub bets: ::prost::alloc::vec::Vec<BetHistory>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuTeamStats {
    /// The gpu variant.
    #[prost(enumeration = "GpuVariant", tag = "1")]
    pub gpu_variant: i32,
    /// The total number of gpus.
    #[prost(uint32, tag = "2")]
    pub total_gpus: u32,
    /// The total number of proofs.
    #[prost(uint32, tag = "3")]
    pub total_proofs: u32,
    /// The total number of contests.
    #[prost(uint32, tag = "4")]
    pub total_contests: u32,
    /// The total number of stars won by the gpu team.
    #[prost(string, tag = "5")]
    pub total_stars_won: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGpuTeamStatsRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGpuTeamStatsResponse {
    /// List of gpu team stats.
    #[prost(message, repeated, tag = "1")]
    pub gpu_team_stats: ::prost::alloc::vec::Vec<GpuTeamStats>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetConfigValuesRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetConfigValuesResponse {
    /// The config values.
    #[prost(message, optional, tag = "1")]
    pub config_values: ::core::option::Option<ConfigValues>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConfigValues {
    /// The disable bets flag.
    #[prost(bool, tag = "1")]
    pub disable_bets: bool,
    /// The disable leaderboard flag.
    #[prost(bool, tag = "2")]
    pub disable_leaderboard: bool,
    /// The disable leaderboard stats flag.
    #[prost(bool, tag = "3")]
    pub disable_leaderboard_stats: bool,
    /// The disable explorer trends flag.
    #[prost(bool, tag = "4")]
    pub disable_explorer_trends: bool,
    /// The disable pending stars flag.
    #[prost(bool, tag = "5")]
    pub disable_pending_stars: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverStatsRequest {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetProverStatsResponse {
    #[prost(uint64, tag = "1")]
    pub total_earnings: u64,
    #[prost(uint64, tag = "2")]
    pub total_cycles: u64,
    #[prost(uint64, tag = "3")]
    pub total_gas_proved: u64,
    #[prost(uint64, tag = "4")]
    pub active_provers: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProverStats {
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub twitter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, tag = "4")]
    pub use_twitter_handle: bool,
    #[prost(uint64, tag = "5")]
    pub total_auction_requests: u64,
    #[prost(uint64, tag = "6")]
    pub successful_requests: u64,
    #[prost(uint64, tag = "7")]
    pub total_gas_proved: u64,
    #[prost(uint64, tag = "8")]
    pub last_active_at: u64,
    #[prost(uint64, tag = "9")]
    pub created_at: u64,
    #[prost(uint64, tag = "10")]
    pub total_earnings: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFilteredProverStatsRequest {
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProverStatsResponse {
    #[prost(message, repeated, tag = "1")]
    pub stats: ::prost::alloc::vec::Vec<ProverStats>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverSearchResultsRequest {
    /// The query to search for.
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverSearchResultsResponse {
    #[prost(message, repeated, tag = "1")]
    pub provers: ::prost::alloc::vec::Vec<SearchResult>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidHistory {
    /// The bidder.
    #[prost(bytes = "vec", tag = "1")]
    pub bidder: ::prost::alloc::vec::Vec<u8>,
    /// The amount bid.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
    /// The creation time of the bid.
    #[prost(uint64, tag = "3")]
    pub created_at: u64,
    /// The bidder name.
    #[prost(string, optional, tag = "4")]
    pub bidder_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBidHistoryRequest {
    /// The request id to filter by.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The limit for the number of results.
    #[prost(uint32, optional, tag = "2")]
    pub limit: ::core::option::Option<u32>,
    /// The page for the results.
    #[prost(uint32, optional, tag = "3")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBidHistoryResponse {
    #[prost(message, repeated, tag = "1")]
    pub bids: ::prost::alloc::vec::Vec<BidHistory>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedMessage {
    /// The message.
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    /// The signature.
    #[prost(string, tag = "2")]
    pub signature: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettlementRequest {
    /// The RequestProofRequest signed message.
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<SignedMessage>,
    /// The BidRequest signed message.
    #[prost(message, optional, tag = "2")]
    pub bid: ::core::option::Option<SignedMessage>,
    /// The SettleRequest signed message.
    #[prost(message, optional, tag = "3")]
    pub settle: ::core::option::Option<SignedMessage>,
    /// The ExecuteProofRequest signed message.
    #[prost(message, optional, tag = "4")]
    pub execute: ::core::option::Option<SignedMessage>,
    /// The FulfillProofRequest signed message.
    #[prost(message, optional, tag = "5")]
    pub fulfill: ::core::option::Option<SignedMessage>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSettlementRequestRequest {
    /// The request ID to get signed messages for.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSettlementRequestResponse {
    /// The settlement request.
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<SettlementRequest>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredSettlementRequestsRequest {
    /// The list of request IDs to get signed messages for.
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub request_ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredSettlementRequestsResponse {
    /// The list of signed messages.
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<SettlementRequest>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Prover {
    /// The address of the prover.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The owner of the prover.
    #[prost(bytes = "vec", tag = "2")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    /// The name of the prover.
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The block number of the prover was created in.
    #[prost(uint64, tag = "4")]
    pub block_number: u64,
    /// The transaction hash of the prover was created in.
    #[prost(bytes = "vec", tag = "5")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFilteredProversRequest {
    /// The optional maximum number of provers to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProversResponse {
    #[prost(message, repeated, tag = "1")]
    pub provers: ::prost::alloc::vec::Vec<Prover>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStakerStakeBalanceRequest {
    /// The account to get the stake balance for. This can be a prover or the owner of the prover.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStakerStakeBalanceResponse {
    /// The stake balance.
    #[prost(string, tag = "1")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverStakeBalanceRequest {
    /// The address of the prover.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverStakeBalanceResponse {
    /// The stake balance.
    #[prost(string, tag = "1")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StakeBalanceLog {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The type of balance change operation.
    #[prost(enumeration = "StakeBalanceOperation", tag = "2")]
    pub operation: i32,
    /// The amount of the change (can be positive or negative).
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    /// The transaction hash that caused this change.
    #[prost(bytes = "vec", tag = "4")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The unix timestamp of when this change occurred.
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredStakerStakeBalanceLogsRequest {
    /// The optional staker address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional type of operations to filter for.
    #[prost(enumeration = "StakeBalanceOperation", optional, tag = "2")]
    pub operation: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp to filter logs from. Only returns
    /// logs after this timestamp.
    #[prost(uint64, optional, tag = "3")]
    pub minimum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum unix timestamp to filter logs to. Only returns
    /// logs before this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub maximum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum number of logs to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "5")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "6")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredStakerStakeBalanceLogsResponse {
    /// The staker balance logs.
    #[prost(message, repeated, tag = "1")]
    pub logs: ::prost::alloc::vec::Vec<StakeBalanceLog>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProverStakeBalanceLogsRequest {
    /// The optional prover address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional type of operations to filter for.
    #[prost(enumeration = "StakeBalanceOperation", optional, tag = "2")]
    pub operation: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp to filter logs from. Only returns
    /// logs after this timestamp.
    #[prost(uint64, optional, tag = "3")]
    pub minimum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum unix timestamp to filter logs to. Only returns
    /// logs before this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub maximum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum number of logs to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "5")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "6")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProverStakeBalanceLogsResponse {
    /// The prover balance logs.
    #[prost(message, repeated, tag = "1")]
    pub logs: ::prost::alloc::vec::Vec<StakeBalanceLog>,
}
/// Format to help decode signature in backend.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MessageFormat {
    /// Unspecified message format.
    UnspecifiedMessageFormat = 0,
    /// The message is in binary format.
    Binary = 1,
    /// The message is in JSON format.
    Json = 2,
}
impl MessageFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedMessageFormat => "UNSPECIFIED_MESSAGE_FORMAT",
            Self::Binary => "BINARY",
            Self::Json => "JSON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_MESSAGE_FORMAT" => Some(Self::UnspecifiedMessageFormat),
            "BINARY" => Some(Self::Binary),
            "JSON" => Some(Self::Json),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VolleyballDifficulty {
    Easy = 0,
    Medium = 1,
    Hard = 2,
    Troll = 3,
}
impl VolleyballDifficulty {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Easy => "EASY",
            Self::Medium => "MEDIUM",
            Self::Hard => "HARD",
            Self::Troll => "TROLL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EASY" => Some(Self::Easy),
            "MEDIUM" => Some(Self::Medium),
            "HARD" => Some(Self::Hard),
            "TROLL" => Some(Self::Troll),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProofMode {
    UnspecifiedProofMode = 0,
    /// The core proof mode.
    Core = 1,
    /// The compressed proof mode.
    Compressed = 2,
    /// The plonk proof mode.
    Plonk = 3,
    /// The groth16 proof mode.
    Groth16 = 4,
}
impl ProofMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedProofMode => "UNSPECIFIED_PROOF_MODE",
            Self::Core => "CORE",
            Self::Compressed => "COMPRESSED",
            Self::Plonk => "PLONK",
            Self::Groth16 => "GROTH16",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_PROOF_MODE" => Some(Self::UnspecifiedProofMode),
            "CORE" => Some(Self::Core),
            "COMPRESSED" => Some(Self::Compressed),
            "PLONK" => Some(Self::Plonk),
            "GROTH16" => Some(Self::Groth16),
            _ => None,
        }
    }
}
/// The different strategies that can be used for fulfilling requests.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FulfillmentStrategy {
    UnspecifiedFulfillmentStrategy = 0,
    /// The hosted fulfillment strategy. Uses Succinct's on-demand prover to fulfill requests.
    Hosted = 1,
    /// The reserved fulfillment strategy. Uses an already existing agreement with a
    /// fulfiller to fulfill requests.
    Reserved = 2,
    /// The auction fulfillment strategy. Uses a decentralized proof contest to
    /// fulfill requests.
    Auction = 3,
}
impl FulfillmentStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedFulfillmentStrategy => "UNSPECIFIED_FULFILLMENT_STRATEGY",
            Self::Hosted => "HOSTED",
            Self::Reserved => "RESERVED",
            Self::Auction => "AUCTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_FULFILLMENT_STRATEGY" => {
                Some(Self::UnspecifiedFulfillmentStrategy)
            }
            "HOSTED" => Some(Self::Hosted),
            "RESERVED" => Some(Self::Reserved),
            "AUCTION" => Some(Self::Auction),
            _ => None,
        }
    }
}
/// The different fulfillment statuses that a request can be in.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FulfillmentStatus {
    UnspecifiedFulfillmentStatus = 0,
    /// The request has been requested.
    Requested = 1,
    /// The request has been assigned to a fulfiller.
    Assigned = 2,
    /// The request has been fulfilled.
    Fulfilled = 3,
    /// The request cannot be fulfilled.
    Unfulfillable = 4,
}
impl FulfillmentStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedFulfillmentStatus => "UNSPECIFIED_FULFILLMENT_STATUS",
            Self::Requested => "REQUESTED",
            Self::Assigned => "ASSIGNED",
            Self::Fulfilled => "FULFILLED",
            Self::Unfulfillable => "UNFULFILLABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_FULFILLMENT_STATUS" => Some(Self::UnspecifiedFulfillmentStatus),
            "REQUESTED" => Some(Self::Requested),
            "ASSIGNED" => Some(Self::Assigned),
            "FULFILLED" => Some(Self::Fulfilled),
            "UNFULFILLABLE" => Some(Self::Unfulfillable),
            _ => None,
        }
    }
}
/// The different execution statuses that a request can be in.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecutionStatus {
    UnspecifiedExecutionStatus = 0,
    /// The request has not been executed.
    Unexecuted = 1,
    /// The request has been executed.
    Executed = 2,
    /// The request cannot be executed.
    Unexecutable = 3,
}
impl ExecutionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedExecutionStatus => "UNSPECIFIED_EXECUTION_STATUS",
            Self::Unexecuted => "UNEXECUTED",
            Self::Executed => "EXECUTED",
            Self::Unexecutable => "UNEXECUTABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_EXECUTION_STATUS" => Some(Self::UnspecifiedExecutionStatus),
            "UNEXECUTED" => Some(Self::Unexecuted),
            "EXECUTED" => Some(Self::Executed),
            "UNEXECUTABLE" => Some(Self::Unexecutable),
            _ => None,
        }
    }
}
/// The different settlement statuses that a request can be in.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SettlementStatus {
    UnspecifiedSettlementStatus = 0,
    /// The request has not been settled.
    Unsettled = 1,
    /// The request has been settled.
    Settled = 2,
}
impl SettlementStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedSettlementStatus => "UNSPECIFIED_SETTLEMENT_STATUS",
            Self::Unsettled => "UNSETTLED",
            Self::Settled => "SETTLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_SETTLEMENT_STATUS" => Some(Self::UnspecifiedSettlementStatus),
            "UNSETTLED" => Some(Self::Unsettled),
            "SETTLED" => Some(Self::Settled),
            _ => None,
        }
    }
}
/// The different types of balance changes that can occur for credits.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BalanceOperation {
    UnspecifiedBalanceChangeOperation = 0,
    /// A deposit operation (positive).
    Deposit = 1,
    /// A withdrawal operation (negative).
    Withdrawal = 2,
    /// A credit operation (positive).
    Credit = 3,
    /// A deduction operation (negative).
    Deduction = 4,
    /// A refund operation (positive).
    Refund = 5,
}
impl BalanceOperation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedBalanceChangeOperation => {
                "UNSPECIFIED_BALANCE_CHANGE_OPERATION"
            }
            Self::Deposit => "DEPOSIT",
            Self::Withdrawal => "WITHDRAWAL",
            Self::Credit => "CREDIT",
            Self::Deduction => "DEDUCTION",
            Self::Refund => "REFUND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_BALANCE_CHANGE_OPERATION" => {
                Some(Self::UnspecifiedBalanceChangeOperation)
            }
            "DEPOSIT" => Some(Self::Deposit),
            "WITHDRAWAL" => Some(Self::Withdrawal),
            "CREDIT" => Some(Self::Credit),
            "DEDUCTION" => Some(Self::Deduction),
            "REFUND" => Some(Self::Refund),
            _ => None,
        }
    }
}
/// The different types of balance changes that can occur for stake.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StakeBalanceOperation {
    UnspecifiedStakeBalanceOperation = 0,
    /// A stake operation (positive).
    Stake = 1,
    /// An unstake operation (negative).
    Unstake = 2,
    /// A slash operation (negative).
    Slash = 3,
    /// A bid operation (negative).
    Bid = 4,
}
impl StakeBalanceOperation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedStakeBalanceOperation => {
                "UNSPECIFIED_STAKE_BALANCE_OPERATION"
            }
            Self::Stake => "STAKE",
            Self::Unstake => "UNSTAKE",
            Self::Slash => "SLASH",
            Self::Bid => "BID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_STAKE_BALANCE_OPERATION" => {
                Some(Self::UnspecifiedStakeBalanceOperation)
            }
            "STAKE" => Some(Self::Stake),
            "UNSTAKE" => Some(Self::Unstake),
            "SLASH" => Some(Self::Slash),
            "BID" => Some(Self::Bid),
            _ => None,
        }
    }
}
/// The different social platforms.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SocialPlatform {
    UnspecifiedPlatform = 0,
    /// The twitter platform.
    Twitter = 1,
    /// The github platform.
    Github = 2,
    /// The discord platform.
    Discord = 3,
}
impl SocialPlatform {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedPlatform => "UNSPECIFIED_PLATFORM",
            Self::Twitter => "TWITTER",
            Self::Github => "GITHUB",
            Self::Discord => "DISCORD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_PLATFORM" => Some(Self::UnspecifiedPlatform),
            "TWITTER" => Some(Self::Twitter),
            "GITHUB" => Some(Self::Github),
            "DISCORD" => Some(Self::Discord),
            _ => None,
        }
    }
}
/// The different gpu variants.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GpuVariant {
    UnspecifiedVariant = 0,
    /// The blueberry variant.
    Blueberry = 1,
    /// The strawberry variant.
    Strawberry = 2,
    /// The lime variant.
    Lime = 3,
    /// The tangerine variant.
    Tangerine = 4,
    /// The grape variant.
    Grape = 5,
}
impl GpuVariant {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedVariant => "UNSPECIFIED_VARIANT",
            Self::Blueberry => "BLUEBERRY",
            Self::Strawberry => "STRAWBERRY",
            Self::Lime => "LIME",
            Self::Tangerine => "TANGERINE",
            Self::Grape => "GRAPE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_VARIANT" => Some(Self::UnspecifiedVariant),
            "BLUEBERRY" => Some(Self::Blueberry),
            "STRAWBERRY" => Some(Self::Strawberry),
            "LIME" => Some(Self::Lime),
            "TANGERINE" => Some(Self::Tangerine),
            "GRAPE" => Some(Self::Grape),
            _ => None,
        }
    }
}
/// The different upgrades that can be purchased with points.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Upgrade {
    UnspecifiedUpgrade = 0,
    /// The earn rate boost upgrade.
    EarnRateBoost = 1,
    /// The click worth boost upgrade.
    ClickValueBoost = 2,
    /// The clicks per period boost upgrade.
    ClicksPerPeriodBoost = 3,
}
impl Upgrade {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedUpgrade => "UNSPECIFIED_UPGRADE",
            Self::EarnRateBoost => "EARN_RATE_BOOST",
            Self::ClickValueBoost => "CLICK_VALUE_BOOST",
            Self::ClicksPerPeriodBoost => "CLICKS_PER_PERIOD_BOOST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_UPGRADE" => Some(Self::UnspecifiedUpgrade),
            "EARN_RATE_BOOST" => Some(Self::EarnRateBoost),
            "CLICK_VALUE_BOOST" => Some(Self::ClickValueBoost),
            "CLICKS_PER_PERIOD_BOOST" => Some(Self::ClicksPerPeriodBoost),
            _ => None,
        }
    }
}
/// The different causes for execution failure.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecuteFailureCause {
    UnspecifiedExecutionFailureCause = 0,
    /// The execution failed with a non-zero exit code.
    HaltWithNonZeroExitCode = 1,
    /// The execution failed with an invalid memory access.
    InvalidMemoryAccess = 2,
    /// The execution failed with an unimplemented syscall.
    UnsupportedSyscall = 3,
    /// The execution failed with a breakpoint.
    Breakpoint = 4,
    /// The execution failed with an exceeded cycle limit.
    ExceededCycleLimit = 5,
    /// The execution failed because the syscall was called in unconstrained mode.
    InvalidSyscallUsage = 6,
    /// The execution failed with an unimplemented feature.
    Unimplemented = 7,
    /// The program ended in unconstrained mode.
    EndInUnconstrained = 8,
}
impl ExecuteFailureCause {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedExecutionFailureCause => {
                "UNSPECIFIED_EXECUTION_FAILURE_CAUSE"
            }
            Self::HaltWithNonZeroExitCode => "HALT_WITH_NON_ZERO_EXIT_CODE",
            Self::InvalidMemoryAccess => "INVALID_MEMORY_ACCESS",
            Self::UnsupportedSyscall => "UNSUPPORTED_SYSCALL",
            Self::Breakpoint => "BREAKPOINT",
            Self::ExceededCycleLimit => "EXCEEDED_CYCLE_LIMIT",
            Self::InvalidSyscallUsage => "INVALID_SYSCALL_USAGE",
            Self::Unimplemented => "UNIMPLEMENTED",
            Self::EndInUnconstrained => "END_IN_UNCONSTRAINED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_EXECUTION_FAILURE_CAUSE" => {
                Some(Self::UnspecifiedExecutionFailureCause)
            }
            "HALT_WITH_NON_ZERO_EXIT_CODE" => Some(Self::HaltWithNonZeroExitCode),
            "INVALID_MEMORY_ACCESS" => Some(Self::InvalidMemoryAccess),
            "UNSUPPORTED_SYSCALL" => Some(Self::UnsupportedSyscall),
            "BREAKPOINT" => Some(Self::Breakpoint),
            "EXCEEDED_CYCLE_LIMIT" => Some(Self::ExceededCycleLimit),
            "INVALID_SYSCALL_USAGE" => Some(Self::InvalidSyscallUsage),
            "UNIMPLEMENTED" => Some(Self::Unimplemented),
            "END_IN_UNCONSTRAINED" => Some(Self::EndInUnconstrained),
            _ => None,
        }
    }
}
/// The different types of charges for reserved billing.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChargeType {
    UnspecifiedChargeType = 0,
    /// For base reserved cluster usage.
    BaseCluster = 1,
    /// For reserved GPU throughput.
    ProvisionedMgasPerSec = 2,
    /// For usage exceeding reserved.
    ExcessGas = 3,
    /// For groth16 proofs.
    Groth16Proof = 4,
    /// For plonk proofs.
    PlonkProof = 5,
}
impl ChargeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedChargeType => "UNSPECIFIED_CHARGE_TYPE",
            Self::BaseCluster => "BASE_CLUSTER",
            Self::ProvisionedMgasPerSec => "PROVISIONED_MGAS_PER_SEC",
            Self::ExcessGas => "EXCESS_GAS",
            Self::Groth16Proof => "GROTH16_PROOF",
            Self::PlonkProof => "PLONK_PROOF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_CHARGE_TYPE" => Some(Self::UnspecifiedChargeType),
            "BASE_CLUSTER" => Some(Self::BaseCluster),
            "PROVISIONED_MGAS_PER_SEC" => Some(Self::ProvisionedMgasPerSec),
            "EXCESS_GAS" => Some(Self::ExcessGas),
            "GROTH16_PROOF" => Some(Self::Groth16Proof),
            "PLONK_PROOF" => Some(Self::PlonkProof),
            _ => None,
        }
    }
}