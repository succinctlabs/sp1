// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RequestProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The version of the prover to use.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// The mode for the request.
    #[prost(enumeration = "ProofMode", tag = "4")]
    pub mode: i32,
    /// The strategy for fulfiller assignment.
    #[prost(enumeration = "FulfillmentStrategy", tag = "5")]
    pub strategy: i32,
    /// The stdin resource identifier.
    #[prost(string, tag = "6")]
    pub stdin_uri: ::prost::alloc::string::String,
    /// The deadline for the request.
    #[prost(uint64, tag = "7")]
    pub deadline: u64,
    /// The cycle limit for the request.
    #[prost(uint64, tag = "8")]
    pub cycle_limit: u64,
    /// The gas limit for the request. If 0, the cycle_limit is used.
    #[prost(uint64, tag = "9")]
    pub gas_limit: u64,
    /// The minimum period a request can be in auction in seconds. Zero indicates no minimum. Only
    /// applicable if the strategy is auction.
    #[prost(uint64, tag = "10")]
    pub min_auction_period: u64,
    /// The whitelist of provers that can bid and prove this request. An empty list indicates that
    /// any prover can participate. Only applicable if the strategy is auction.
    #[prost(bytes = "vec", repeated, tag = "11")]
    pub whitelist: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RequestProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestProofResponseBody {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReservedMetadata {
    /// The optional ratio of gpu time the proof used on-demand resources versus reserved.
    #[prost(float, optional, tag = "1")]
    pub on_demand_ratio: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FulfillProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<FulfillProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FulfillProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The proof bytes.
    #[prost(bytes = "vec", tag = "3")]
    pub proof: ::prost::alloc::vec::Vec<u8>,
    /// The optional metadata for reserved proofs.
    #[prost(message, optional, tag = "4")]
    pub reserved_metadata: ::core::option::Option<ReservedMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FulfillProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<FulfillProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FulfillProofResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<ExecuteProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "3")]
    pub execution_status: i32,
    /// The optional public values hash of the request execution, only included if
    /// the request is valid.
    #[prost(bytes = "vec", optional, tag = "4")]
    pub public_values_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional cycles used when executing the request, only included if the
    /// request is valid.
    #[prost(uint64, optional, tag = "5")]
    pub cycles: ::core::option::Option<u64>,
    /// The optional amount of gas used when executing the request, only included if
    /// the request is valid.
    #[prost(uint64, optional, tag = "6")]
    pub gas_used: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<ExecuteProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExecuteProofResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailFulfillmentRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<FailFulfillmentRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailFulfillmentRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailFulfillmentResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<FailFulfillmentResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FailFulfillmentResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailExecutionRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<FailExecutionRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailExecutionRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The cause of execution failure.
    #[prost(enumeration = "ExecuteFailureCause", tag = "3")]
    pub execute_fail_cause: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailExecutionResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<FailExecutionResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FailExecutionResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProofRequest {
    /// The request identifier.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The version of the prover to use.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// The mode for the proof.
    #[prost(enumeration = "ProofMode", tag = "4")]
    pub mode: i32,
    /// The strategy for fulfiller assignment.
    #[prost(enumeration = "FulfillmentStrategy", tag = "5")]
    pub strategy: i32,
    /// The program resource identifier.
    #[prost(string, tag = "6")]
    pub program_uri: ::prost::alloc::string::String,
    /// The stdin resource identifier.
    #[prost(string, tag = "7")]
    pub stdin_uri: ::prost::alloc::string::String,
    /// The deadline for the request.
    #[prost(uint64, tag = "8")]
    pub deadline: u64,
    /// The cycle limit for the request.
    #[prost(uint64, tag = "9")]
    pub cycle_limit: u64,
    /// The gas price for the request.
    #[prost(uint64, optional, tag = "10")]
    pub gas_price: ::core::option::Option<u64>,
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "11")]
    pub fulfillment_status: i32,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "12")]
    pub execution_status: i32,
    /// The requester address that signed the request.
    #[prost(bytes = "vec", tag = "13")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
    /// The fulfiller address that fulfilled the request.
    #[prost(bytes = "vec", optional, tag = "14")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional name to refer to an alias of the program id.
    #[prost(string, optional, tag = "15")]
    pub program_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the requester address.
    #[prost(string, optional, tag = "16")]
    pub requester_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "17")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the request was created.
    #[prost(uint64, tag = "18")]
    pub created_at: u64,
    /// The unix timestamp of when the request was updated.
    #[prost(uint64, tag = "19")]
    pub updated_at: u64,
    /// The unix timestamp of when the request was fulfilled. Only included if
    /// the request has a fulfillment status of FULFILLED.
    #[prost(uint64, optional, tag = "20")]
    pub fulfilled_at: ::core::option::Option<u64>,
    /// The transaction hash of the request.
    #[prost(bytes = "vec", tag = "21")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The cycle used during the execution of the request. Only included if the
    /// request has an execution status of EXECUTED.
    #[prost(uint64, optional, tag = "22")]
    pub cycles: ::core::option::Option<u64>,
    /// The public values hash from the execution of the request. Only included if
    /// the request has an execution status of EXECUTED.
    #[prost(bytes = "vec", optional, tag = "23")]
    pub public_values_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The amount deducted from the fulfiller's balance. Only included if the
    /// request has a fulfillment status of ASSIGNED.
    #[prost(string, optional, tag = "24")]
    pub deduction_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// The amount refunded to the fulfiller's balance. Only included if the
    /// request has a fulfillment status of EXECUTED.
    #[prost(string, optional, tag = "25")]
    pub refund_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// The gas limit for the request.
    #[prost(uint64, tag = "26")]
    pub gas_limit: u64,
    /// The amount of gas used for the request.
    #[prost(uint64, optional, tag = "27")]
    pub gas_used: ::core::option::Option<u64>,
    /// The cause of execution failure, if any.
    #[prost(enumeration = "ExecuteFailureCause", tag = "28")]
    pub execute_fail_cause: i32,
    /// The settlement status of the request.
    #[prost(enumeration = "SettlementStatus", tag = "29")]
    pub settlement_status: i32,
    /// The public program resource identifier.
    #[prost(string, tag = "30")]
    pub program_public_uri: ::prost::alloc::string::String,
    /// The public stdin resource identifier.
    #[prost(string, tag = "31")]
    pub stdin_public_uri: ::prost::alloc::string::String,
    /// The minimum period a request can be in auction in seconds. Zero indicates no minimum. Only
    /// applicable if the strategy is auction.
    #[prost(uint64, tag = "32")]
    pub min_auction_period: u64,
    /// The whitelist of provers that can bid and prove this request. An empty list indicates that
    /// any prover can participate. Only applicable if the strategy is auction.
    #[prost(bytes = "vec", repeated, tag = "33")]
    pub whitelist: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestStatusRequest {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestStatusResponse {
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "1")]
    pub fulfillment_status: i32,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "2")]
    pub execution_status: i32,
    /// The transaction hash of the request.
    #[prost(bytes = "vec", tag = "3")]
    pub request_tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The deadline of the request. A request should be ignored if it is past
    /// its deadline.
    #[prost(uint64, tag = "4")]
    pub deadline: u64,
    /// The optional transaction hash of the proof fulfill. Only included if the
    /// request has a fulfillment status of FULFILLED.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub fulfill_tx_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional proof URI, where you can download the result of the request.
    /// Only included if the request has a fulfillment status of FULFILLED.
    #[prost(string, optional, tag = "6")]
    pub proof_uri: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional public values hash from the execution of the request. Only
    /// included if the request has an execution status of EXECUTED.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub public_values_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional public proof URI, where you can download the result of the
    /// request. Only included if the request has a fulfillment status of FULFILLED.
    #[prost(string, optional, tag = "8")]
    pub proof_public_uri: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestDetailsRequest {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestDetailsResponse {
    /// The detailed request.
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<ProofRequest>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProofRequestsRequest {
    /// The optional version of the requests to filter for.
    #[prost(string, optional, tag = "1")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional fulfillment status of the requests to filter for.
    #[prost(enumeration = "FulfillmentStatus", optional, tag = "2")]
    pub fulfillment_status: ::core::option::Option<i32>,
    /// The optional execution status of the requests to filter for.
    #[prost(enumeration = "ExecutionStatus", optional, tag = "3")]
    pub execution_status: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp deadline of the requests to filter for.
    /// Only returns requests with deadlines after this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub minimum_deadline: ::core::option::Option<u64>,
    /// The optional verification key hash of the program to filter for.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub vk_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional requester address to filter for.
    #[prost(bytes = "vec", optional, tag = "6")]
    pub requester: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional fulfiller address to filter for.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional minimum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "8")]
    pub from: ::core::option::Option<u64>,
    /// The optional maximum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "9")]
    pub to: ::core::option::Option<u64>,
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "10")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "11")]
    pub page: ::core::option::Option<u32>,
    /// The optional mode of the requests to filter for.
    #[prost(enumeration = "ProofMode", optional, tag = "12")]
    pub mode: ::core::option::Option<i32>,
    /// The optional bidder address to filter out. Only returns requests that
    /// have not been bid by this address.
    #[prost(bytes = "vec", optional, tag = "13")]
    pub not_bid_by: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional cause of execution failure.
    #[prost(enumeration = "ExecuteFailureCause", optional, tag = "14")]
    pub execute_fail_cause: ::core::option::Option<i32>,
    /// The optional settlement status of the requests to filter for.
    #[prost(enumeration = "SettlementStatus", optional, tag = "15")]
    pub settlement_status: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProofRequestsResponse {
    /// The requests that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<ProofRequest>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSearchResultsRequest {
    /// The search query string.
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResult {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSearchResultsResponse {
    /// List of matching request IDs with optional names.
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<SearchResult>,
    /// List of matching program IDs with optional names.
    #[prost(message, repeated, tag = "2")]
    pub programs: ::prost::alloc::vec::Vec<SearchResult>,
    /// List of matching requester IDs with optional names.
    #[prost(message, repeated, tag = "3")]
    pub requesters: ::prost::alloc::vec::Vec<SearchResult>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestMetricsRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional interval in days for volume calculation.
    #[prost(uint64, optional, tag = "2")]
    pub volume_interval_days: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetProofRequestMetricsResponse {
    /// The total number of proofs.
    #[prost(uint64, tag = "1")]
    pub total_proofs: u64,
    /// The total number of cycles.
    #[prost(uint64, tag = "2")]
    pub total_cycles: u64,
    /// The volume in the specified interval.
    #[prost(uint64, tag = "3")]
    pub volume: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestGraphRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional interval in days for the graph range.
    #[prost(uint64, optional, tag = "2")]
    pub range_interval_days: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphData {
    /// The timestamp of the data point.
    #[prost(string, tag = "1")]
    pub timestamp: ::prost::alloc::string::String,
    /// The value at this timestamp.
    #[prost(uint64, tag = "2")]
    pub value: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestGraphResponse {
    /// The time series data points.
    #[prost(message, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<GraphData>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnalyticsGraphsRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional interval in days for the graph range.
    #[prost(uint64, optional, tag = "2")]
    pub range_interval_days: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnalyticsGraphsResponse {
    /// The time series data points for proof count.
    #[prost(message, repeated, tag = "1")]
    pub proofs: ::prost::alloc::vec::Vec<GraphData>,
    /// The time series data points for program count.
    #[prost(message, repeated, tag = "2")]
    pub programs: ::prost::alloc::vec::Vec<GraphData>,
    /// The time series data points for cycle count.
    #[prost(message, repeated, tag = "3")]
    pub cycles: ::prost::alloc::vec::Vec<GraphData>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNonceRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetNonceResponse {
    /// The nonce of the account.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Delegation {
    /// The address of the owner.
    #[prost(bytes = "vec", tag = "1")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    /// The address of the delegate (the account with granted permissions).
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
    /// Whether the delegation has been accepted.
    #[prost(bool, tag = "3")]
    pub accepted: bool,
    /// The unix timestamp of when the delegation was created.
    #[prost(uint64, tag = "4")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredDelegationsRequest {
    /// The optional owner address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub owner: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "2")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "3")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredDelegationsResponse {
    /// The delegations that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub delegations: ::prost::alloc::vec::Vec<Delegation>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddDelegationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AddDelegationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddDelegationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The delegate address to add.
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddDelegationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AddDelegationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddDelegationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveDelegationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RemoveDelegationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveDelegationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The delegate address to remove.
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveDelegationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RemoveDelegationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveDelegationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminateDelegationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<TerminateDelegationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminateDelegationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the owner whose delegation to terminate.
    #[prost(bytes = "vec", tag = "2")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminateDelegationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<TerminateDelegationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TerminateDelegationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceptDelegationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AcceptDelegationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceptDelegationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the owner who requested the delegation
    #[prost(bytes = "vec", tag = "2")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceptDelegationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AcceptDelegationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AcceptDelegationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAccountNameRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetAccountNameRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAccountNameRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the account to update the name of. Only the sender can
    /// update the name unless authorized.
    #[prost(bytes = "vec", tag = "2")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The name of the account. Must be unique.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAccountNameResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetAccountNameResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetAccountNameResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountNameRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountNameResponse {
    /// The name of the account.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOwnerRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOwnerResponse {
    /// The owner of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTermsSignatureRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTermsSignatureResponse {
    /// Whether the account has signed the terms.
    #[prost(bool, tag = "1")]
    pub is_signed: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetTermsSignatureRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The message accepting the terms of service.
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetTermsSignatureResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Account {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The custom name of the account (optional).
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter handle of the account (optional).
    #[prost(string, optional, tag = "3")]
    pub twitter_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter name of the account (optional).
    #[prost(string, optional, tag = "4")]
    pub twitter_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter username of the account (optional).
    #[prost(string, optional, tag = "5")]
    pub twitter_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter image of the account (optional).
    #[prost(string, optional, tag = "6")]
    pub twitter_image: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether the account wants to use their twitter handle to set their name.
    #[prost(bool, tag = "7")]
    pub use_twitter_handle: bool,
    /// Whether the account wants to use their twitter image to set their image.
    #[prost(bool, tag = "8")]
    pub use_twitter_image: bool,
    /// The code of the account (optional).
    #[prost(string, optional, tag = "9")]
    pub code: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether the account has completed onboarding.
    #[prost(bool, tag = "10")]
    pub is_onboarded: bool,
    /// The version of the captcha game the account has completed.
    #[prost(int32, optional, tag = "11")]
    pub last_captcha_version: ::core::option::Option<i32>,
    /// The turbo high score of the account.
    #[prost(int32, optional, tag = "12")]
    pub turbo_high_score: ::core::option::Option<i32>,
    /// The version of the quiz game the account has completed.
    #[prost(int32, optional, tag = "13")]
    pub last_quiz_version: ::core::option::Option<i32>,
    /// The whitelist id of the account (optional).
    #[prost(int64, optional, tag = "14")]
    pub whitelist_id: ::core::option::Option<i64>,
    /// The social platform type from the whitelist (optional).
    #[prost(enumeration = "SocialPlatform", optional, tag = "15")]
    pub whitelist_social_platform: ::core::option::Option<i32>,
    /// The social handle from the whitelist (optional).
    #[prost(string, optional, tag = "16")]
    pub whitelist_social_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The social id from the whitelist (optional).
    #[prost(string, optional, tag = "17")]
    pub whitelist_social_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The social image from the whitelist (optional).
    #[prost(string, optional, tag = "18")]
    pub whitelist_social_image: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether the user completed whitelist social auth.
    #[prost(bool, optional, tag = "19")]
    pub whitelist_has_social_auth: ::core::option::Option<bool>,
    /// The gpu ID of the account (optional).
    #[prost(int64, optional, tag = "20")]
    pub gpu_id: ::core::option::Option<i64>,
    /// The gpu delegate address (optional).
    #[prost(bytes = "vec", optional, tag = "21")]
    pub gpu_delegate: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The gpu variant type (optional).
    #[prost(enumeration = "GpuVariant", optional, tag = "22")]
    pub gpu_variant: ::core::option::Option<i32>,
    /// The proving address of the account (optional). Only included if not delegating to Succinct's
    /// auction fulfiller.
    #[prost(bytes = "vec", optional, tag = "23")]
    pub proving_address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The 2048 high score of the account.
    #[prost(int32, optional, tag = "24")]
    pub high_score_2048: ::core::option::Option<i32>,
    /// The crab volleyball high score of the account.
    #[prost(int32, optional, tag = "25")]
    pub high_score_volleyball: ::core::option::Option<i32>,
    /// The coin craze high score of the account.
    #[prost(int32, optional, tag = "26")]
    pub high_score_coin_craze: ::core::option::Option<i32>,
    /// The turbo time trial high score of the account.
    #[prost(int32, optional, tag = "27")]
    pub high_score_turbo_trials: ::core::option::Option<i32>,
    /// The turbo time trial best rate of the account.
    #[prost(float, optional, tag = "28")]
    pub best_rate_turbo_trials: ::core::option::Option<f32>,
    /// The gpu coordinates (optional).
    #[prost(string, optional, tag = "29")]
    pub gpu_coordinates: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the gpu was created (optional).
    #[prost(uint64, optional, tag = "30")]
    pub gpu_created_at: ::core::option::Option<u64>,
    /// The lean high score of the account.
    #[prost(int32, optional, tag = "31")]
    pub high_score_lean: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountResponse {
    /// The account details.
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Account>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTeeWhitelistStatusRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTeeWhitelistStatusResponse {
    /// The whitelist status.
    #[prost(bool, tag = "1")]
    pub is_whitelisted: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Program {
    /// The verification key hash.
    #[prost(bytes = "vec", tag = "1")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The verification key.
    #[prost(bytes = "vec", tag = "2")]
    pub vk: ::prost::alloc::vec::Vec<u8>,
    /// The program resource identifier.
    #[prost(string, tag = "3")]
    pub program_uri: ::prost::alloc::string::String,
    /// The optional name of the program.
    #[prost(string, optional, tag = "4")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The owner of the program.
    #[prost(bytes = "vec", tag = "5")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    /// The unix timestamp of when the program was created.
    #[prost(uint64, tag = "6")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProgramRequest {
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "1")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProgramResponse {
    /// The program details.
    #[prost(message, optional, tag = "1")]
    pub program: ::core::option::Option<Program>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProgramRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<CreateProgramRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProgramRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The verification key hash.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The verification key.
    #[prost(bytes = "vec", tag = "3")]
    pub vk: ::prost::alloc::vec::Vec<u8>,
    /// The program resource identifier.
    #[prost(string, tag = "4")]
    pub program_uri: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProgramResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<CreateProgramResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateProgramResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetProgramNameRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetProgramNameRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetProgramNameRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier of the program to update the name of. Only the original
    /// program creator can update the name unless authorized.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The name of the program. Must be unique.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetProgramNameResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetProgramNameResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetProgramNameResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceResponse {
    /// The amount of credits owned by the account.
    #[prost(string, tag = "1")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BalanceLog {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The type of balance change operation.
    #[prost(enumeration = "BalanceOperation", tag = "2")]
    pub operation: i32,
    /// The amount of the change (can be positive or negative).
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    /// The transaction hash that caused this change.
    #[prost(bytes = "vec", tag = "4")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The unix timestamp of when this change occurred.
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBalanceLogsRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional type of operations to filter for.
    #[prost(enumeration = "BalanceOperation", optional, tag = "2")]
    pub operation: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp to filter logs from. Only returns
    /// logs after this timestamp.
    #[prost(uint64, optional, tag = "3")]
    pub minimum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum unix timestamp to filter logs to. Only returns
    /// logs before this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub maximum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum number of logs to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "5")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "6")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBalanceLogsResponse {
    /// The balance logs that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub logs: ::prost::alloc::vec::Vec<BalanceLog>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddCreditRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AddCreditRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddCreditRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the account to add credits to.
    #[prost(bytes = "vec", tag = "2")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The amount of credits to add.
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddCreditResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AddCreditResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddCreditResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLatestBridgeBlockRequest {
    /// The chain ID of the bridge.
    #[prost(uint32, tag = "1")]
    pub chain_id: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLatestBridgeBlockResponse {
    /// The latest processed block in the bridge.
    #[prost(uint64, tag = "1")]
    pub block_number: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGasPriceEstimateRequest {
    #[prost(enumeration = "FulfillmentStrategy", tag = "1")]
    pub strategy: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGasPriceEstimateResponse {
    #[prost(uint64, tag = "1")]
    pub gas_price: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionDetailsRequest {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionDetails {
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "4")]
    pub nonce: u64,
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
    #[prost(string, optional, tag = "6")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "7")]
    pub request_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionDetailsResponse {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<TransactionDetails>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddReservedChargeRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AddReservedChargeRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddReservedChargeRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The type of charge.
    #[prost(enumeration = "ChargeType", tag = "2")]
    pub charge_type: i32,
    /// The quantity of the charge.
    #[prost(string, tag = "3")]
    pub quantity: ::prost::alloc::string::String,
    /// The unix timestamp of the charge start time.
    #[prost(uint64, tag = "4")]
    pub start_time: u64,
    /// The unix timestamp of the charge end time.
    #[prost(uint64, tag = "5")]
    pub end_time: u64,
    /// The address of the fulfiller.
    #[prost(bytes = "vec", tag = "6")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddReservedChargeResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AddReservedChargeResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddReservedChargeResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChargeDetails {
    /// The identifier for the charge.
    #[prost(uint64, tag = "1")]
    pub charge_id: u64,
    /// The transaction hash of the charge.
    #[prost(bytes = "vec", tag = "2")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The type of charge.
    #[prost(enumeration = "ChargeType", tag = "3")]
    pub charge_type: i32,
    /// The quantity of the charge.
    #[prost(string, tag = "4")]
    pub quantity: ::prost::alloc::string::String,
    /// The effective price of the charge in USDC.
    #[prost(string, tag = "5")]
    pub effective_price: ::prost::alloc::string::String,
    /// Whether the charge is instant or not.
    #[prost(bool, tag = "6")]
    pub is_instant: bool,
    /// The address of the fulfiller the charge is associated with.
    #[prost(bytes = "vec", tag = "7")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The optional request ID associated with an instant charge.
    #[prost(bytes = "vec", optional, tag = "8")]
    pub request_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional unix timestamp of a non-instant charge start time.
    #[prost(uint64, optional, tag = "9")]
    pub start_time: ::core::option::Option<u64>,
    /// The optional unix timestamp of a non-instant charge end time.
    #[prost(uint64, optional, tag = "10")]
    pub end_time: ::core::option::Option<u64>,
    /// The unix timestamp of when the charge was created.
    #[prost(uint64, tag = "11")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChargeSummary {
    /// The type of charge.
    #[prost(enumeration = "ChargeType", tag = "1")]
    pub charge_type: i32,
    /// The total prorated amount.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterBillingSummary {
    /// The address of the fulfiller.
    #[prost(bytes = "vec", tag = "1")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "2")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The details of each active reserved charge.
    #[prost(message, repeated, tag = "3")]
    pub reserved_charges_details: ::prost::alloc::vec::Vec<ChargeDetails>,
    /// The summary of each reserved charge type associated with this fulfiller.
    #[prost(message, repeated, tag = "4")]
    pub reserved_charges: ::prost::alloc::vec::Vec<ChargeSummary>,
    /// The summary of each instant charge type associated with this fulfiller.
    #[prost(message, repeated, tag = "5")]
    pub instant_charges: ::prost::alloc::vec::Vec<ChargeSummary>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PayerBillingSummary {
    /// The month, formatted as "mm/yyyy".
    #[prost(string, tag = "1")]
    pub month: ::prost::alloc::string::String,
    /// The sum of all instant charges and prorated reserved charges for the month.
    #[prost(string, tag = "2")]
    pub total: ::prost::alloc::string::String,
    /// The clusters with a billing summary for the month.
    #[prost(message, repeated, tag = "3")]
    pub clusters: ::prost::alloc::vec::Vec<ClusterBillingSummary>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBillingSummaryRequest {
    /// The optional starting month to filter from (inclusive), formatted as "mm/yyyy".
    #[prost(string, optional, tag = "1")]
    pub from_month: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional ending month to filter to (inclusive), formatted as "mm/yyyy".
    #[prost(string, optional, tag = "2")]
    pub to_month: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional maximum number of months to return per page (default is 3, max is 10).
    #[prost(uint32, optional, tag = "3")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "4")]
    pub page: ::core::option::Option<u32>,
    /// The payer to filter for.
    #[prost(bytes = "vec", tag = "5")]
    pub payer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBillingSummaryResponse {
    /// A list summarizing charges by month and clusters for the specified payer.
    #[prost(message, repeated, tag = "1")]
    pub billing_summary: ::prost::alloc::vec::Vec<PayerBillingSummary>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Price {
    /// The address of the fulfiller the price is for.
    #[prost(bytes = "vec", tag = "1")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The type of charge the price is for.
    #[prost(enumeration = "ChargeType", tag = "2")]
    pub charge_type: i32,
    /// The price of the charge type in USDC.
    #[prost(string, tag = "3")]
    pub price: ::prost::alloc::string::String,
    /// Whether the price is the default price.
    #[prost(bool, tag = "4")]
    pub is_default: bool,
    /// The optional note associated with the price.
    #[prost(string, optional, tag = "5")]
    pub note: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the price was created.
    #[prost(uint64, tag = "6")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cluster {
    /// The address of the fulfiller.
    #[prost(bytes = "vec", tag = "1")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The address of the payer.
    #[prost(bytes = "vec", tag = "2")]
    pub payer: ::prost::alloc::vec::Vec<u8>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "3")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the payer address.
    #[prost(string, optional, tag = "4")]
    pub payer_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the fulfiller was created.
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
    /// The current prices for all charge types in this reservation.
    #[prost(message, repeated, tag = "6")]
    pub prices: ::prost::alloc::vec::Vec<Price>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredClustersRequest {
    /// The optional fulfiller address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional payer address to filter for.
    #[prost(bytes = "vec", optional, tag = "2")]
    pub payer: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional maximum number of clusters to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "3")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "4")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredClustersResponse {
    /// The clusters that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub clusters: ::prost::alloc::vec::Vec<Cluster>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePriceRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<UpdatePriceRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePriceRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the fulfiller the price is for.
    #[prost(bytes = "vec", tag = "2")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The type of charge to update the price for.
    #[prost(enumeration = "ChargeType", tag = "3")]
    pub charge_type: i32,
    /// The price to update to.
    #[prost(string, tag = "4")]
    pub price: ::prost::alloc::string::String,
    /// The optional note for the price.
    #[prost(string, optional, tag = "5")]
    pub note: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePriceResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<UpdatePriceResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdatePriceResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsageSummary {
    /// The total amount of gas (reserved + on-demand).
    #[prost(string, tag = "1")]
    pub total_gas: ::prost::alloc::string::String,
    /// The total amount of reserved gas.
    #[prost(string, tag = "2")]
    pub reserved_gas: ::prost::alloc::string::String,
    /// The total amount of on-demand gas.
    #[prost(string, tag = "3")]
    pub on_demand_gas: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterUsageSummary {
    /// The address of the fulfiller.
    #[prost(bytes = "vec", tag = "1")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "2")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The usage summary associated with this fulfiller.
    #[prost(message, optional, tag = "3")]
    pub usage_summary: ::core::option::Option<UsageSummary>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PayerUsageSummary {
    /// The month, formatted as "mm/yyyy".
    #[prost(string, tag = "1")]
    pub month: ::prost::alloc::string::String,
    /// The sum of all reserved and on-demand gas for the month.
    #[prost(string, tag = "2")]
    pub total_gas: ::prost::alloc::string::String,
    /// The sum of all reserved gas for the month.
    #[prost(string, tag = "3")]
    pub total_reserved_gas: ::prost::alloc::string::String,
    /// The sum of all on-demand gas for the month.
    #[prost(string, tag = "4")]
    pub total_on_demand_gas: ::prost::alloc::string::String,
    /// The clusters with a usage summary for the month.
    #[prost(message, repeated, tag = "5")]
    pub clusters: ::prost::alloc::vec::Vec<ClusterUsageSummary>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUsageSummaryRequest {
    /// The optional starting month to filter from (inclusive), formatted as "mm/yyyy".
    #[prost(string, optional, tag = "1")]
    pub from_month: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional ending month to filter to (inclusive), formatted as "mm/yyyy".
    #[prost(string, optional, tag = "2")]
    pub to_month: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional maximum number of months to return per page (default is 3, max is 12).
    #[prost(uint32, optional, tag = "3")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "4")]
    pub page: ::core::option::Option<u32>,
    /// The optional payer to filter for.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub payer: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUsageSummaryResponse {
    /// A list summarizing usage by month and clusters for the specified payer.
    #[prost(message, repeated, tag = "1")]
    pub usage_summary: ::prost::alloc::vec::Vec<PayerUsageSummary>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reservation {
    /// The address of the requester.
    #[prost(bytes = "vec", tag = "1")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
    /// The address of the fulfiller.
    #[prost(bytes = "vec", tag = "2")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The optional name to refer to an alias of the requester address.
    #[prost(string, optional, tag = "3")]
    pub requester_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "4")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the reservation was created.
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredReservationsRequest {
    /// Requester address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub requester: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional maximum number of reservations to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "2")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "3")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredReservationsResponse {
    /// The reservations that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub reservations: ::prost::alloc::vec::Vec<Reservation>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddReservationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AddReservationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddReservationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the requester to add reservation for.
    #[prost(bytes = "vec", tag = "2")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
    /// The address of the fulfiller to reserve.
    #[prost(bytes = "vec", tag = "3")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddReservationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AddReservationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddReservationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveReservationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RemoveReservationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveReservationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the requester to remove reservation for.
    #[prost(bytes = "vec", tag = "2")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveReservationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RemoveReservationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveReservationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<BidRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The request ID to bid on.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The amount to bid.
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<BidResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BidResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettleRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SettleRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettleRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The request ID to settle bids for.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettleResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SettleResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SettleResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Claims {
    /// The subject of the JWT.
    #[prost(bytes = "vec", tag = "1")]
    pub sub: ::prost::alloc::vec::Vec<u8>,
    /// The expiration time of the JWT.
    #[prost(uint64, tag = "2")]
    pub exp: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignInRequest {
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The SIWE message.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignInResponse {
    /// The JSON Web Token (JWT) to use for authentication.
    #[prost(string, tag = "1")]
    pub jwt: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetOnboardedAccountsCountRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetOnboardedAccountsCountResponse {
    /// The number of accounts that have been onboarded.
    #[prost(uint64, tag = "1")]
    pub count: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnboardedAccount {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The unix timestamp of when the account was onboarded.
    #[prost(uint64, tag = "2")]
    pub created_at: u64,
    /// The optional name of the account.
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional twitter handle of the account.
    #[prost(string, optional, tag = "4")]
    pub image: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional invite code referrer of the account.
    #[prost(string, optional, tag = "5")]
    pub referrer: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFilteredOnboardedAccountsRequest {
    /// The optional maximum number of entries to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredOnboardedAccountsResponse {
    /// The accounts that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub accounts: ::prost::alloc::vec::Vec<OnboardedAccount>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaderboardRow {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The rank of the account.
    #[prost(uint64, tag = "2")]
    pub rank: u64,
    /// The optional name of the account.
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional twitter handle of the account.
    #[prost(string, optional, tag = "4")]
    pub image: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional invite code referrer of the account.
    #[prost(string, optional, tag = "5")]
    pub referrer: ::core::option::Option<::prost::alloc::string::String>,
    /// The number of requests.
    #[prost(uint64, tag = "6")]
    pub requests: u64,
    /// The number of cycles.
    #[prost(uint64, tag = "7")]
    pub cycles: u64,
    /// The number of redeemed stars.
    #[prost(uint64, tag = "8")]
    pub redeemed_stars: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaderboardRowWithExtraStars {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The rank of the account.
    #[prost(uint64, tag = "2")]
    pub rank: u64,
    /// The optional name of the account.
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional twitter handle of the account.
    #[prost(string, optional, tag = "4")]
    pub image: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional invite code referrer of the account.
    #[prost(string, optional, tag = "5")]
    pub referrer: ::core::option::Option<::prost::alloc::string::String>,
    /// The number of requests.
    #[prost(uint64, tag = "6")]
    pub requests: u64,
    /// The number of cycles.
    #[prost(uint64, tag = "7")]
    pub cycles: u64,
    /// The number of redeemed stars.
    #[prost(uint64, tag = "8")]
    pub redeemed_stars: u64,
    /// The number of pending stars (total - redeemed).
    #[prost(uint64, tag = "9")]
    pub pending_stars: u64,
    /// The number of referral stars (already counted in pending stars / redeemed stars).
    #[prost(uint64, tag = "10")]
    pub referral_stars: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLeaderboardRequest {
    /// The optional maximum number of entries to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLeaderboardResponse {
    /// The leaderboard entries.
    #[prost(message, repeated, tag = "1")]
    pub leaderboard: ::prost::alloc::vec::Vec<LeaderboardRow>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLeaderboardStatsRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLeaderboardStatsResponse {
    /// The leaderboard stats for the account.
    #[prost(message, optional, tag = "1")]
    pub stats: ::core::option::Option<LeaderboardRowWithExtraStars>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReferralCode {
    /// The code.
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    /// The optional account's address that redeemed the code.
    #[prost(bytes = "vec", optional, tag = "2")]
    pub referred_account: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional account's name that redeemed the code.
    #[prost(string, optional, tag = "3")]
    pub referred_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional account's image that redeemed the code.
    #[prost(string, optional, tag = "4")]
    pub referred_image: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the code was created.
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCodesRequest {
    /// The account to get the codes for.
    #[prost(bytes = "vec", tag = "1")]
    pub account: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCodesResponse {
    /// The codes that the account has.
    #[prost(message, repeated, tag = "1")]
    pub codes: ::prost::alloc::vec::Vec<ReferralCode>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedeemCodeRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RedeemCodeRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedeemCodeRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The code to redeem.
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedeemCodeResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RedeemCodeResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RedeemCodeResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectTwitterRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<ConnectTwitterRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectTwitterRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The callback URI redirected to.
    #[prost(string, tag = "2")]
    pub callback_uri: ::prost::alloc::string::String,
    /// The code from Twitter.
    #[prost(string, tag = "3")]
    pub code: ::prost::alloc::string::String,
    /// The code verifier used in the initial Twitter request.
    #[prost(string, tag = "4")]
    pub code_verifier: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectTwitterResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<ConnectTwitterResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConnectTwitterResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteOnboardingRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<CompleteOnboardingRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CompleteOnboardingRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteOnboardingResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<CompleteOnboardingResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CompleteOnboardingResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUseTwitterHandleRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetUseTwitterHandleRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetUseTwitterHandleRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// Whether to display the Twitter handle.
    #[prost(bool, tag = "2")]
    pub should_display: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUseTwitterHandleResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetUseTwitterHandleResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetUseTwitterHandleResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUseTwitterImageRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetUseTwitterImageRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetUseTwitterImageRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// Whether to display the Twitter profile picture.
    #[prost(bool, tag = "2")]
    pub should_display: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUseTwitterImageResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetUseTwitterImageResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetUseTwitterImageResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestRandomProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RequestRandomProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestRandomProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestRandomProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RequestRandomProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestRandomProofResponseBody {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The name of the randomly selected program.
    #[prost(string, tag = "2")]
    pub program_name: ::prost::alloc::string::String,
    /// The number of bonus stars earned.
    #[prost(uint64, tag = "3")]
    pub stars: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitCaptchaGameRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SubmitCaptchaGameRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitCaptchaGameRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The list of integer answers for the captcha game.
    #[prost(int32, repeated, tag = "2")]
    pub fake_images: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitCaptchaGameResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SubmitCaptchaGameResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitCaptchaGameResponseBody {
    /// The number of correct answers submitted.
    #[prost(uint32, tag = "1")]
    pub correct_count: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedeemStarsRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RedeemStarsRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RedeemStarsRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedeemStarsResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RedeemStarsResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedeemStarsResponseBody {
    /// The base number of stars that were redeemed.
    #[prost(uint64, tag = "1")]
    pub base_stars: u64,
    /// The multiplier that was applied.
    #[prost(string, tag = "2")]
    pub multiplier: ::prost::alloc::string::String,
    /// The final number of stars after applying the multiplier.
    #[prost(uint64, tag = "3")]
    pub final_stars: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFlappyLeaderboardRequest {
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlappyBirdEntry {
    /// The unique ID of the proof request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The account that submitted the proof request.
    #[prost(bytes = "vec", tag = "2")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
    /// The number of cycles used.
    #[prost(uint64, tag = "3")]
    pub cycles: u64,
    /// The player's score.
    #[prost(uint64, tag = "4")]
    pub score: u64,
    /// The twitter username of the account.
    #[prost(string, optional, tag = "5")]
    pub twitter_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter image of the account.
    #[prost(string, optional, tag = "6")]
    pub twitter_image: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether the account wants to use their twitter handle to set their name.
    #[prost(bool, tag = "7")]
    pub use_twitter_handle: bool,
    /// Whether the account wants to use their twitter image to set their image.
    #[prost(bool, tag = "8")]
    pub use_twitter_image: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFlappyLeaderboardResponse {
    /// List of flappy bird leaderboard entries.
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<FlappyBirdEntry>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTurboHighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetTurboHighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetTurboHighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTurboHighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetTurboHighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetTurboHighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitQuizGameRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SubmitQuizGameRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitQuizGameRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The list of integer answers for the quiz game.
    #[prost(int32, repeated, tag = "2")]
    pub answers: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitQuizGameResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SubmitQuizGameResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitQuizGameResponseBody {
    /// The number of correct answers submitted.
    #[prost(uint32, tag = "1")]
    pub correct_count: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTurboLeaderboardRequest {
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TurboLeaderboardEntry {
    /// The account that submitted the proof request.
    #[prost(bytes = "vec", tag = "1")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
    /// The player's score.
    #[prost(uint64, tag = "2")]
    pub score: u64,
    /// The twitter username of the account.
    #[prost(string, optional, tag = "3")]
    pub twitter_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter image of the account.
    #[prost(string, optional, tag = "4")]
    pub twitter_image: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether the account wants to use their twitter handle to set their name.
    #[prost(bool, tag = "5")]
    pub use_twitter_handle: bool,
    /// Whether the account wants to use their twitter image to set their image.
    #[prost(bool, tag = "6")]
    pub use_twitter_image: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTurboLeaderboardResponse {
    /// List of turbo leaderboard entries.
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<TurboLeaderboardEntry>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitEthBlockMetadataRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SubmitEthBlockMetadataBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitEthBlockMetadataBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The request identifier for which this metadata is for.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The chain identifier.
    #[prost(uint32, tag = "3")]
    pub chain_id: u32,
    /// The block hash.
    #[prost(bytes = "vec", tag = "4")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    /// The block number.
    #[prost(uint64, tag = "5")]
    pub number: u64,
    /// The block timestamp.
    #[prost(uint64, tag = "6")]
    pub timestamp: u64,
    /// The block transaction count.
    #[prost(uint64, tag = "7")]
    pub tx_count: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitEthBlockMetadataResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SubmitEthBlockMetadataResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitEthBlockMetadataResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bid {
    /// The address of the bidder.
    #[prost(bytes = "vec", tag = "1")]
    pub bidder: ::prost::alloc::vec::Vec<u8>,
    /// The amount of the bid.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bet {
    /// The address of the bettor.
    #[prost(bytes = "vec", tag = "1")]
    pub bettor: ::prost::alloc::vec::Vec<u8>,
    /// The amount of the bet.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EthBlockRequest {
    /// The request identifier.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The version of the prover to use.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// The mode for the proof.
    #[prost(enumeration = "ProofMode", tag = "4")]
    pub mode: i32,
    /// The strategy for fulfiller assignment.
    #[prost(enumeration = "FulfillmentStrategy", tag = "5")]
    pub strategy: i32,
    /// The program resource identifier.
    #[prost(string, tag = "6")]
    pub program_uri: ::prost::alloc::string::String,
    /// The stdin resource identifier.
    #[prost(string, tag = "7")]
    pub stdin_uri: ::prost::alloc::string::String,
    /// The deadline for the request.
    #[prost(uint64, tag = "8")]
    pub deadline: u64,
    /// The cycle limit for the request.
    #[prost(uint64, tag = "9")]
    pub cycle_limit: u64,
    /// The gas price for the request.
    #[prost(uint64, optional, tag = "10")]
    pub gas_price: ::core::option::Option<u64>,
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "11")]
    pub fulfillment_status: i32,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "12")]
    pub execution_status: i32,
    /// The requester address that signed the request.
    #[prost(bytes = "vec", tag = "13")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
    /// The fulfiller address that fulfilled the request.
    #[prost(bytes = "vec", optional, tag = "14")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional name to refer to an alias of the program id.
    #[prost(string, optional, tag = "15")]
    pub program_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the requester address.
    #[prost(string, optional, tag = "16")]
    pub requester_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "17")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the request was created.
    #[prost(uint64, tag = "18")]
    pub created_at: u64,
    /// The unix timestamp of when the request was updated.
    #[prost(uint64, tag = "19")]
    pub updated_at: u64,
    /// The unix timestamp of when the request was fulfilled. Only included if
    /// the request has a fulfillment status of FULFILLED.
    #[prost(uint64, optional, tag = "20")]
    pub fulfilled_at: ::core::option::Option<u64>,
    /// The transaction hash of the request.
    #[prost(bytes = "vec", tag = "21")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The cycle used during the execution of the request. Only included if the
    /// request has an execution status of EXECUTED.
    #[prost(uint64, optional, tag = "22")]
    pub cycles: ::core::option::Option<u64>,
    /// The public values hash from the execution of the request. Only included if
    /// the request has an execution status of EXECUTED.
    #[prost(bytes = "vec", optional, tag = "23")]
    pub public_values_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The amount deducted from the fulfiller's balance. Only included if the
    /// request has a fulfillment status of ASSIGNED.
    #[prost(string, optional, tag = "24")]
    pub deduction_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// The amount refunded to the fulfiller's balance. Only included if the
    /// request has a fulfillment status of EXECUTED.
    #[prost(string, optional, tag = "25")]
    pub refund_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// The chain id of the request.
    #[prost(uint32, tag = "26")]
    pub chain_id: u32,
    /// The block hash of the request.
    #[prost(bytes = "vec", tag = "27")]
    pub block_hash: ::prost::alloc::vec::Vec<u8>,
    /// The block number of the request.
    #[prost(uint64, tag = "28")]
    pub block_number: u64,
    /// The block timestamp of the request.
    #[prost(uint64, tag = "29")]
    pub block_timestamp: u64,
    /// The block transaction count of the request.
    #[prost(uint64, tag = "30")]
    pub block_tx_count: u64,
    /// The bids for the request.
    #[prost(message, repeated, tag = "31")]
    pub bids: ::prost::alloc::vec::Vec<Bid>,
    /// When the auction was settled.
    #[prost(uint64, optional, tag = "32")]
    pub settled_at: ::core::option::Option<u64>,
    /// The fulfiller social platform.
    #[prost(enumeration = "SocialPlatform", optional, tag = "33")]
    pub fulfiller_social_platform: ::core::option::Option<i32>,
    /// The fulfiller social id.
    #[prost(string, optional, tag = "34")]
    pub fulfiller_social_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The fulfiller social handle.
    #[prost(string, optional, tag = "35")]
    pub fulfiller_social_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The fulfiller social image.
    #[prost(string, optional, tag = "36")]
    pub fulfiller_social_image: ::core::option::Option<::prost::alloc::string::String>,
    /// The bets for the request.
    #[prost(message, repeated, tag = "37")]
    pub bets: ::prost::alloc::vec::Vec<BettorDetails>,
    /// The public program resource identifier.
    #[prost(string, tag = "38")]
    pub program_public_uri: ::prost::alloc::string::String,
    /// The public stdin resource identifier.
    #[prost(string, tag = "39")]
    pub stdin_public_uri: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredEthBlockRequestsRequest {
    /// The optional version of the requests to filter for.
    #[prost(string, optional, tag = "1")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional fulfillment status of the requests to filter for.
    #[prost(enumeration = "FulfillmentStatus", optional, tag = "2")]
    pub fulfillment_status: ::core::option::Option<i32>,
    /// The optional execution status of the requests to filter for.
    #[prost(enumeration = "ExecutionStatus", optional, tag = "3")]
    pub execution_status: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp deadline of the requests to filter for.
    /// Only returns requests with deadlines after this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub minimum_deadline: ::core::option::Option<u64>,
    /// The optional verification key hash of the program to filter for.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub vk_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional requester address to filter for.
    #[prost(bytes = "vec", optional, tag = "6")]
    pub requester: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional fulfiller address to filter for.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional minimum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "8")]
    pub from: ::core::option::Option<u64>,
    /// The optional maximum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "9")]
    pub to: ::core::option::Option<u64>,
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "10")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "11")]
    pub page: ::core::option::Option<u32>,
    /// The optional mode of the requests to filter for.
    #[prost(enumeration = "ProofMode", optional, tag = "12")]
    pub mode: ::core::option::Option<i32>,
    /// The optional bidder address to filter out. Only returns requests that
    /// have not been bid by this address.
    #[prost(bytes = "vec", optional, tag = "13")]
    pub not_bid_by: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredEthBlockRequestsResponse {
    /// The list of filtered requests.
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<EthBlockRequest>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Set2048HighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<Set2048HighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Set2048HighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Set2048HighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<Set2048HighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Set2048HighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetVolleyballHighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetVolleyballHighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetVolleyballHighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
    /// The difficulty of the game.
    #[prost(enumeration = "VolleyballDifficulty", tag = "3")]
    pub difficulty: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetVolleyballHighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetVolleyballHighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetVolleyballHighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTurboTimeTrialHighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetTurboTimeTrialHighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetTurboTimeTrialHighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
    /// The best rate to set.
    #[prost(float, tag = "3")]
    pub best_rate: f32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTurboTimeTrialHighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetTurboTimeTrialHighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetTurboTimeTrialHighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetCoinCrazeHighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetCoinCrazeHighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetCoinCrazeHighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetCoinCrazeHighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetCoinCrazeHighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetCoinCrazeHighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLeanHighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetLeanHighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetLeanHighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLeanHighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetLeanHighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetLeanHighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetFlowHighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetFlowHighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetFlowHighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetFlowHighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetFlowHighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetFlowHighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRollupHighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetRollupHighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetRollupHighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
    /// The victory status for the game.
    #[prost(bool, tag = "3")]
    pub is_victory: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRollupHighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetRollupHighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetRollupHighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SocialIdentity {
    /// The social platform.
    #[prost(enumeration = "SocialPlatform", tag = "1")]
    pub platform: i32,
    /// The social handle to check.
    #[prost(string, tag = "2")]
    pub handle: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWhitelistStatusRequest {
    #[prost(oneof = "get_whitelist_status_request::Identifier", tags = "1, 2")]
    pub identifier: ::core::option::Option<get_whitelist_status_request::Identifier>,
}
/// Nested message and enum types in `GetWhitelistStatusRequest`.
pub mod get_whitelist_status_request {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Identifier {
        /// The ethereum address to check.
        #[prost(bytes, tag = "1")]
        Address(::prost::alloc::vec::Vec<u8>),
        /// The social identity to check.
        #[prost(message, tag = "2")]
        SocialIdentity(super::SocialIdentity),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetWhitelistStatusResponse {
    /// Whether the user is whitelisted.
    #[prost(bool, tag = "1")]
    pub is_whitelisted: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGpuDelegateRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetGpuDelegateRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGpuDelegateRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The ethereum address to delegate to.
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGpuDelegateResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetGpuDelegateResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetGpuDelegateResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimGpuRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<ClaimGpuRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimGpuRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The ethereum address to delegate to.
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
    /// The gpu variant.
    #[prost(enumeration = "GpuVariant", tag = "3")]
    pub variant: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimGpuResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<ClaimGpuResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClaimGpuResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGpuVariantRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetGpuVariantRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetGpuVariantRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The gpu variant.
    #[prost(enumeration = "GpuVariant", tag = "2")]
    pub variant: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGpuVariantResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetGpuVariantResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetGpuVariantResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedTwitterRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<LinkWhitelistedTwitterRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedTwitterRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The callback URI redirected to.
    #[prost(string, tag = "2")]
    pub callback_uri: ::prost::alloc::string::String,
    /// The code from Twitter.
    #[prost(string, tag = "3")]
    pub code: ::prost::alloc::string::String,
    /// The code verifier used in the initial Twitter request.
    #[prost(string, tag = "4")]
    pub code_verifier: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedTwitterResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<LinkWhitelistedTwitterResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedTwitterResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveProvingKeyRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RetrieveProvingKeyRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RetrieveProvingKeyRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveProvingKeyResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RetrieveProvingKeyResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveProvingKeyResponseBody {
    /// The proving key.
    #[prost(bytes = "vec", tag = "1")]
    pub proving_key: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedGithubRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<LinkWhitelistedGithubRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedGithubRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The callback URI redirected to.
    #[prost(string, tag = "2")]
    pub callback_uri: ::prost::alloc::string::String,
    /// The code from GitHub.
    #[prost(string, tag = "3")]
    pub code: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedGithubResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<LinkWhitelistedGithubResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedGithubResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedDiscordRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<LinkWhitelistedDiscordRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedDiscordRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The callback URI redirected to.
    #[prost(string, tag = "2")]
    pub callback_uri: ::prost::alloc::string::String,
    /// The code from Discord.
    #[prost(string, tag = "3")]
    pub code: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedDiscordResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<LinkWhitelistedDiscordResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedDiscordResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProverEntry {
    /// The social platform.
    #[prost(enumeration = "SocialPlatform", optional, tag = "1")]
    pub social_platform: ::core::option::Option<i32>,
    /// The social handle.
    #[prost(string, optional, tag = "2")]
    pub social_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The social id.
    #[prost(string, optional, tag = "3")]
    pub social_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The social image.
    #[prost(string, optional, tag = "4")]
    pub social_image: ::core::option::Option<::prost::alloc::string::String>,
    /// The gpu variant.
    #[prost(enumeration = "GpuVariant", tag = "5")]
    pub gpu_variant: i32,
    /// The ethereum address of the gpu owner;
    #[prost(bytes = "vec", tag = "6")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    /// The ethereum address of the gpu delegate;
    #[prost(bytes = "vec", tag = "7")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
    /// The total number of proofs.
    #[prost(uint64, tag = "8")]
    pub total_proofs: u64,
    /// The total number of cycles.
    #[prost(uint64, tag = "9")]
    pub total_cycles: u64,
    /// The optional gpu coordinates.
    #[prost(string, optional, tag = "10")]
    pub gpu_coordinates: ::core::option::Option<::prost::alloc::string::String>,
    /// The total number of points;
    #[prost(uint64, tag = "11")]
    pub total_points: u64,
    /// The total number of stars.
    #[prost(uint64, tag = "12")]
    pub total_stars: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEthBlockRequestMetricsRequest {
    /// The optional version of the requests to filter for.
    #[prost(string, optional, tag = "1")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional verification key hash of the program to filter for.
    #[prost(bytes = "vec", optional, tag = "2")]
    pub vk_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional execution status of the requests to filter for.
    #[prost(enumeration = "ExecutionStatus", optional, tag = "3")]
    pub execution_status: ::core::option::Option<i32>,
    /// The optional fulfillment status of the requests to filter for.
    #[prost(enumeration = "FulfillmentStatus", optional, tag = "4")]
    pub fulfillment_status: ::core::option::Option<i32>,
    /// The optional requester address to filter for.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub requester: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional fulfiller address to filter for.
    #[prost(bytes = "vec", optional, tag = "6")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional mode of the requests to filter for.
    #[prost(enumeration = "ProofMode", optional, tag = "7")]
    pub mode: ::core::option::Option<i32>,
    /// The optional minimum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "8")]
    pub from: ::core::option::Option<u64>,
    /// The optional maximum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "9")]
    pub to: ::core::option::Option<u64>,
    /// The optional bidder address to filter out. Only returns requests that
    /// have not been bid by this address.
    #[prost(bytes = "vec", optional, tag = "10")]
    pub not_bid_by: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetEthBlockRequestMetricsResponse {
    /// The total number of requests.
    #[prost(uint64, tag = "1")]
    pub total_requests: u64,
    /// The total number of cycles.
    #[prost(uint64, tag = "2")]
    pub total_cycles: u64,
    /// The total number of bids.
    #[prost(uint64, tag = "3")]
    pub total_bids: u64,
    /// The total number of bets.
    #[prost(uint64, tag = "4")]
    pub total_bets: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetProverLeaderboardRequest {
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
    /// The optional gpu variant to filter by.
    #[prost(enumeration = "GpuVariant", optional, tag = "3")]
    pub gpu_variant: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverLeaderboardResponse {
    /// List of prover leaderboard entries.
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<ProverEntry>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Gpu {
    /// The address of the gpu owner.
    #[prost(bytes = "vec", tag = "1")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    /// The address of the gpu delegate.
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
    /// The gpu variant.
    #[prost(enumeration = "GpuVariant", tag = "3")]
    pub gpu_variant: i32,
    /// The unix timestamp of when the gpu was created.
    #[prost(uint64, tag = "4")]
    pub created_at: u64,
    /// The optional social platform of the gpu owner.
    #[prost(enumeration = "SocialPlatform", optional, tag = "5")]
    pub social_platform: ::core::option::Option<i32>,
    /// The optional social handle of the gpu owner.
    #[prost(string, optional, tag = "6")]
    pub social_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional social id of the gpu owner.
    #[prost(string, optional, tag = "7")]
    pub social_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The social image of the gpu owner.
    #[prost(string, optional, tag = "8")]
    pub social_image: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFilteredGpusRequest {
    /// The optional maximum number of entries to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredGpusResponse {
    /// The gpus that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub gpus: ::prost::alloc::vec::Vec<Gpu>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGpuCoordinatesRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetGpuCoordinatesRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGpuCoordinatesRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The gpu longitude coordinate.
    #[prost(string, tag = "2")]
    pub longitude: ::prost::alloc::string::String,
    /// The gpu latitude coordinate.
    #[prost(string, tag = "3")]
    pub latitude: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGpuCoordinatesResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetGpuCoordinatesResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetGpuCoordinatesResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeDetails {
    /// The type of upgrade.
    #[prost(enumeration = "Upgrade", tag = "1")]
    pub upgrade: i32,
    /// The amount of times the upgrade has been purchased.
    #[prost(uint32, tag = "2")]
    pub count: u32,
    /// The base cost of the upgrade.
    #[prost(string, tag = "3")]
    pub base_cost: ::prost::alloc::string::String,
    /// The cost to purchase the next upgrade level.
    #[prost(string, tag = "4")]
    pub next_level_cost: ::prost::alloc::string::String,
    /// The upgrade amount;
    #[prost(string, tag = "5")]
    pub amount: ::prost::alloc::string::String,
    /// The max level allowed for the upgrade.
    #[prost(uint32, tag = "6")]
    pub max_level: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPointsRequest {
    /// The address of the account to get points for.
    #[prost(bytes = "vec", tag = "1")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPointsResponse {
    /// The amount of points owned by the account.
    #[prost(string, tag = "2")]
    pub points_from_rate: ::prost::alloc::string::String,
    /// The amount of points owned by the account.
    #[prost(string, tag = "3")]
    pub total_points: ::prost::alloc::string::String,
    /// The owner's current earn rate.
    #[prost(string, tag = "4")]
    pub earn_rate: ::prost::alloc::string::String,
    /// The owner's current click value.
    #[prost(string, tag = "5")]
    pub click_value: ::prost::alloc::string::String,
    /// The owner's maximum clicks allowed per period.
    #[prost(uint32, tag = "6")]
    pub max_clicks_per_period: u32,
    /// The owner's amount of clicks in the current period.
    #[prost(uint32, tag = "7")]
    pub clicks_current_period: u32,
    /// The unix timestamp of when click period resets.
    #[prost(uint64, tag = "8")]
    pub clicks_reset_date: u64,
    /// The unix timestamp of the last time clicks were processed.
    #[prost(uint64, tag = "9")]
    pub last_click_date: u64,
    /// Whether the owner is in overclocked state for the current period.
    #[prost(bool, tag = "10")]
    pub overclocked: bool,
    /// Detailed information about each upgrade.
    #[prost(message, repeated, tag = "11")]
    pub upgrades: ::prost::alloc::vec::Vec<UpgradeDetails>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessClicksRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<ProcessClicksRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProcessClicksRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The number of clicks to process.
    #[prost(uint32, tag = "2")]
    pub clicks: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessClicksResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<ProcessClicksResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProcessClicksResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurchaseUpgradeRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<PurchaseUpgradeRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PurchaseUpgradeRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The upgrade to purchase.
    #[prost(enumeration = "Upgrade", tag = "2")]
    pub upgrade: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurchaseUpgradeResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<PurchaseUpgradeResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PurchaseUpgradeResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BetRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<BetRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BetRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The amount to bet.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "3")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BetResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<BetResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BetResponseBody {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BettorDetails {
    /// The address of the bettor.
    #[prost(bytes = "vec", tag = "1")]
    pub bettor: ::prost::alloc::vec::Vec<u8>,
    /// The amount of the bet.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
    /// The probability of the bettor winning.
    #[prost(string, tag = "3")]
    pub probability: ::prost::alloc::string::String,
    /// The optional social platform of the bettor.
    #[prost(enumeration = "SocialPlatform", optional, tag = "4")]
    pub social_platform: ::core::option::Option<i32>,
    /// The optional social handle of the bettor.
    #[prost(string, optional, tag = "5")]
    pub social_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional social id of the bettor.
    #[prost(string, optional, tag = "6")]
    pub social_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The social image of the bettor.
    #[prost(string, optional, tag = "7")]
    pub social_image: ::core::option::Option<::prost::alloc::string::String>,
    /// The gpu variant of the bettor.
    #[prost(enumeration = "GpuVariant", optional, tag = "8")]
    pub gpu_variant: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetContestDetailsRequest {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetContestDetailsResponse {
    /// The block number of the request.
    #[prost(uint64, tag = "1")]
    pub block_number: u64,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "2")]
    pub execution_status: i32,
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "3")]
    pub fulfillment_status: i32,
    /// The credits reward amount.
    #[prost(string, tag = "4")]
    pub credits_reward: ::prost::alloc::string::String,
    /// The points reward amount.
    #[prost(string, tag = "5")]
    pub points_reward: ::prost::alloc::string::String,
    /// Detailed information about the winner.
    #[prost(message, optional, tag = "6")]
    pub winner: ::core::option::Option<BettorDetails>,
    /// Detailed information about each loser.
    #[prost(message, repeated, tag = "11")]
    pub losers: ::prost::alloc::vec::Vec<BettorDetails>,
    /// The stars reward amount.
    #[prost(string, tag = "12")]
    pub stars_reward: ::prost::alloc::string::String,
    /// The base stars amount.
    #[prost(string, tag = "13")]
    pub base_stars: ::prost::alloc::string::String,
    /// The multiplier amount.
    #[prost(string, tag = "14")]
    pub multiplier: ::prost::alloc::string::String,
    /// The total amount of bets in the contest.
    #[prost(string, tag = "15")]
    pub total_bets: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContestRequestDetails {
    /// The latest contest id.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub request_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The latest contest creation time.
    #[prost(uint64, optional, tag = "2")]
    pub created_at: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLatestContestRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLatestContestResponse {
    /// The latest contest id.
    #[prost(message, optional, tag = "1")]
    pub new_contest: ::core::option::Option<ContestRequestDetails>,
    /// The current contest id.
    #[prost(message, optional, tag = "2")]
    pub current_contest: ::core::option::Option<ContestRequestDetails>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetContestBettorsRequest {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetContestBettorsResponse {
    /// The bettors.
    #[prost(message, repeated, tag = "1")]
    pub bettors: ::prost::alloc::vec::Vec<BettorDetails>,
    /// The total pool of the contest.
    #[prost(string, tag = "2")]
    pub total_pool: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGpuMetricsRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGpuMetricsResponse {
    /// The total number of gpus.
    #[prost(uint32, tag = "1")]
    pub total_gpus: u32,
    /// The total number of proofs by gpus.
    #[prost(uint32, tag = "2")]
    pub total_proofs: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProverActivity {
    /// The request id.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "2")]
    pub fulfillment_status: i32,
    /// The fulfiller address.
    #[prost(bytes = "vec", tag = "3")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The optional social platform of the fulfiller.
    #[prost(enumeration = "SocialPlatform", optional, tag = "4")]
    pub fulfiller_social_platform: ::core::option::Option<i32>,
    /// The optional social handle of the fulfiller.
    #[prost(string, optional, tag = "5")]
    pub fulfiller_social_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional social id of the fulfiller.
    #[prost(string, optional, tag = "6")]
    pub fulfiller_social_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The social image of the fulfiller.
    #[prost(string, optional, tag = "7")]
    pub fulfiller_social_image: ::core::option::Option<::prost::alloc::string::String>,
    /// The creation time of the request.
    #[prost(uint64, optional, tag = "8")]
    pub created_at: ::core::option::Option<u64>,
    /// The total number of bets placed for this proof.
    #[prost(uint64, tag = "9")]
    pub total_bets: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProverActivityRequest {
    /// The limit for the number of results.
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The page for the results.
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
    /// The optional address to filter by.
    #[prost(bytes = "vec", optional, tag = "3")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProverActivityResponse {
    /// The prover activity.
    #[prost(message, repeated, tag = "1")]
    pub prover_activity: ::prost::alloc::vec::Vec<ProverActivity>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverMetricsRequest {
    /// The address to filter by.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverMetricsResponse {
    /// The total number of proofs.
    #[prost(uint32, tag = "1")]
    pub total_proofs: u32,
    /// Number of contests participated in.
    #[prost(uint32, tag = "2")]
    pub total_contests: u32,
    /// Stars earned.
    #[prost(string, tag = "3")]
    pub stars_earned: ::prost::alloc::string::String,
    /// Average multiplier.
    #[prost(string, tag = "4")]
    pub average_multiplier: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BetHistory {
    /// The request id.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// Points bet.
    #[prost(string, tag = "2")]
    pub points_bet: ::prost::alloc::string::String,
    /// Stars pool.
    #[prost(string, tag = "3")]
    pub star_pool: ::prost::alloc::string::String,
    /// Multiplier.
    #[prost(string, tag = "4")]
    pub multiplier: ::prost::alloc::string::String,
    /// Probability.
    #[prost(string, tag = "5")]
    pub probability: ::prost::alloc::string::String,
    /// Stars reward.
    #[prost(string, tag = "6")]
    pub star_reward: ::prost::alloc::string::String,
    /// The winner.
    #[prost(message, optional, tag = "7")]
    pub winner: ::core::option::Option<BettorDetails>,
    /// The creation time of the bet.
    #[prost(uint64, tag = "8")]
    pub created_at: u64,
    /// The total number of bettors.
    #[prost(uint32, tag = "9")]
    pub total_bettors: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBetHistoryRequest {
    /// The address to filter by.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The limit for the number of results.
    #[prost(uint32, optional, tag = "2")]
    pub limit: ::core::option::Option<u32>,
    /// The page for the results.
    #[prost(uint32, optional, tag = "3")]
    pub page: ::core::option::Option<u32>,
    /// Filter by victory.
    #[prost(bool, optional, tag = "4")]
    pub is_victory: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBetHistoryResponse {
    /// The bet history.
    #[prost(message, repeated, tag = "1")]
    pub bets: ::prost::alloc::vec::Vec<BetHistory>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuTeamStats {
    /// The gpu variant.
    #[prost(enumeration = "GpuVariant", tag = "1")]
    pub gpu_variant: i32,
    /// The total number of gpus.
    #[prost(uint32, tag = "2")]
    pub total_gpus: u32,
    /// The total number of proofs.
    #[prost(uint32, tag = "3")]
    pub total_proofs: u32,
    /// The total number of contests.
    #[prost(uint32, tag = "4")]
    pub total_contests: u32,
    /// The total number of stars won by the gpu team.
    #[prost(string, tag = "5")]
    pub total_stars_won: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGpuTeamStatsRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGpuTeamStatsResponse {
    /// List of gpu team stats.
    #[prost(message, repeated, tag = "1")]
    pub gpu_team_stats: ::prost::alloc::vec::Vec<GpuTeamStats>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverStatsRequest {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetProverStatsResponse {
    #[prost(uint64, tag = "1")]
    pub total_earnings: u64,
    #[prost(uint64, tag = "2")]
    pub total_cycles: u64,
    #[prost(uint64, tag = "3")]
    pub total_gas_proved: u64,
    #[prost(uint64, tag = "4")]
    pub active_provers: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProverStats {
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub twitter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, tag = "4")]
    pub use_twitter_handle: bool,
    #[prost(uint64, tag = "5")]
    pub total_auction_requests: u64,
    #[prost(uint64, tag = "6")]
    pub successful_requests: u64,
    #[prost(uint64, tag = "7")]
    pub total_gas_proved: u64,
    #[prost(uint64, tag = "8")]
    pub last_active_at: u64,
    #[prost(uint64, tag = "9")]
    pub created_at: u64,
    #[prost(uint64, tag = "10")]
    pub total_earnings: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFilteredProverStatsRequest {
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProverStatsResponse {
    #[prost(message, repeated, tag = "1")]
    pub stats: ::prost::alloc::vec::Vec<ProverStats>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverSearchResultsRequest {
    /// The query to search for.
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverSearchResultsResponse {
    #[prost(message, repeated, tag = "1")]
    pub provers: ::prost::alloc::vec::Vec<SearchResult>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidHistory {
    /// The bidder.
    #[prost(bytes = "vec", tag = "1")]
    pub bidder: ::prost::alloc::vec::Vec<u8>,
    /// The amount bid.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
    /// The creation time of the bid.
    #[prost(uint64, tag = "3")]
    pub created_at: u64,
    /// The bidder name.
    #[prost(string, optional, tag = "4")]
    pub bidder_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBidHistoryRequest {
    /// The request id to filter by.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The limit for the number of results.
    #[prost(uint32, optional, tag = "2")]
    pub limit: ::core::option::Option<u32>,
    /// The page for the results.
    #[prost(uint32, optional, tag = "3")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBidHistoryResponse {
    #[prost(message, repeated, tag = "1")]
    pub bids: ::prost::alloc::vec::Vec<BidHistory>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedMessage {
    /// The message.
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    /// The signature.
    #[prost(string, tag = "2")]
    pub signature: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettlementRequest {
    /// The RequestProofRequest signed message.
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<SignedMessage>,
    /// The BidRequest signed message.
    #[prost(message, optional, tag = "2")]
    pub bid: ::core::option::Option<SignedMessage>,
    /// The SettleRequest signed message.
    #[prost(message, optional, tag = "3")]
    pub settle: ::core::option::Option<SignedMessage>,
    /// The ExecuteProofRequest signed message.
    #[prost(message, optional, tag = "4")]
    pub execute: ::core::option::Option<SignedMessage>,
    /// The FulfillProofRequest signed message.
    #[prost(message, optional, tag = "5")]
    pub fulfill: ::core::option::Option<SignedMessage>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSettlementRequestRequest {
    /// The request ID to get signed messages for.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSettlementRequestResponse {
    /// The settlement request.
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<SettlementRequest>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredSettlementRequestsRequest {
    /// The list of request IDs to get signed messages for.
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub request_ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredSettlementRequestsResponse {
    /// The list of signed messages.
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<SettlementRequest>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Prover {
    /// The address of the prover.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The owner of the prover.
    #[prost(bytes = "vec", tag = "2")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    /// The name of the prover.
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The block number of the prover was created in.
    #[prost(uint64, tag = "4")]
    pub block_number: u64,
    /// The transaction hash of the prover was created in.
    #[prost(bytes = "vec", tag = "5")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFilteredProversRequest {
    /// The optional maximum number of provers to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProversResponse {
    #[prost(message, repeated, tag = "1")]
    pub provers: ::prost::alloc::vec::Vec<Prover>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStakerStakeBalanceRequest {
    /// The account to get the stake balance for. This can be a prover or the owner of the prover.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStakerStakeBalanceResponse {
    /// The stake balance.
    #[prost(string, tag = "1")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverStakeBalanceRequest {
    /// The address of the prover.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProverStakeBalanceResponse {
    /// The stake balance.
    #[prost(string, tag = "1")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StakeBalanceLog {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The type of balance change operation.
    #[prost(enumeration = "StakeBalanceOperation", tag = "2")]
    pub operation: i32,
    /// The amount of the change (can be positive or negative).
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    /// The transaction hash that caused this change.
    #[prost(bytes = "vec", tag = "4")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The unix timestamp of when this change occurred.
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredStakerStakeBalanceLogsRequest {
    /// The optional staker address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional type of operations to filter for.
    #[prost(enumeration = "StakeBalanceOperation", optional, tag = "2")]
    pub operation: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp to filter logs from. Only returns
    /// logs after this timestamp.
    #[prost(uint64, optional, tag = "3")]
    pub minimum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum unix timestamp to filter logs to. Only returns
    /// logs before this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub maximum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum number of logs to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "5")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "6")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredStakerStakeBalanceLogsResponse {
    /// The staker balance logs.
    #[prost(message, repeated, tag = "1")]
    pub logs: ::prost::alloc::vec::Vec<StakeBalanceLog>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProverStakeBalanceLogsRequest {
    /// The optional prover address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional type of operations to filter for.
    #[prost(enumeration = "StakeBalanceOperation", optional, tag = "2")]
    pub operation: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp to filter logs from. Only returns
    /// logs after this timestamp.
    #[prost(uint64, optional, tag = "3")]
    pub minimum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum unix timestamp to filter logs to. Only returns
    /// logs before this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub maximum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum number of logs to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "5")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "6")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProverStakeBalanceLogsResponse {
    /// The prover balance logs.
    #[prost(message, repeated, tag = "1")]
    pub logs: ::prost::alloc::vec::Vec<StakeBalanceLog>,
}
/// Format to help decode signature in backend.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MessageFormat {
    /// Unspecified message format.
    UnspecifiedMessageFormat = 0,
    /// The message is in binary format.
    Binary = 1,
    /// The message is in JSON format.
    Json = 2,
}
impl MessageFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedMessageFormat => "UNSPECIFIED_MESSAGE_FORMAT",
            Self::Binary => "BINARY",
            Self::Json => "JSON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_MESSAGE_FORMAT" => Some(Self::UnspecifiedMessageFormat),
            "BINARY" => Some(Self::Binary),
            "JSON" => Some(Self::Json),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VolleyballDifficulty {
    Easy = 0,
    Medium = 1,
    Hard = 2,
    Troll = 3,
}
impl VolleyballDifficulty {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Easy => "EASY",
            Self::Medium => "MEDIUM",
            Self::Hard => "HARD",
            Self::Troll => "TROLL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EASY" => Some(Self::Easy),
            "MEDIUM" => Some(Self::Medium),
            "HARD" => Some(Self::Hard),
            "TROLL" => Some(Self::Troll),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProofMode {
    UnspecifiedProofMode = 0,
    /// The core proof mode.
    Core = 1,
    /// The compressed proof mode.
    Compressed = 2,
    /// The plonk proof mode.
    Plonk = 3,
    /// The groth16 proof mode.
    Groth16 = 4,
}
impl ProofMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedProofMode => "UNSPECIFIED_PROOF_MODE",
            Self::Core => "CORE",
            Self::Compressed => "COMPRESSED",
            Self::Plonk => "PLONK",
            Self::Groth16 => "GROTH16",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_PROOF_MODE" => Some(Self::UnspecifiedProofMode),
            "CORE" => Some(Self::Core),
            "COMPRESSED" => Some(Self::Compressed),
            "PLONK" => Some(Self::Plonk),
            "GROTH16" => Some(Self::Groth16),
            _ => None,
        }
    }
}
/// The different strategies that can be used for fulfilling requests.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FulfillmentStrategy {
    UnspecifiedFulfillmentStrategy = 0,
    /// The hosted fulfillment strategy. Uses Succinct's on-demand prover to fulfill requests.
    Hosted = 1,
    /// The reserved fulfillment strategy. Uses an already existing agreement with a
    /// fulfiller to fulfill requests.
    Reserved = 2,
    /// The auction fulfillment strategy. Uses a decentralized proof contest to
    /// fulfill requests.
    Auction = 3,
}
impl FulfillmentStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedFulfillmentStrategy => "UNSPECIFIED_FULFILLMENT_STRATEGY",
            Self::Hosted => "HOSTED",
            Self::Reserved => "RESERVED",
            Self::Auction => "AUCTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_FULFILLMENT_STRATEGY" => {
                Some(Self::UnspecifiedFulfillmentStrategy)
            }
            "HOSTED" => Some(Self::Hosted),
            "RESERVED" => Some(Self::Reserved),
            "AUCTION" => Some(Self::Auction),
            _ => None,
        }
    }
}
/// The different fulfillment statuses that a request can be in.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FulfillmentStatus {
    UnspecifiedFulfillmentStatus = 0,
    /// The request has been requested.
    Requested = 1,
    /// The request has been assigned to a fulfiller.
    Assigned = 2,
    /// The request has been fulfilled.
    Fulfilled = 3,
    /// The request cannot be fulfilled.
    Unfulfillable = 4,
}
impl FulfillmentStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedFulfillmentStatus => "UNSPECIFIED_FULFILLMENT_STATUS",
            Self::Requested => "REQUESTED",
            Self::Assigned => "ASSIGNED",
            Self::Fulfilled => "FULFILLED",
            Self::Unfulfillable => "UNFULFILLABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_FULFILLMENT_STATUS" => Some(Self::UnspecifiedFulfillmentStatus),
            "REQUESTED" => Some(Self::Requested),
            "ASSIGNED" => Some(Self::Assigned),
            "FULFILLED" => Some(Self::Fulfilled),
            "UNFULFILLABLE" => Some(Self::Unfulfillable),
            _ => None,
        }
    }
}
/// The different execution statuses that a request can be in.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecutionStatus {
    UnspecifiedExecutionStatus = 0,
    /// The request has not been executed.
    Unexecuted = 1,
    /// The request has been executed.
    Executed = 2,
    /// The request cannot be executed.
    Unexecutable = 3,
}
impl ExecutionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedExecutionStatus => "UNSPECIFIED_EXECUTION_STATUS",
            Self::Unexecuted => "UNEXECUTED",
            Self::Executed => "EXECUTED",
            Self::Unexecutable => "UNEXECUTABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_EXECUTION_STATUS" => Some(Self::UnspecifiedExecutionStatus),
            "UNEXECUTED" => Some(Self::Unexecuted),
            "EXECUTED" => Some(Self::Executed),
            "UNEXECUTABLE" => Some(Self::Unexecutable),
            _ => None,
        }
    }
}
/// The different settlement statuses that a request can be in.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SettlementStatus {
    UnspecifiedSettlementStatus = 0,
    /// The request has not been settled.
    Unsettled = 1,
    /// The request has been settled.
    Settled = 2,
}
impl SettlementStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedSettlementStatus => "UNSPECIFIED_SETTLEMENT_STATUS",
            Self::Unsettled => "UNSETTLED",
            Self::Settled => "SETTLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_SETTLEMENT_STATUS" => Some(Self::UnspecifiedSettlementStatus),
            "UNSETTLED" => Some(Self::Unsettled),
            "SETTLED" => Some(Self::Settled),
            _ => None,
        }
    }
}
/// The different types of balance changes that can occur for credits.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BalanceOperation {
    UnspecifiedBalanceChangeOperation = 0,
    /// A deposit operation (positive).
    Deposit = 1,
    /// A withdrawal operation (negative).
    Withdrawal = 2,
    /// A credit operation (positive).
    Credit = 3,
    /// A deduction operation (negative).
    Deduction = 4,
    /// A refund operation (positive).
    Refund = 5,
}
impl BalanceOperation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedBalanceChangeOperation => {
                "UNSPECIFIED_BALANCE_CHANGE_OPERATION"
            }
            Self::Deposit => "DEPOSIT",
            Self::Withdrawal => "WITHDRAWAL",
            Self::Credit => "CREDIT",
            Self::Deduction => "DEDUCTION",
            Self::Refund => "REFUND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_BALANCE_CHANGE_OPERATION" => {
                Some(Self::UnspecifiedBalanceChangeOperation)
            }
            "DEPOSIT" => Some(Self::Deposit),
            "WITHDRAWAL" => Some(Self::Withdrawal),
            "CREDIT" => Some(Self::Credit),
            "DEDUCTION" => Some(Self::Deduction),
            "REFUND" => Some(Self::Refund),
            _ => None,
        }
    }
}
/// The different types of balance changes that can occur for stake.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StakeBalanceOperation {
    UnspecifiedStakeBalanceOperation = 0,
    /// A stake operation (positive).
    Stake = 1,
    /// An unstake operation (negative).
    Unstake = 2,
    /// A slash operation (negative).
    Slash = 3,
    /// A bid operation (negative).
    Bid = 4,
}
impl StakeBalanceOperation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedStakeBalanceOperation => {
                "UNSPECIFIED_STAKE_BALANCE_OPERATION"
            }
            Self::Stake => "STAKE",
            Self::Unstake => "UNSTAKE",
            Self::Slash => "SLASH",
            Self::Bid => "BID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_STAKE_BALANCE_OPERATION" => {
                Some(Self::UnspecifiedStakeBalanceOperation)
            }
            "STAKE" => Some(Self::Stake),
            "UNSTAKE" => Some(Self::Unstake),
            "SLASH" => Some(Self::Slash),
            "BID" => Some(Self::Bid),
            _ => None,
        }
    }
}
/// The different social platforms.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SocialPlatform {
    UnspecifiedPlatform = 0,
    /// The twitter platform.
    Twitter = 1,
    /// The github platform.
    Github = 2,
    /// The discord platform.
    Discord = 3,
}
impl SocialPlatform {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedPlatform => "UNSPECIFIED_PLATFORM",
            Self::Twitter => "TWITTER",
            Self::Github => "GITHUB",
            Self::Discord => "DISCORD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_PLATFORM" => Some(Self::UnspecifiedPlatform),
            "TWITTER" => Some(Self::Twitter),
            "GITHUB" => Some(Self::Github),
            "DISCORD" => Some(Self::Discord),
            _ => None,
        }
    }
}
/// The different gpu variants.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GpuVariant {
    UnspecifiedVariant = 0,
    /// The blueberry variant.
    Blueberry = 1,
    /// The strawberry variant.
    Strawberry = 2,
    /// The lime variant.
    Lime = 3,
    /// The tangerine variant.
    Tangerine = 4,
    /// The grape variant.
    Grape = 5,
}
impl GpuVariant {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedVariant => "UNSPECIFIED_VARIANT",
            Self::Blueberry => "BLUEBERRY",
            Self::Strawberry => "STRAWBERRY",
            Self::Lime => "LIME",
            Self::Tangerine => "TANGERINE",
            Self::Grape => "GRAPE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_VARIANT" => Some(Self::UnspecifiedVariant),
            "BLUEBERRY" => Some(Self::Blueberry),
            "STRAWBERRY" => Some(Self::Strawberry),
            "LIME" => Some(Self::Lime),
            "TANGERINE" => Some(Self::Tangerine),
            "GRAPE" => Some(Self::Grape),
            _ => None,
        }
    }
}
/// The different upgrades that can be purchased with points.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Upgrade {
    UnspecifiedUpgrade = 0,
    /// The earn rate boost upgrade.
    EarnRateBoost = 1,
    /// The click worth boost upgrade.
    ClickValueBoost = 2,
    /// The clicks per period boost upgrade.
    ClicksPerPeriodBoost = 3,
}
impl Upgrade {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedUpgrade => "UNSPECIFIED_UPGRADE",
            Self::EarnRateBoost => "EARN_RATE_BOOST",
            Self::ClickValueBoost => "CLICK_VALUE_BOOST",
            Self::ClicksPerPeriodBoost => "CLICKS_PER_PERIOD_BOOST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_UPGRADE" => Some(Self::UnspecifiedUpgrade),
            "EARN_RATE_BOOST" => Some(Self::EarnRateBoost),
            "CLICK_VALUE_BOOST" => Some(Self::ClickValueBoost),
            "CLICKS_PER_PERIOD_BOOST" => Some(Self::ClicksPerPeriodBoost),
            _ => None,
        }
    }
}
/// The different causes for execution failure.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecuteFailureCause {
    UnspecifiedExecutionFailureCause = 0,
    /// The execution failed with a non-zero exit code.
    HaltWithNonZeroExitCode = 1,
    /// The execution failed with an invalid memory access.
    InvalidMemoryAccess = 2,
    /// The execution failed with an unimplemented syscall.
    UnsupportedSyscall = 3,
    /// The execution failed with a breakpoint.
    Breakpoint = 4,
    /// The execution failed with an exceeded cycle limit.
    ExceededCycleLimit = 5,
    /// The execution failed because the syscall was called in unconstrained mode.
    InvalidSyscallUsage = 6,
    /// The execution failed with an unimplemented feature.
    Unimplemented = 7,
    /// The program ended in unconstrained mode.
    EndInUnconstrained = 8,
}
impl ExecuteFailureCause {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedExecutionFailureCause => {
                "UNSPECIFIED_EXECUTION_FAILURE_CAUSE"
            }
            Self::HaltWithNonZeroExitCode => "HALT_WITH_NON_ZERO_EXIT_CODE",
            Self::InvalidMemoryAccess => "INVALID_MEMORY_ACCESS",
            Self::UnsupportedSyscall => "UNSUPPORTED_SYSCALL",
            Self::Breakpoint => "BREAKPOINT",
            Self::ExceededCycleLimit => "EXCEEDED_CYCLE_LIMIT",
            Self::InvalidSyscallUsage => "INVALID_SYSCALL_USAGE",
            Self::Unimplemented => "UNIMPLEMENTED",
            Self::EndInUnconstrained => "END_IN_UNCONSTRAINED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_EXECUTION_FAILURE_CAUSE" => {
                Some(Self::UnspecifiedExecutionFailureCause)
            }
            "HALT_WITH_NON_ZERO_EXIT_CODE" => Some(Self::HaltWithNonZeroExitCode),
            "INVALID_MEMORY_ACCESS" => Some(Self::InvalidMemoryAccess),
            "UNSUPPORTED_SYSCALL" => Some(Self::UnsupportedSyscall),
            "BREAKPOINT" => Some(Self::Breakpoint),
            "EXCEEDED_CYCLE_LIMIT" => Some(Self::ExceededCycleLimit),
            "INVALID_SYSCALL_USAGE" => Some(Self::InvalidSyscallUsage),
            "UNIMPLEMENTED" => Some(Self::Unimplemented),
            "END_IN_UNCONSTRAINED" => Some(Self::EndInUnconstrained),
            _ => None,
        }
    }
}
/// The different types of charges for reserved billing.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChargeType {
    UnspecifiedChargeType = 0,
    /// For base reserved cluster usage.
    BaseCluster = 1,
    /// For reserved GPU throughput.
    ProvisionedMgasPerSec = 2,
    /// For usage exceeding reserved.
    ExcessGas = 3,
    /// For groth16 proofs.
    Groth16Proof = 4,
    /// For plonk proofs.
    PlonkProof = 5,
}
impl ChargeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedChargeType => "UNSPECIFIED_CHARGE_TYPE",
            Self::BaseCluster => "BASE_CLUSTER",
            Self::ProvisionedMgasPerSec => "PROVISIONED_MGAS_PER_SEC",
            Self::ExcessGas => "EXCESS_GAS",
            Self::Groth16Proof => "GROTH16_PROOF",
            Self::PlonkProof => "PLONK_PROOF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_CHARGE_TYPE" => Some(Self::UnspecifiedChargeType),
            "BASE_CLUSTER" => Some(Self::BaseCluster),
            "PROVISIONED_MGAS_PER_SEC" => Some(Self::ProvisionedMgasPerSec),
            "EXCESS_GAS" => Some(Self::ExcessGas),
            "GROTH16_PROOF" => Some(Self::Groth16Proof),
            "PLONK_PROOF" => Some(Self::PlonkProof),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod prover_network_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct ProverNetworkClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ProverNetworkClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ProverNetworkClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ProverNetworkClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ProverNetworkClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a proof request.
        pub async fn request_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::RequestProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RequestProofResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/RequestProof",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RequestProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Fulfills a proof request. Only callable by the assigned fulfiller.
        pub async fn fulfill_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::FulfillProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FulfillProofResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/FulfillProof",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "FulfillProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Executes a proof request. Only callable by the execution oracle.
        pub async fn execute_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecuteProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecuteProofResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/ExecuteProof",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "ExecuteProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Fails fulfillment. Only callable by the assigned fulfiller.
        pub async fn fail_fulfillment(
            &mut self,
            request: impl tonic::IntoRequest<super::FailFulfillmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FailFulfillmentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/FailFulfillment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "FailFulfillment"));
            self.inner.unary(req, path, codec).await
        }
        /// Fails execution. Only callable by the execution oracle.
        pub async fn fail_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::FailExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FailExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/FailExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "FailExecution"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the status of a proof request.
        pub async fn get_proof_request_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProofRequestStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProofRequestStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProofRequestStatus"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the details of a proof request.
        pub async fn get_proof_request_details(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProofRequestDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProofRequestDetailsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProofRequestDetails"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the proof requests that meet the filter criteria.
        pub async fn get_filtered_proof_requests(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredProofRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredProofRequestsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProofRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredProofRequests"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Subscribe to proof requests that meet the filter criteria.
        pub async fn subscribe_proof_requests(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredProofRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ProofRequest>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SubscribeProofRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "SubscribeProofRequests"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Search for proof requests, programs, and requesters.
        pub async fn get_search_results(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSearchResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSearchResultsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetSearchResults",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetSearchResults"));
            self.inner.unary(req, path, codec).await
        }
        /// Get metrics for proof requests.
        pub async fn get_proof_request_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProofRequestMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProofRequestMetricsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProofRequestMetrics"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get time series data for proof requests.
        pub async fn get_proof_request_graph(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProofRequestGraphRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProofRequestGraphResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestGraph",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProofRequestGraph"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get analytics graphs for proof requests.
        pub async fn get_analytics_graphs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAnalyticsGraphsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAnalyticsGraphsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetAnalyticsGraphs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetAnalyticsGraphs"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the nonce of the account.
        pub async fn get_nonce(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNonceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetNonceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetNonce",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetNonce"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the delegations of the account.
        pub async fn get_filtered_delegations(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredDelegationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredDelegationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredDelegations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredDelegations"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Add a delegation. Only callable by the owner of an account.
        pub async fn add_delegation(
            &mut self,
            request: impl tonic::IntoRequest<super::AddDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddDelegationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/AddDelegation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "AddDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Remove a delegation. Only callable by the owner of an account.
        pub async fn remove_delegation(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveDelegationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/RemoveDelegation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RemoveDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Terminate a delegation. Only callable by the delegate of a delegation.
        pub async fn terminate_delegation(
            &mut self,
            request: impl tonic::IntoRequest<super::TerminateDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TerminateDelegationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/TerminateDelegation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "TerminateDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Accept a delegation. Only callable by the delegate of a delegation.
        pub async fn accept_delegation(
            &mut self,
            request: impl tonic::IntoRequest<super::AcceptDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AcceptDelegationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/AcceptDelegation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "AcceptDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the name of the account. Only callable by the owner of an account.
        pub async fn set_account_name(
            &mut self,
            request: impl tonic::IntoRequest<super::SetAccountNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetAccountNameResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetAccountName",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetAccountName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the name of the account.
        pub async fn get_account_name(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAccountNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAccountNameResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetAccountName",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetAccountName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get whether the account has signed the terms.
        pub async fn get_terms_signature(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTermsSignatureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTermsSignatureResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetTermsSignature",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetTermsSignature"));
            self.inner.unary(req, path, codec).await
        }
        /// Set whether the account has signed the terms.
        pub async fn set_terms_signature(
            &mut self,
            request: impl tonic::IntoRequest<super::SetTermsSignatureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetTermsSignatureResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetTermsSignature",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetTermsSignature"));
            self.inner.unary(req, path, codec).await
        }
        /// Get all the information about an account.
        pub async fn get_account(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetAccount"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the owner of an account. Returns itself if the account is not delegated.
        pub async fn get_owner(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOwnerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetOwnerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetOwner",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetOwner"));
            self.inner.unary(req, path, codec).await
        }
        /// Get metadata about a program.
        pub async fn get_program(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProgramResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProgram",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProgram"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new program. Must be called before requesting proofs.
        pub async fn create_program(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateProgramResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/CreateProgram",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "CreateProgram"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the name of the program. Only callable by the owner.
        pub async fn set_program_name(
            &mut self,
            request: impl tonic::IntoRequest<super::SetProgramNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetProgramNameResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetProgramName",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetProgramName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the available balance of an account.
        pub async fn get_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBalanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetBalance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetBalance"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the balance logs that meet the filter criteria.
        pub async fn get_filtered_balance_logs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredBalanceLogsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredBalanceLogsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredBalanceLogs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredBalanceLogs"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Add credit to an account.
        pub async fn add_credit(
            &mut self,
            request: impl tonic::IntoRequest<super::AddCreditRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddCreditResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/AddCredit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "AddCredit"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the latest processed block in the bridge.
        pub async fn get_latest_bridge_block(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLatestBridgeBlockRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetLatestBridgeBlockResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetLatestBridgeBlock",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetLatestBridgeBlock"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the gas price estimate for a given fulfillment strategy.
        pub async fn get_gas_price_estimate(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGasPriceEstimateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetGasPriceEstimateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetGasPriceEstimate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetGasPriceEstimate"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the details of a transaction.
        pub async fn get_transaction_details(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTransactionDetailsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetTransactionDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetTransactionDetails"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Add a charge to an account.
        pub async fn add_reserved_charge(
            &mut self,
            request: impl tonic::IntoRequest<super::AddReservedChargeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddReservedChargeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/AddReservedCharge",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "AddReservedCharge"));
            self.inner.unary(req, path, codec).await
        }
        /// Get prorated billing summary by month for a specified payer.
        pub async fn get_billing_summary(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBillingSummaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBillingSummaryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetBillingSummary",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetBillingSummary"));
            self.inner.unary(req, path, codec).await
        }
        /// Update the charge type price for a reservation.
        pub async fn update_price(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePriceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdatePriceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/UpdatePrice",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "UpdatePrice"));
            self.inner.unary(req, path, codec).await
        }
        /// Get filtered and paginated clusters/fulfillers with prices.
        pub async fn get_filtered_clusters(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredClustersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredClustersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredClusters",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredClusters"));
            self.inner.unary(req, path, codec).await
        }
        /// Get usage summary by month for a specified payer.
        pub async fn get_usage_summary(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUsageSummaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetUsageSummaryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetUsageSummary",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetUsageSummary"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the reservations that meet the filter criteria.
        pub async fn get_filtered_reservations(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredReservationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredReservationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredReservations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredReservations"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Add a reservation for a requester.
        pub async fn add_reservation(
            &mut self,
            request: impl tonic::IntoRequest<super::AddReservationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddReservationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/AddReservation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "AddReservation"));
            self.inner.unary(req, path, codec).await
        }
        /// Remove a reservation for a requester.
        pub async fn remove_reservation(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveReservationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveReservationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/RemoveReservation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RemoveReservation"));
            self.inner.unary(req, path, codec).await
        }
        /// Bid for a proof request. Provers that want to be assigned this request must first
        /// bid on it.
        pub async fn bid(
            &mut self,
            request: impl tonic::IntoRequest<super::BidRequest>,
        ) -> std::result::Result<tonic::Response<super::BidResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/Bid",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "Bid"));
            self.inner.unary(req, path, codec).await
        }
        /// Settle the bids on a proof request to choose the assigned prover. Only callable by
        /// the approved auctioneer.
        pub async fn settle(
            &mut self,
            request: impl tonic::IntoRequest<super::SettleRequest>,
        ) -> std::result::Result<tonic::Response<super::SettleResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/Settle",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "Settle"));
            self.inner.unary(req, path, codec).await
        }
        /// Sign in with Ethereum
        pub async fn sign_in(
            &mut self,
            request: impl tonic::IntoRequest<super::SignInRequest>,
        ) -> std::result::Result<tonic::Response<super::SignInResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SignIn",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SignIn"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the accounts that meet the filter criteria.
        pub async fn get_onboarded_accounts_count(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOnboardedAccountsCountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetOnboardedAccountsCountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetOnboardedAccountsCount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetOnboardedAccountsCount"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the accounts that have joined the leaderboard.
        pub async fn get_filtered_onboarded_accounts(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredOnboardedAccountsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredOnboardedAccountsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredOnboardedAccounts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "GetFilteredOnboardedAccounts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the leaderboard.
        pub async fn get_leaderboard(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetLeaderboardResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetLeaderboard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetLeaderboard"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the leaderboard stats for a given account.
        pub async fn get_leaderboard_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLeaderboardStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetLeaderboardStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetLeaderboardStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetLeaderboardStats"));
            self.inner.unary(req, path, codec).await
        }
        /// Get codes.
        pub async fn get_codes(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCodesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCodesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetCodes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetCodes"));
            self.inner.unary(req, path, codec).await
        }
        /// Redeem a code.
        pub async fn redeem_code(
            &mut self,
            request: impl tonic::IntoRequest<super::RedeemCodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RedeemCodeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/RedeemCode",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RedeemCode"));
            self.inner.unary(req, path, codec).await
        }
        /// Connect a Twitter account.
        pub async fn connect_twitter(
            &mut self,
            request: impl tonic::IntoRequest<super::ConnectTwitterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConnectTwitterResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/ConnectTwitter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "ConnectTwitter"));
            self.inner.unary(req, path, codec).await
        }
        /// Complete onboarding.
        pub async fn complete_onboarding(
            &mut self,
            request: impl tonic::IntoRequest<super::CompleteOnboardingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CompleteOnboardingResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/CompleteOnboarding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "CompleteOnboarding"));
            self.inner.unary(req, path, codec).await
        }
        /// Set if a user should display their Twitter handle.
        pub async fn set_use_twitter_handle(
            &mut self,
            request: impl tonic::IntoRequest<super::SetUseTwitterHandleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetUseTwitterHandleResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetUseTwitterHandle",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetUseTwitterHandle"));
            self.inner.unary(req, path, codec).await
        }
        /// Set if a user should display their Twitter profile picture.
        pub async fn set_use_twitter_image(
            &mut self,
            request: impl tonic::IntoRequest<super::SetUseTwitterImageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetUseTwitterImageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetUseTwitterImage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetUseTwitterImage"));
            self.inner.unary(req, path, codec).await
        }
        /// Request a random proof.
        pub async fn request_random_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::RequestRandomProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RequestRandomProofResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/RequestRandomProof",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RequestRandomProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit answers for the captcha game.
        pub async fn submit_captcha_game(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitCaptchaGameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitCaptchaGameResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SubmitCaptchaGame",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SubmitCaptchaGame"));
            self.inner.unary(req, path, codec).await
        }
        /// Redeem stars.
        pub async fn redeem_stars(
            &mut self,
            request: impl tonic::IntoRequest<super::RedeemStarsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RedeemStarsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/RedeemStars",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RedeemStars"));
            self.inner.unary(req, path, codec).await
        }
        /// Get flappy leaderboard.
        pub async fn get_flappy_leaderboard(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFlappyLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFlappyLeaderboardResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFlappyLeaderboard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFlappyLeaderboard"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set the turbo game high score.
        pub async fn set_turbo_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::SetTurboHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetTurboHighScoreResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetTurboHighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetTurboHighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit answers for the quiz game.
        pub async fn submit_quiz_game(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitQuizGameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitQuizGameResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SubmitQuizGame",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SubmitQuizGame"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the turbo game leaderboard.
        pub async fn get_turbo_leaderboard(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTurboLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTurboLeaderboardResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetTurboLeaderboard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetTurboLeaderboard"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit ETH block metadata.
        pub async fn submit_eth_block_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitEthBlockMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitEthBlockMetadataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SubmitEthBlockMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "SubmitEthBlockMetadata"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get ETH block requests that meet the filter criteria.
        pub async fn get_filtered_eth_block_requests(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredEthBlockRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredEthBlockRequestsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredEthBlockRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "GetFilteredEthBlockRequests",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set the 2048 game high score.
        pub async fn set2048_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::Set2048HighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::Set2048HighScoreResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/Set2048HighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "Set2048HighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the volleyball game high score.
        pub async fn set_volleyball_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::SetVolleyballHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetVolleyballHighScoreResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetVolleyballHighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "SetVolleyballHighScore"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get ETH block proof requests metrics.
        pub async fn get_eth_block_request_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEthBlockRequestMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetEthBlockRequestMetricsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetEthBlockRequestMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetEthBlockRequestMetrics"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set the turbo time trial high score.
        pub async fn set_turbo_time_trial_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::SetTurboTimeTrialHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetTurboTimeTrialHighScoreResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetTurboTimeTrialHighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "SetTurboTimeTrialHighScore",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set the coin craze high score.
        pub async fn set_coin_craze_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::SetCoinCrazeHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetCoinCrazeHighScoreResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetCoinCrazeHighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "SetCoinCrazeHighScore"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set the lean high score.
        pub async fn set_lean_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLeanHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetLeanHighScoreResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetLeanHighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetLeanHighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the flow high score.
        pub async fn set_flow_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::SetFlowHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetFlowHighScoreResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetFlowHighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetFlowHighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the rollup high score.
        pub async fn set_rollup_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRollupHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRollupHighScoreResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetRollupHighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetRollupHighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Check if address or social identity is whitelisted.
        pub async fn get_whitelist_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetWhitelistStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetWhitelistStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetWhitelistStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetWhitelistStatus"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the gpu delegate.
        pub async fn set_gpu_delegate(
            &mut self,
            request: impl tonic::IntoRequest<super::SetGpuDelegateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetGpuDelegateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetGpuDelegate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetGpuDelegate"));
            self.inner.unary(req, path, codec).await
        }
        /// Claim a gpu.
        pub async fn claim_gpu(
            &mut self,
            request: impl tonic::IntoRequest<super::ClaimGpuRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ClaimGpuResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/ClaimGpu",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "ClaimGpu"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the gpu variant.
        pub async fn set_gpu_variant(
            &mut self,
            request: impl tonic::IntoRequest<super::SetGpuVariantRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetGpuVariantResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetGpuVariant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetGpuVariant"));
            self.inner.unary(req, path, codec).await
        }
        /// Link a whitelisted twitter account.
        pub async fn link_whitelisted_twitter(
            &mut self,
            request: impl tonic::IntoRequest<super::LinkWhitelistedTwitterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LinkWhitelistedTwitterResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/LinkWhitelistedTwitter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "LinkWhitelistedTwitter"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve the proving key for your account. Must have claimed a gpu and self-delegated to
        /// yourself.
        pub async fn retrieve_proving_key(
            &mut self,
            request: impl tonic::IntoRequest<super::RetrieveProvingKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RetrieveProvingKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/RetrieveProvingKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RetrieveProvingKey"));
            self.inner.unary(req, path, codec).await
        }
        /// Link a whitelisted github account.
        pub async fn link_whitelisted_github(
            &mut self,
            request: impl tonic::IntoRequest<super::LinkWhitelistedGithubRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LinkWhitelistedGithubResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/LinkWhitelistedGithub",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "LinkWhitelistedGithub"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Link a whitelisted discord account.
        pub async fn link_whitelisted_discord(
            &mut self,
            request: impl tonic::IntoRequest<super::LinkWhitelistedDiscordRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LinkWhitelistedDiscordResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/LinkWhitelistedDiscord",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "LinkWhitelistedDiscord"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get prover leaderboard.
        pub async fn get_prover_leaderboard(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProverLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProverLeaderboardResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProverLeaderboard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProverLeaderboard"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get filtered gpus.
        pub async fn get_filtered_gpus(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredGpusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredGpusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredGpus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredGpus"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the gpu coordinates.
        pub async fn set_gpu_coordinates(
            &mut self,
            request: impl tonic::IntoRequest<super::SetGpuCoordinatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetGpuCoordinatesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetGpuCoordinates",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetGpuCoordinates"));
            self.inner.unary(req, path, codec).await
        }
        /// Get points.
        pub async fn get_points(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPointsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetPointsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetPoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetPoints"));
            self.inner.unary(req, path, codec).await
        }
        /// Process clicks.
        pub async fn process_clicks(
            &mut self,
            request: impl tonic::IntoRequest<super::ProcessClicksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ProcessClicksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/ProcessClicks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "ProcessClicks"));
            self.inner.unary(req, path, codec).await
        }
        /// Purchase upgrade.
        pub async fn purchase_upgrade(
            &mut self,
            request: impl tonic::IntoRequest<super::PurchaseUpgradeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PurchaseUpgradeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/PurchaseUpgrade",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "PurchaseUpgrade"));
            self.inner.unary(req, path, codec).await
        }
        /// Place a bet.
        pub async fn bet(
            &mut self,
            request: impl tonic::IntoRequest<super::BetRequest>,
        ) -> std::result::Result<tonic::Response<super::BetResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/Bet",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "Bet"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the status of a proof contest.
        pub async fn get_contest_details(
            &mut self,
            request: impl tonic::IntoRequest<super::GetContestDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetContestDetailsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetContestDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetContestDetails"));
            self.inner.unary(req, path, codec).await
        }
        /// Get latest contest id.
        pub async fn get_latest_contest(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLatestContestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetLatestContestResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetLatestContest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetLatestContest"));
            self.inner.unary(req, path, codec).await
        }
        /// Get contest bettors.
        pub async fn get_contest_bettors(
            &mut self,
            request: impl tonic::IntoRequest<super::GetContestBettorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetContestBettorsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetContestBettors",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetContestBettors"));
            self.inner.unary(req, path, codec).await
        }
        /// Get gpu metrics.
        pub async fn get_gpu_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGpuMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetGpuMetricsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetGpuMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetGpuMetrics"));
            self.inner.unary(req, path, codec).await
        }
        /// Get filtered prover activity.
        pub async fn get_filtered_prover_activity(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredProverActivityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredProverActivityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProverActivity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredProverActivity"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get prover metrics.
        pub async fn get_prover_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProverMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProverMetricsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProverMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProverMetrics"));
            self.inner.unary(req, path, codec).await
        }
        /// Get filtered bet history.
        pub async fn get_filtered_bet_history(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredBetHistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredBetHistoryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredBetHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredBetHistory"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get gpu team stats.
        pub async fn get_gpu_team_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGpuTeamStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetGpuTeamStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetGpuTeamStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetGpuTeamStats"));
            self.inner.unary(req, path, codec).await
        }
        /// Get metrics for a specific prover
        pub async fn get_prover_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProverStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProverStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProverStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProverStats"));
            self.inner.unary(req, path, codec).await
        }
        /// Get statistics for all provers with pagination
        pub async fn get_filtered_prover_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredProverStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredProverStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProverStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredProverStats"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get search results for provers
        pub async fn get_prover_search_results(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProverSearchResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProverSearchResultsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProverSearchResults",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProverSearchResults"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get paginated auction history
        pub async fn get_filtered_bid_history(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredBidHistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredBidHistoryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredBidHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetFilteredBidHistory"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Check if the user is whitelisted to use the TEE service.
        pub async fn get_tee_whitelist_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTeeWhitelistStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTeeWhitelistStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetTEEWhitelistStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetTEEWhitelistStatus"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        /// Settlement
        ///
        /// These methods are for settling orders to L1.
        pub async fn get_settlement_request(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSettlementRequestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSettlementRequestResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetSettlementRequest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetSettlementRequest"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_filtered_settlement_requests(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredSettlementRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredSettlementRequestsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredSettlementRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "GetFilteredSettlementRequests",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the provers that meet the filter criteria.
        pub async fn get_filtered_provers(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredProversRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredProversResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProvers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredProvers"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the available balance of a staker.
        pub async fn get_staker_stake_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStakerStakeBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetStakerStakeBalanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetStakerStakeBalance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetStakerStakeBalance"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the available balance of a prover.
        pub async fn get_prover_stake_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProverStakeBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProverStakeBalanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProverStakeBalance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("network.ProverNetwork", "GetProverStakeBalance"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the staker balance logs that meet the filter criteria.
        pub async fn get_filtered_staker_stake_balance_logs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetFilteredStakerStakeBalanceLogsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredStakerStakeBalanceLogsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredStakerStakeBalanceLogs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "GetFilteredStakerStakeBalanceLogs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the prover balance logs that meet the filter criteria.
        pub async fn get_filtered_prover_stake_balance_logs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetFilteredProverStakeBalanceLogsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredProverStakeBalanceLogsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProverStakeBalanceLogs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "network.ProverNetwork",
                        "GetFilteredProverStakeBalanceLogs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod prover_network_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ProverNetworkServer.
    #[async_trait]
    pub trait ProverNetwork: std::marker::Send + std::marker::Sync + 'static {
        /// Creates a proof request.
        async fn request_proof(
            &self,
            request: tonic::Request<super::RequestProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RequestProofResponse>,
            tonic::Status,
        >;
        /// Fulfills a proof request. Only callable by the assigned fulfiller.
        async fn fulfill_proof(
            &self,
            request: tonic::Request<super::FulfillProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FulfillProofResponse>,
            tonic::Status,
        >;
        /// Executes a proof request. Only callable by the execution oracle.
        async fn execute_proof(
            &self,
            request: tonic::Request<super::ExecuteProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecuteProofResponse>,
            tonic::Status,
        >;
        /// Fails fulfillment. Only callable by the assigned fulfiller.
        async fn fail_fulfillment(
            &self,
            request: tonic::Request<super::FailFulfillmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FailFulfillmentResponse>,
            tonic::Status,
        >;
        /// Fails execution. Only callable by the execution oracle.
        async fn fail_execution(
            &self,
            request: tonic::Request<super::FailExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FailExecutionResponse>,
            tonic::Status,
        >;
        /// Get the status of a proof request.
        async fn get_proof_request_status(
            &self,
            request: tonic::Request<super::GetProofRequestStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProofRequestStatusResponse>,
            tonic::Status,
        >;
        /// Get the details of a proof request.
        async fn get_proof_request_details(
            &self,
            request: tonic::Request<super::GetProofRequestDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProofRequestDetailsResponse>,
            tonic::Status,
        >;
        /// Get the proof requests that meet the filter criteria.
        async fn get_filtered_proof_requests(
            &self,
            request: tonic::Request<super::GetFilteredProofRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredProofRequestsResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the SubscribeProofRequests method.
        type SubscribeProofRequestsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ProofRequest, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to proof requests that meet the filter criteria.
        async fn subscribe_proof_requests(
            &self,
            request: tonic::Request<super::GetFilteredProofRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SubscribeProofRequestsStream>,
            tonic::Status,
        >;
        /// Search for proof requests, programs, and requesters.
        async fn get_search_results(
            &self,
            request: tonic::Request<super::GetSearchResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSearchResultsResponse>,
            tonic::Status,
        >;
        /// Get metrics for proof requests.
        async fn get_proof_request_metrics(
            &self,
            request: tonic::Request<super::GetProofRequestMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProofRequestMetricsResponse>,
            tonic::Status,
        >;
        /// Get time series data for proof requests.
        async fn get_proof_request_graph(
            &self,
            request: tonic::Request<super::GetProofRequestGraphRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProofRequestGraphResponse>,
            tonic::Status,
        >;
        /// Get analytics graphs for proof requests.
        async fn get_analytics_graphs(
            &self,
            request: tonic::Request<super::GetAnalyticsGraphsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAnalyticsGraphsResponse>,
            tonic::Status,
        >;
        /// Get the nonce of the account.
        async fn get_nonce(
            &self,
            request: tonic::Request<super::GetNonceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetNonceResponse>,
            tonic::Status,
        >;
        /// Get the delegations of the account.
        async fn get_filtered_delegations(
            &self,
            request: tonic::Request<super::GetFilteredDelegationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredDelegationsResponse>,
            tonic::Status,
        >;
        /// Add a delegation. Only callable by the owner of an account.
        async fn add_delegation(
            &self,
            request: tonic::Request<super::AddDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddDelegationResponse>,
            tonic::Status,
        >;
        /// Remove a delegation. Only callable by the owner of an account.
        async fn remove_delegation(
            &self,
            request: tonic::Request<super::RemoveDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveDelegationResponse>,
            tonic::Status,
        >;
        /// Terminate a delegation. Only callable by the delegate of a delegation.
        async fn terminate_delegation(
            &self,
            request: tonic::Request<super::TerminateDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TerminateDelegationResponse>,
            tonic::Status,
        >;
        /// Accept a delegation. Only callable by the delegate of a delegation.
        async fn accept_delegation(
            &self,
            request: tonic::Request<super::AcceptDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AcceptDelegationResponse>,
            tonic::Status,
        >;
        /// Set the name of the account. Only callable by the owner of an account.
        async fn set_account_name(
            &self,
            request: tonic::Request<super::SetAccountNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetAccountNameResponse>,
            tonic::Status,
        >;
        /// Get the name of the account.
        async fn get_account_name(
            &self,
            request: tonic::Request<super::GetAccountNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAccountNameResponse>,
            tonic::Status,
        >;
        /// Get whether the account has signed the terms.
        async fn get_terms_signature(
            &self,
            request: tonic::Request<super::GetTermsSignatureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTermsSignatureResponse>,
            tonic::Status,
        >;
        /// Set whether the account has signed the terms.
        async fn set_terms_signature(
            &self,
            request: tonic::Request<super::SetTermsSignatureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetTermsSignatureResponse>,
            tonic::Status,
        >;
        /// Get all the information about an account.
        async fn get_account(
            &self,
            request: tonic::Request<super::GetAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAccountResponse>,
            tonic::Status,
        >;
        /// Get the owner of an account. Returns itself if the account is not delegated.
        async fn get_owner(
            &self,
            request: tonic::Request<super::GetOwnerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetOwnerResponse>,
            tonic::Status,
        >;
        /// Get metadata about a program.
        async fn get_program(
            &self,
            request: tonic::Request<super::GetProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProgramResponse>,
            tonic::Status,
        >;
        /// Create a new program. Must be called before requesting proofs.
        async fn create_program(
            &self,
            request: tonic::Request<super::CreateProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateProgramResponse>,
            tonic::Status,
        >;
        /// Set the name of the program. Only callable by the owner.
        async fn set_program_name(
            &self,
            request: tonic::Request<super::SetProgramNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetProgramNameResponse>,
            tonic::Status,
        >;
        /// Get the available balance of an account.
        async fn get_balance(
            &self,
            request: tonic::Request<super::GetBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBalanceResponse>,
            tonic::Status,
        >;
        /// Get the balance logs that meet the filter criteria.
        async fn get_filtered_balance_logs(
            &self,
            request: tonic::Request<super::GetFilteredBalanceLogsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredBalanceLogsResponse>,
            tonic::Status,
        >;
        /// Add credit to an account.
        async fn add_credit(
            &self,
            request: tonic::Request<super::AddCreditRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddCreditResponse>,
            tonic::Status,
        >;
        /// Get the latest processed block in the bridge.
        async fn get_latest_bridge_block(
            &self,
            request: tonic::Request<super::GetLatestBridgeBlockRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetLatestBridgeBlockResponse>,
            tonic::Status,
        >;
        /// Get the gas price estimate for a given fulfillment strategy.
        async fn get_gas_price_estimate(
            &self,
            request: tonic::Request<super::GetGasPriceEstimateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetGasPriceEstimateResponse>,
            tonic::Status,
        >;
        /// Get the details of a transaction.
        async fn get_transaction_details(
            &self,
            request: tonic::Request<super::GetTransactionDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTransactionDetailsResponse>,
            tonic::Status,
        >;
        /// Add a charge to an account.
        async fn add_reserved_charge(
            &self,
            request: tonic::Request<super::AddReservedChargeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddReservedChargeResponse>,
            tonic::Status,
        >;
        /// Get prorated billing summary by month for a specified payer.
        async fn get_billing_summary(
            &self,
            request: tonic::Request<super::GetBillingSummaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBillingSummaryResponse>,
            tonic::Status,
        >;
        /// Update the charge type price for a reservation.
        async fn update_price(
            &self,
            request: tonic::Request<super::UpdatePriceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdatePriceResponse>,
            tonic::Status,
        >;
        /// Get filtered and paginated clusters/fulfillers with prices.
        async fn get_filtered_clusters(
            &self,
            request: tonic::Request<super::GetFilteredClustersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredClustersResponse>,
            tonic::Status,
        >;
        /// Get usage summary by month for a specified payer.
        async fn get_usage_summary(
            &self,
            request: tonic::Request<super::GetUsageSummaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetUsageSummaryResponse>,
            tonic::Status,
        >;
        /// Get the reservations that meet the filter criteria.
        async fn get_filtered_reservations(
            &self,
            request: tonic::Request<super::GetFilteredReservationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredReservationsResponse>,
            tonic::Status,
        >;
        /// Add a reservation for a requester.
        async fn add_reservation(
            &self,
            request: tonic::Request<super::AddReservationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddReservationResponse>,
            tonic::Status,
        >;
        /// Remove a reservation for a requester.
        async fn remove_reservation(
            &self,
            request: tonic::Request<super::RemoveReservationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveReservationResponse>,
            tonic::Status,
        >;
        /// Bid for a proof request. Provers that want to be assigned this request must first
        /// bid on it.
        async fn bid(
            &self,
            request: tonic::Request<super::BidRequest>,
        ) -> std::result::Result<tonic::Response<super::BidResponse>, tonic::Status>;
        /// Settle the bids on a proof request to choose the assigned prover. Only callable by
        /// the approved auctioneer.
        async fn settle(
            &self,
            request: tonic::Request<super::SettleRequest>,
        ) -> std::result::Result<tonic::Response<super::SettleResponse>, tonic::Status>;
        /// Sign in with Ethereum
        async fn sign_in(
            &self,
            request: tonic::Request<super::SignInRequest>,
        ) -> std::result::Result<tonic::Response<super::SignInResponse>, tonic::Status>;
        /// Get the accounts that meet the filter criteria.
        async fn get_onboarded_accounts_count(
            &self,
            request: tonic::Request<super::GetOnboardedAccountsCountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetOnboardedAccountsCountResponse>,
            tonic::Status,
        >;
        /// Get the accounts that have joined the leaderboard.
        async fn get_filtered_onboarded_accounts(
            &self,
            request: tonic::Request<super::GetFilteredOnboardedAccountsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredOnboardedAccountsResponse>,
            tonic::Status,
        >;
        /// Get the leaderboard.
        async fn get_leaderboard(
            &self,
            request: tonic::Request<super::GetLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetLeaderboardResponse>,
            tonic::Status,
        >;
        /// Get the leaderboard stats for a given account.
        async fn get_leaderboard_stats(
            &self,
            request: tonic::Request<super::GetLeaderboardStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetLeaderboardStatsResponse>,
            tonic::Status,
        >;
        /// Get codes.
        async fn get_codes(
            &self,
            request: tonic::Request<super::GetCodesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCodesResponse>,
            tonic::Status,
        >;
        /// Redeem a code.
        async fn redeem_code(
            &self,
            request: tonic::Request<super::RedeemCodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RedeemCodeResponse>,
            tonic::Status,
        >;
        /// Connect a Twitter account.
        async fn connect_twitter(
            &self,
            request: tonic::Request<super::ConnectTwitterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConnectTwitterResponse>,
            tonic::Status,
        >;
        /// Complete onboarding.
        async fn complete_onboarding(
            &self,
            request: tonic::Request<super::CompleteOnboardingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CompleteOnboardingResponse>,
            tonic::Status,
        >;
        /// Set if a user should display their Twitter handle.
        async fn set_use_twitter_handle(
            &self,
            request: tonic::Request<super::SetUseTwitterHandleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetUseTwitterHandleResponse>,
            tonic::Status,
        >;
        /// Set if a user should display their Twitter profile picture.
        async fn set_use_twitter_image(
            &self,
            request: tonic::Request<super::SetUseTwitterImageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetUseTwitterImageResponse>,
            tonic::Status,
        >;
        /// Request a random proof.
        async fn request_random_proof(
            &self,
            request: tonic::Request<super::RequestRandomProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RequestRandomProofResponse>,
            tonic::Status,
        >;
        /// Submit answers for the captcha game.
        async fn submit_captcha_game(
            &self,
            request: tonic::Request<super::SubmitCaptchaGameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitCaptchaGameResponse>,
            tonic::Status,
        >;
        /// Redeem stars.
        async fn redeem_stars(
            &self,
            request: tonic::Request<super::RedeemStarsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RedeemStarsResponse>,
            tonic::Status,
        >;
        /// Get flappy leaderboard.
        async fn get_flappy_leaderboard(
            &self,
            request: tonic::Request<super::GetFlappyLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFlappyLeaderboardResponse>,
            tonic::Status,
        >;
        /// Set the turbo game high score.
        async fn set_turbo_high_score(
            &self,
            request: tonic::Request<super::SetTurboHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetTurboHighScoreResponse>,
            tonic::Status,
        >;
        /// Submit answers for the quiz game.
        async fn submit_quiz_game(
            &self,
            request: tonic::Request<super::SubmitQuizGameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitQuizGameResponse>,
            tonic::Status,
        >;
        /// Get the turbo game leaderboard.
        async fn get_turbo_leaderboard(
            &self,
            request: tonic::Request<super::GetTurboLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTurboLeaderboardResponse>,
            tonic::Status,
        >;
        /// Submit ETH block metadata.
        async fn submit_eth_block_metadata(
            &self,
            request: tonic::Request<super::SubmitEthBlockMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitEthBlockMetadataResponse>,
            tonic::Status,
        >;
        /// Get ETH block requests that meet the filter criteria.
        async fn get_filtered_eth_block_requests(
            &self,
            request: tonic::Request<super::GetFilteredEthBlockRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredEthBlockRequestsResponse>,
            tonic::Status,
        >;
        /// Set the 2048 game high score.
        async fn set2048_high_score(
            &self,
            request: tonic::Request<super::Set2048HighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::Set2048HighScoreResponse>,
            tonic::Status,
        >;
        /// Set the volleyball game high score.
        async fn set_volleyball_high_score(
            &self,
            request: tonic::Request<super::SetVolleyballHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetVolleyballHighScoreResponse>,
            tonic::Status,
        >;
        /// Get ETH block proof requests metrics.
        async fn get_eth_block_request_metrics(
            &self,
            request: tonic::Request<super::GetEthBlockRequestMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetEthBlockRequestMetricsResponse>,
            tonic::Status,
        >;
        /// Set the turbo time trial high score.
        async fn set_turbo_time_trial_high_score(
            &self,
            request: tonic::Request<super::SetTurboTimeTrialHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetTurboTimeTrialHighScoreResponse>,
            tonic::Status,
        >;
        /// Set the coin craze high score.
        async fn set_coin_craze_high_score(
            &self,
            request: tonic::Request<super::SetCoinCrazeHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetCoinCrazeHighScoreResponse>,
            tonic::Status,
        >;
        /// Set the lean high score.
        async fn set_lean_high_score(
            &self,
            request: tonic::Request<super::SetLeanHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetLeanHighScoreResponse>,
            tonic::Status,
        >;
        /// Set the flow high score.
        async fn set_flow_high_score(
            &self,
            request: tonic::Request<super::SetFlowHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetFlowHighScoreResponse>,
            tonic::Status,
        >;
        /// Set the rollup high score.
        async fn set_rollup_high_score(
            &self,
            request: tonic::Request<super::SetRollupHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRollupHighScoreResponse>,
            tonic::Status,
        >;
        /// Check if address or social identity is whitelisted.
        async fn get_whitelist_status(
            &self,
            request: tonic::Request<super::GetWhitelistStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetWhitelistStatusResponse>,
            tonic::Status,
        >;
        /// Set the gpu delegate.
        async fn set_gpu_delegate(
            &self,
            request: tonic::Request<super::SetGpuDelegateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetGpuDelegateResponse>,
            tonic::Status,
        >;
        /// Claim a gpu.
        async fn claim_gpu(
            &self,
            request: tonic::Request<super::ClaimGpuRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ClaimGpuResponse>,
            tonic::Status,
        >;
        /// Set the gpu variant.
        async fn set_gpu_variant(
            &self,
            request: tonic::Request<super::SetGpuVariantRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetGpuVariantResponse>,
            tonic::Status,
        >;
        /// Link a whitelisted twitter account.
        async fn link_whitelisted_twitter(
            &self,
            request: tonic::Request<super::LinkWhitelistedTwitterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LinkWhitelistedTwitterResponse>,
            tonic::Status,
        >;
        /// Retrieve the proving key for your account. Must have claimed a gpu and self-delegated to
        /// yourself.
        async fn retrieve_proving_key(
            &self,
            request: tonic::Request<super::RetrieveProvingKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RetrieveProvingKeyResponse>,
            tonic::Status,
        >;
        /// Link a whitelisted github account.
        async fn link_whitelisted_github(
            &self,
            request: tonic::Request<super::LinkWhitelistedGithubRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LinkWhitelistedGithubResponse>,
            tonic::Status,
        >;
        /// Link a whitelisted discord account.
        async fn link_whitelisted_discord(
            &self,
            request: tonic::Request<super::LinkWhitelistedDiscordRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LinkWhitelistedDiscordResponse>,
            tonic::Status,
        >;
        /// Get prover leaderboard.
        async fn get_prover_leaderboard(
            &self,
            request: tonic::Request<super::GetProverLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProverLeaderboardResponse>,
            tonic::Status,
        >;
        /// Get filtered gpus.
        async fn get_filtered_gpus(
            &self,
            request: tonic::Request<super::GetFilteredGpusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredGpusResponse>,
            tonic::Status,
        >;
        /// Set the gpu coordinates.
        async fn set_gpu_coordinates(
            &self,
            request: tonic::Request<super::SetGpuCoordinatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetGpuCoordinatesResponse>,
            tonic::Status,
        >;
        /// Get points.
        async fn get_points(
            &self,
            request: tonic::Request<super::GetPointsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetPointsResponse>,
            tonic::Status,
        >;
        /// Process clicks.
        async fn process_clicks(
            &self,
            request: tonic::Request<super::ProcessClicksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ProcessClicksResponse>,
            tonic::Status,
        >;
        /// Purchase upgrade.
        async fn purchase_upgrade(
            &self,
            request: tonic::Request<super::PurchaseUpgradeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PurchaseUpgradeResponse>,
            tonic::Status,
        >;
        /// Place a bet.
        async fn bet(
            &self,
            request: tonic::Request<super::BetRequest>,
        ) -> std::result::Result<tonic::Response<super::BetResponse>, tonic::Status>;
        /// Get the status of a proof contest.
        async fn get_contest_details(
            &self,
            request: tonic::Request<super::GetContestDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetContestDetailsResponse>,
            tonic::Status,
        >;
        /// Get latest contest id.
        async fn get_latest_contest(
            &self,
            request: tonic::Request<super::GetLatestContestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetLatestContestResponse>,
            tonic::Status,
        >;
        /// Get contest bettors.
        async fn get_contest_bettors(
            &self,
            request: tonic::Request<super::GetContestBettorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetContestBettorsResponse>,
            tonic::Status,
        >;
        /// Get gpu metrics.
        async fn get_gpu_metrics(
            &self,
            request: tonic::Request<super::GetGpuMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetGpuMetricsResponse>,
            tonic::Status,
        >;
        /// Get filtered prover activity.
        async fn get_filtered_prover_activity(
            &self,
            request: tonic::Request<super::GetFilteredProverActivityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredProverActivityResponse>,
            tonic::Status,
        >;
        /// Get prover metrics.
        async fn get_prover_metrics(
            &self,
            request: tonic::Request<super::GetProverMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProverMetricsResponse>,
            tonic::Status,
        >;
        /// Get filtered bet history.
        async fn get_filtered_bet_history(
            &self,
            request: tonic::Request<super::GetFilteredBetHistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredBetHistoryResponse>,
            tonic::Status,
        >;
        /// Get gpu team stats.
        async fn get_gpu_team_stats(
            &self,
            request: tonic::Request<super::GetGpuTeamStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetGpuTeamStatsResponse>,
            tonic::Status,
        >;
        /// Get metrics for a specific prover
        async fn get_prover_stats(
            &self,
            request: tonic::Request<super::GetProverStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProverStatsResponse>,
            tonic::Status,
        >;
        /// Get statistics for all provers with pagination
        async fn get_filtered_prover_stats(
            &self,
            request: tonic::Request<super::GetFilteredProverStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredProverStatsResponse>,
            tonic::Status,
        >;
        /// Get search results for provers
        async fn get_prover_search_results(
            &self,
            request: tonic::Request<super::GetProverSearchResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProverSearchResultsResponse>,
            tonic::Status,
        >;
        /// Get paginated auction history
        async fn get_filtered_bid_history(
            &self,
            request: tonic::Request<super::GetFilteredBidHistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredBidHistoryResponse>,
            tonic::Status,
        >;
        /// Check if the user is whitelisted to use the TEE service.
        async fn get_tee_whitelist_status(
            &self,
            request: tonic::Request<super::GetTeeWhitelistStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTeeWhitelistStatusResponse>,
            tonic::Status,
        >;
        ///
        /// Settlement
        ///
        /// These methods are for settling orders to L1.
        async fn get_settlement_request(
            &self,
            request: tonic::Request<super::GetSettlementRequestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSettlementRequestResponse>,
            tonic::Status,
        >;
        async fn get_filtered_settlement_requests(
            &self,
            request: tonic::Request<super::GetFilteredSettlementRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredSettlementRequestsResponse>,
            tonic::Status,
        >;
        /// Get the provers that meet the filter criteria.
        async fn get_filtered_provers(
            &self,
            request: tonic::Request<super::GetFilteredProversRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredProversResponse>,
            tonic::Status,
        >;
        /// Get the available balance of a staker.
        async fn get_staker_stake_balance(
            &self,
            request: tonic::Request<super::GetStakerStakeBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetStakerStakeBalanceResponse>,
            tonic::Status,
        >;
        /// Get the available balance of a prover.
        async fn get_prover_stake_balance(
            &self,
            request: tonic::Request<super::GetProverStakeBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProverStakeBalanceResponse>,
            tonic::Status,
        >;
        /// Get the staker balance logs that meet the filter criteria.
        async fn get_filtered_staker_stake_balance_logs(
            &self,
            request: tonic::Request<super::GetFilteredStakerStakeBalanceLogsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredStakerStakeBalanceLogsResponse>,
            tonic::Status,
        >;
        /// Get the prover balance logs that meet the filter criteria.
        async fn get_filtered_prover_stake_balance_logs(
            &self,
            request: tonic::Request<super::GetFilteredProverStakeBalanceLogsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredProverStakeBalanceLogsResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct ProverNetworkServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ProverNetworkServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ProverNetworkServer<T>
    where
        T: ProverNetwork,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/network.ProverNetwork/RequestProof" => {
                    #[allow(non_camel_case_types)]
                    struct RequestProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::RequestProofRequest>
                    for RequestProofSvc<T> {
                        type Response = super::RequestProofResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RequestProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::request_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RequestProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/FulfillProof" => {
                    #[allow(non_camel_case_types)]
                    struct FulfillProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::FulfillProofRequest>
                    for FulfillProofSvc<T> {
                        type Response = super::FulfillProofResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FulfillProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::fulfill_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FulfillProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ExecuteProof" => {
                    #[allow(non_camel_case_types)]
                    struct ExecuteProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::ExecuteProofRequest>
                    for ExecuteProofSvc<T> {
                        type Response = super::ExecuteProofResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExecuteProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::execute_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecuteProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/FailFulfillment" => {
                    #[allow(non_camel_case_types)]
                    struct FailFulfillmentSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::FailFulfillmentRequest>
                    for FailFulfillmentSvc<T> {
                        type Response = super::FailFulfillmentResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FailFulfillmentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::fail_fulfillment(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FailFulfillmentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/FailExecution" => {
                    #[allow(non_camel_case_types)]
                    struct FailExecutionSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::FailExecutionRequest>
                    for FailExecutionSvc<T> {
                        type Response = super::FailExecutionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FailExecutionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::fail_execution(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FailExecutionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestStatusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetProofRequestStatusRequest>
                    for GetProofRequestStatusSvc<T> {
                        type Response = super::GetProofRequestStatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProofRequestStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_status(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestDetails" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestDetailsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetProofRequestDetailsRequest>
                    for GetProofRequestDetailsSvc<T> {
                        type Response = super::GetProofRequestDetailsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProofRequestDetailsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_details(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProofRequests" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProofRequestsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetFilteredProofRequestsRequest>
                    for GetFilteredProofRequestsSvc<T> {
                        type Response = super::GetFilteredProofRequestsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GetFilteredProofRequestsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_proof_requests(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProofRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SubscribeProofRequests" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeProofRequestsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::ServerStreamingService<
                        super::GetFilteredProofRequestsRequest,
                    > for SubscribeProofRequestsSvc<T> {
                        type Response = super::ProofRequest;
                        type ResponseStream = T::SubscribeProofRequestsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GetFilteredProofRequestsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::subscribe_proof_requests(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeProofRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetSearchResults" => {
                    #[allow(non_camel_case_types)]
                    struct GetSearchResultsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetSearchResultsRequest>
                    for GetSearchResultsSvc<T> {
                        type Response = super::GetSearchResultsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSearchResultsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_search_results(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSearchResultsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestMetricsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetProofRequestMetricsRequest>
                    for GetProofRequestMetricsSvc<T> {
                        type Response = super::GetProofRequestMetricsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProofRequestMetricsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_metrics(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestGraph" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestGraphSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetProofRequestGraphRequest>
                    for GetProofRequestGraphSvc<T> {
                        type Response = super::GetProofRequestGraphResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProofRequestGraphRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_graph(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestGraphSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetAnalyticsGraphs" => {
                    #[allow(non_camel_case_types)]
                    struct GetAnalyticsGraphsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetAnalyticsGraphsRequest>
                    for GetAnalyticsGraphsSvc<T> {
                        type Response = super::GetAnalyticsGraphsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAnalyticsGraphsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_analytics_graphs(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAnalyticsGraphsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetNonce" => {
                    #[allow(non_camel_case_types)]
                    struct GetNonceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetNonceRequest>
                    for GetNonceSvc<T> {
                        type Response = super::GetNonceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetNonceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_nonce(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetNonceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredDelegations" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredDelegationsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetFilteredDelegationsRequest>
                    for GetFilteredDelegationsSvc<T> {
                        type Response = super::GetFilteredDelegationsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredDelegationsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_delegations(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredDelegationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AddDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct AddDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::AddDelegationRequest>
                    for AddDelegationSvc<T> {
                        type Response = super::AddDelegationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddDelegationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::add_delegation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RemoveDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::RemoveDelegationRequest>
                    for RemoveDelegationSvc<T> {
                        type Response = super::RemoveDelegationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RemoveDelegationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::remove_delegation(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/TerminateDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct TerminateDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::TerminateDelegationRequest>
                    for TerminateDelegationSvc<T> {
                        type Response = super::TerminateDelegationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TerminateDelegationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::terminate_delegation(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TerminateDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AcceptDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct AcceptDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::AcceptDelegationRequest>
                    for AcceptDelegationSvc<T> {
                        type Response = super::AcceptDelegationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AcceptDelegationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::accept_delegation(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AcceptDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetAccountName" => {
                    #[allow(non_camel_case_types)]
                    struct SetAccountNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SetAccountNameRequest>
                    for SetAccountNameSvc<T> {
                        type Response = super::SetAccountNameResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetAccountNameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_account_name(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetAccountNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetAccountName" => {
                    #[allow(non_camel_case_types)]
                    struct GetAccountNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetAccountNameRequest>
                    for GetAccountNameSvc<T> {
                        type Response = super::GetAccountNameResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAccountNameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_account_name(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAccountNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTermsSignature" => {
                    #[allow(non_camel_case_types)]
                    struct GetTermsSignatureSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetTermsSignatureRequest>
                    for GetTermsSignatureSvc<T> {
                        type Response = super::GetTermsSignatureResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTermsSignatureRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_terms_signature(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTermsSignatureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetTermsSignature" => {
                    #[allow(non_camel_case_types)]
                    struct SetTermsSignatureSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SetTermsSignatureRequest>
                    for SetTermsSignatureSvc<T> {
                        type Response = super::SetTermsSignatureResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetTermsSignatureRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_terms_signature(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetTermsSignatureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetAccount" => {
                    #[allow(non_camel_case_types)]
                    struct GetAccountSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetAccountRequest>
                    for GetAccountSvc<T> {
                        type Response = super::GetAccountResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAccountRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_account(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAccountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetOwner" => {
                    #[allow(non_camel_case_types)]
                    struct GetOwnerSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetOwnerRequest>
                    for GetOwnerSvc<T> {
                        type Response = super::GetOwnerResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetOwnerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_owner(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOwnerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProgram" => {
                    #[allow(non_camel_case_types)]
                    struct GetProgramSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetProgramRequest>
                    for GetProgramSvc<T> {
                        type Response = super::GetProgramResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProgramRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_program(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProgramSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/CreateProgram" => {
                    #[allow(non_camel_case_types)]
                    struct CreateProgramSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::CreateProgramRequest>
                    for CreateProgramSvc<T> {
                        type Response = super::CreateProgramResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateProgramRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::create_program(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateProgramSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetProgramName" => {
                    #[allow(non_camel_case_types)]
                    struct SetProgramNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SetProgramNameRequest>
                    for SetProgramNameSvc<T> {
                        type Response = super::SetProgramNameResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetProgramNameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_program_name(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetProgramNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetBalance" => {
                    #[allow(non_camel_case_types)]
                    struct GetBalanceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetBalanceRequest>
                    for GetBalanceSvc<T> {
                        type Response = super::GetBalanceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBalanceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_balance(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBalanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredBalanceLogs" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredBalanceLogsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetFilteredBalanceLogsRequest>
                    for GetFilteredBalanceLogsSvc<T> {
                        type Response = super::GetFilteredBalanceLogsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredBalanceLogsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_balance_logs(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredBalanceLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AddCredit" => {
                    #[allow(non_camel_case_types)]
                    struct AddCreditSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::AddCreditRequest>
                    for AddCreditSvc<T> {
                        type Response = super::AddCreditResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddCreditRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::add_credit(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddCreditSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLatestBridgeBlock" => {
                    #[allow(non_camel_case_types)]
                    struct GetLatestBridgeBlockSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetLatestBridgeBlockRequest>
                    for GetLatestBridgeBlockSvc<T> {
                        type Response = super::GetLatestBridgeBlockResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetLatestBridgeBlockRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_latest_bridge_block(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLatestBridgeBlockSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetGasPriceEstimate" => {
                    #[allow(non_camel_case_types)]
                    struct GetGasPriceEstimateSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetGasPriceEstimateRequest>
                    for GetGasPriceEstimateSvc<T> {
                        type Response = super::GetGasPriceEstimateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetGasPriceEstimateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_gas_price_estimate(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetGasPriceEstimateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTransactionDetails" => {
                    #[allow(non_camel_case_types)]
                    struct GetTransactionDetailsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetTransactionDetailsRequest>
                    for GetTransactionDetailsSvc<T> {
                        type Response = super::GetTransactionDetailsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTransactionDetailsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_transaction_details(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTransactionDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AddReservedCharge" => {
                    #[allow(non_camel_case_types)]
                    struct AddReservedChargeSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::AddReservedChargeRequest>
                    for AddReservedChargeSvc<T> {
                        type Response = super::AddReservedChargeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddReservedChargeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::add_reserved_charge(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddReservedChargeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetBillingSummary" => {
                    #[allow(non_camel_case_types)]
                    struct GetBillingSummarySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetBillingSummaryRequest>
                    for GetBillingSummarySvc<T> {
                        type Response = super::GetBillingSummaryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBillingSummaryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_billing_summary(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBillingSummarySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/UpdatePrice" => {
                    #[allow(non_camel_case_types)]
                    struct UpdatePriceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::UpdatePriceRequest>
                    for UpdatePriceSvc<T> {
                        type Response = super::UpdatePriceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdatePriceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::update_price(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdatePriceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredClusters" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredClustersSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetFilteredClustersRequest>
                    for GetFilteredClustersSvc<T> {
                        type Response = super::GetFilteredClustersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredClustersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_clusters(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredClustersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetUsageSummary" => {
                    #[allow(non_camel_case_types)]
                    struct GetUsageSummarySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetUsageSummaryRequest>
                    for GetUsageSummarySvc<T> {
                        type Response = super::GetUsageSummaryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetUsageSummaryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_usage_summary(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetUsageSummarySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredReservations" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredReservationsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetFilteredReservationsRequest>
                    for GetFilteredReservationsSvc<T> {
                        type Response = super::GetFilteredReservationsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GetFilteredReservationsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_reservations(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredReservationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AddReservation" => {
                    #[allow(non_camel_case_types)]
                    struct AddReservationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::AddReservationRequest>
                    for AddReservationSvc<T> {
                        type Response = super::AddReservationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddReservationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::add_reservation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddReservationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RemoveReservation" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveReservationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::RemoveReservationRequest>
                    for RemoveReservationSvc<T> {
                        type Response = super::RemoveReservationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RemoveReservationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::remove_reservation(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveReservationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Bid" => {
                    #[allow(non_camel_case_types)]
                    struct BidSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::BidRequest>
                    for BidSvc<T> {
                        type Response = super::BidResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::bid(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Settle" => {
                    #[allow(non_camel_case_types)]
                    struct SettleSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SettleRequest>
                    for SettleSvc<T> {
                        type Response = super::SettleResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SettleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::settle(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SettleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SignIn" => {
                    #[allow(non_camel_case_types)]
                    struct SignInSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SignInRequest>
                    for SignInSvc<T> {
                        type Response = super::SignInResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SignInRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::sign_in(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SignInSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetOnboardedAccountsCount" => {
                    #[allow(non_camel_case_types)]
                    struct GetOnboardedAccountsCountSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::GetOnboardedAccountsCountRequest,
                    > for GetOnboardedAccountsCountSvc<T> {
                        type Response = super::GetOnboardedAccountsCountResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GetOnboardedAccountsCountRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_onboarded_accounts_count(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOnboardedAccountsCountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredOnboardedAccounts" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredOnboardedAccountsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::GetFilteredOnboardedAccountsRequest,
                    > for GetFilteredOnboardedAccountsSvc<T> {
                        type Response = super::GetFilteredOnboardedAccountsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GetFilteredOnboardedAccountsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_onboarded_accounts(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredOnboardedAccountsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLeaderboard" => {
                    #[allow(non_camel_case_types)]
                    struct GetLeaderboardSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetLeaderboardRequest>
                    for GetLeaderboardSvc<T> {
                        type Response = super::GetLeaderboardResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetLeaderboardRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_leaderboard(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLeaderboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLeaderboardStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetLeaderboardStatsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetLeaderboardStatsRequest>
                    for GetLeaderboardStatsSvc<T> {
                        type Response = super::GetLeaderboardStatsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetLeaderboardStatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_leaderboard_stats(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLeaderboardStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetCodes" => {
                    #[allow(non_camel_case_types)]
                    struct GetCodesSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetCodesRequest>
                    for GetCodesSvc<T> {
                        type Response = super::GetCodesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCodesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_codes(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCodesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RedeemCode" => {
                    #[allow(non_camel_case_types)]
                    struct RedeemCodeSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::RedeemCodeRequest>
                    for RedeemCodeSvc<T> {
                        type Response = super::RedeemCodeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RedeemCodeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::redeem_code(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RedeemCodeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ConnectTwitter" => {
                    #[allow(non_camel_case_types)]
                    struct ConnectTwitterSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::ConnectTwitterRequest>
                    for ConnectTwitterSvc<T> {
                        type Response = super::ConnectTwitterResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ConnectTwitterRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::connect_twitter(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConnectTwitterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/CompleteOnboarding" => {
                    #[allow(non_camel_case_types)]
                    struct CompleteOnboardingSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::CompleteOnboardingRequest>
                    for CompleteOnboardingSvc<T> {
                        type Response = super::CompleteOnboardingResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CompleteOnboardingRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::complete_onboarding(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CompleteOnboardingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetUseTwitterHandle" => {
                    #[allow(non_camel_case_types)]
                    struct SetUseTwitterHandleSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SetUseTwitterHandleRequest>
                    for SetUseTwitterHandleSvc<T> {
                        type Response = super::SetUseTwitterHandleResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetUseTwitterHandleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_use_twitter_handle(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetUseTwitterHandleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetUseTwitterImage" => {
                    #[allow(non_camel_case_types)]
                    struct SetUseTwitterImageSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SetUseTwitterImageRequest>
                    for SetUseTwitterImageSvc<T> {
                        type Response = super::SetUseTwitterImageResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetUseTwitterImageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_use_twitter_image(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetUseTwitterImageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RequestRandomProof" => {
                    #[allow(non_camel_case_types)]
                    struct RequestRandomProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::RequestRandomProofRequest>
                    for RequestRandomProofSvc<T> {
                        type Response = super::RequestRandomProofResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RequestRandomProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::request_random_proof(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RequestRandomProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SubmitCaptchaGame" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitCaptchaGameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SubmitCaptchaGameRequest>
                    for SubmitCaptchaGameSvc<T> {
                        type Response = super::SubmitCaptchaGameResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubmitCaptchaGameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::submit_captcha_game(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitCaptchaGameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RedeemStars" => {
                    #[allow(non_camel_case_types)]
                    struct RedeemStarsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::RedeemStarsRequest>
                    for RedeemStarsSvc<T> {
                        type Response = super::RedeemStarsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RedeemStarsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::redeem_stars(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RedeemStarsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFlappyLeaderboard" => {
                    #[allow(non_camel_case_types)]
                    struct GetFlappyLeaderboardSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetFlappyLeaderboardRequest>
                    for GetFlappyLeaderboardSvc<T> {
                        type Response = super::GetFlappyLeaderboardResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFlappyLeaderboardRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_flappy_leaderboard(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFlappyLeaderboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetTurboHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetTurboHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SetTurboHighScoreRequest>
                    for SetTurboHighScoreSvc<T> {
                        type Response = super::SetTurboHighScoreResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetTurboHighScoreRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_turbo_high_score(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetTurboHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SubmitQuizGame" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitQuizGameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SubmitQuizGameRequest>
                    for SubmitQuizGameSvc<T> {
                        type Response = super::SubmitQuizGameResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubmitQuizGameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::submit_quiz_game(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitQuizGameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTurboLeaderboard" => {
                    #[allow(non_camel_case_types)]
                    struct GetTurboLeaderboardSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetTurboLeaderboardRequest>
                    for GetTurboLeaderboardSvc<T> {
                        type Response = super::GetTurboLeaderboardResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTurboLeaderboardRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_turbo_leaderboard(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTurboLeaderboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SubmitEthBlockMetadata" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitEthBlockMetadataSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SubmitEthBlockMetadataRequest>
                    for SubmitEthBlockMetadataSvc<T> {
                        type Response = super::SubmitEthBlockMetadataResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubmitEthBlockMetadataRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::submit_eth_block_metadata(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitEthBlockMetadataSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredEthBlockRequests" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredEthBlockRequestsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::GetFilteredEthBlockRequestsRequest,
                    > for GetFilteredEthBlockRequestsSvc<T> {
                        type Response = super::GetFilteredEthBlockRequestsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GetFilteredEthBlockRequestsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_eth_block_requests(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredEthBlockRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Set2048HighScore" => {
                    #[allow(non_camel_case_types)]
                    struct Set2048HighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::Set2048HighScoreRequest>
                    for Set2048HighScoreSvc<T> {
                        type Response = super::Set2048HighScoreResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::Set2048HighScoreRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set2048_high_score(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = Set2048HighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetVolleyballHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetVolleyballHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SetVolleyballHighScoreRequest>
                    for SetVolleyballHighScoreSvc<T> {
                        type Response = super::SetVolleyballHighScoreResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetVolleyballHighScoreRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_volleyball_high_score(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetVolleyballHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetEthBlockRequestMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct GetEthBlockRequestMetricsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::GetEthBlockRequestMetricsRequest,
                    > for GetEthBlockRequestMetricsSvc<T> {
                        type Response = super::GetEthBlockRequestMetricsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GetEthBlockRequestMetricsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_eth_block_request_metrics(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetEthBlockRequestMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetTurboTimeTrialHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetTurboTimeTrialHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::SetTurboTimeTrialHighScoreRequest,
                    > for SetTurboTimeTrialHighScoreSvc<T> {
                        type Response = super::SetTurboTimeTrialHighScoreResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::SetTurboTimeTrialHighScoreRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_turbo_time_trial_high_score(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetTurboTimeTrialHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetCoinCrazeHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetCoinCrazeHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SetCoinCrazeHighScoreRequest>
                    for SetCoinCrazeHighScoreSvc<T> {
                        type Response = super::SetCoinCrazeHighScoreResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetCoinCrazeHighScoreRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_coin_craze_high_score(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetCoinCrazeHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetLeanHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetLeanHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SetLeanHighScoreRequest>
                    for SetLeanHighScoreSvc<T> {
                        type Response = super::SetLeanHighScoreResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetLeanHighScoreRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_lean_high_score(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetLeanHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetFlowHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetFlowHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SetFlowHighScoreRequest>
                    for SetFlowHighScoreSvc<T> {
                        type Response = super::SetFlowHighScoreResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetFlowHighScoreRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_flow_high_score(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetFlowHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetRollupHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetRollupHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SetRollupHighScoreRequest>
                    for SetRollupHighScoreSvc<T> {
                        type Response = super::SetRollupHighScoreResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetRollupHighScoreRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_rollup_high_score(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetRollupHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetWhitelistStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetWhitelistStatusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetWhitelistStatusRequest>
                    for GetWhitelistStatusSvc<T> {
                        type Response = super::GetWhitelistStatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetWhitelistStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_whitelist_status(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetWhitelistStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetGpuDelegate" => {
                    #[allow(non_camel_case_types)]
                    struct SetGpuDelegateSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SetGpuDelegateRequest>
                    for SetGpuDelegateSvc<T> {
                        type Response = super::SetGpuDelegateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetGpuDelegateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_gpu_delegate(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetGpuDelegateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ClaimGpu" => {
                    #[allow(non_camel_case_types)]
                    struct ClaimGpuSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::ClaimGpuRequest>
                    for ClaimGpuSvc<T> {
                        type Response = super::ClaimGpuResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ClaimGpuRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::claim_gpu(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ClaimGpuSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetGpuVariant" => {
                    #[allow(non_camel_case_types)]
                    struct SetGpuVariantSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SetGpuVariantRequest>
                    for SetGpuVariantSvc<T> {
                        type Response = super::SetGpuVariantResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetGpuVariantRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_gpu_variant(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetGpuVariantSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/LinkWhitelistedTwitter" => {
                    #[allow(non_camel_case_types)]
                    struct LinkWhitelistedTwitterSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::LinkWhitelistedTwitterRequest>
                    for LinkWhitelistedTwitterSvc<T> {
                        type Response = super::LinkWhitelistedTwitterResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LinkWhitelistedTwitterRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::link_whitelisted_twitter(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkWhitelistedTwitterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RetrieveProvingKey" => {
                    #[allow(non_camel_case_types)]
                    struct RetrieveProvingKeySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::RetrieveProvingKeyRequest>
                    for RetrieveProvingKeySvc<T> {
                        type Response = super::RetrieveProvingKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RetrieveProvingKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::retrieve_proving_key(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RetrieveProvingKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/LinkWhitelistedGithub" => {
                    #[allow(non_camel_case_types)]
                    struct LinkWhitelistedGithubSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::LinkWhitelistedGithubRequest>
                    for LinkWhitelistedGithubSvc<T> {
                        type Response = super::LinkWhitelistedGithubResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LinkWhitelistedGithubRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::link_whitelisted_github(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkWhitelistedGithubSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/LinkWhitelistedDiscord" => {
                    #[allow(non_camel_case_types)]
                    struct LinkWhitelistedDiscordSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::LinkWhitelistedDiscordRequest>
                    for LinkWhitelistedDiscordSvc<T> {
                        type Response = super::LinkWhitelistedDiscordResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LinkWhitelistedDiscordRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::link_whitelisted_discord(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkWhitelistedDiscordSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverLeaderboard" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverLeaderboardSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetProverLeaderboardRequest>
                    for GetProverLeaderboardSvc<T> {
                        type Response = super::GetProverLeaderboardResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProverLeaderboardRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_leaderboard(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverLeaderboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredGpus" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredGpusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetFilteredGpusRequest>
                    for GetFilteredGpusSvc<T> {
                        type Response = super::GetFilteredGpusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredGpusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_gpus(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredGpusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetGpuCoordinates" => {
                    #[allow(non_camel_case_types)]
                    struct SetGpuCoordinatesSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::SetGpuCoordinatesRequest>
                    for SetGpuCoordinatesSvc<T> {
                        type Response = super::SetGpuCoordinatesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetGpuCoordinatesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_gpu_coordinates(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetGpuCoordinatesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetPoints" => {
                    #[allow(non_camel_case_types)]
                    struct GetPointsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetPointsRequest>
                    for GetPointsSvc<T> {
                        type Response = super::GetPointsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetPointsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_points(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPointsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ProcessClicks" => {
                    #[allow(non_camel_case_types)]
                    struct ProcessClicksSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::ProcessClicksRequest>
                    for ProcessClicksSvc<T> {
                        type Response = super::ProcessClicksResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ProcessClicksRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::process_clicks(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ProcessClicksSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/PurchaseUpgrade" => {
                    #[allow(non_camel_case_types)]
                    struct PurchaseUpgradeSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::PurchaseUpgradeRequest>
                    for PurchaseUpgradeSvc<T> {
                        type Response = super::PurchaseUpgradeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PurchaseUpgradeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::purchase_upgrade(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PurchaseUpgradeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Bet" => {
                    #[allow(non_camel_case_types)]
                    struct BetSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::BetRequest>
                    for BetSvc<T> {
                        type Response = super::BetResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::bet(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetContestDetails" => {
                    #[allow(non_camel_case_types)]
                    struct GetContestDetailsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetContestDetailsRequest>
                    for GetContestDetailsSvc<T> {
                        type Response = super::GetContestDetailsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetContestDetailsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_contest_details(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetContestDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLatestContest" => {
                    #[allow(non_camel_case_types)]
                    struct GetLatestContestSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetLatestContestRequest>
                    for GetLatestContestSvc<T> {
                        type Response = super::GetLatestContestResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetLatestContestRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_latest_contest(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLatestContestSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetContestBettors" => {
                    #[allow(non_camel_case_types)]
                    struct GetContestBettorsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetContestBettorsRequest>
                    for GetContestBettorsSvc<T> {
                        type Response = super::GetContestBettorsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetContestBettorsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_contest_bettors(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetContestBettorsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetGpuMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct GetGpuMetricsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetGpuMetricsRequest>
                    for GetGpuMetricsSvc<T> {
                        type Response = super::GetGpuMetricsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetGpuMetricsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_gpu_metrics(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetGpuMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProverActivity" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProverActivitySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::GetFilteredProverActivityRequest,
                    > for GetFilteredProverActivitySvc<T> {
                        type Response = super::GetFilteredProverActivityResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GetFilteredProverActivityRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_prover_activity(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProverActivitySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverMetricsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetProverMetricsRequest>
                    for GetProverMetricsSvc<T> {
                        type Response = super::GetProverMetricsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProverMetricsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_metrics(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredBetHistory" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredBetHistorySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetFilteredBetHistoryRequest>
                    for GetFilteredBetHistorySvc<T> {
                        type Response = super::GetFilteredBetHistoryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredBetHistoryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_bet_history(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredBetHistorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetGpuTeamStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetGpuTeamStatsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetGpuTeamStatsRequest>
                    for GetGpuTeamStatsSvc<T> {
                        type Response = super::GetGpuTeamStatsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetGpuTeamStatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_gpu_team_stats(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetGpuTeamStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverStatsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetProverStatsRequest>
                    for GetProverStatsSvc<T> {
                        type Response = super::GetProverStatsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProverStatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_stats(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProverStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProverStatsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetFilteredProverStatsRequest>
                    for GetFilteredProverStatsSvc<T> {
                        type Response = super::GetFilteredProverStatsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredProverStatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_prover_stats(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProverStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverSearchResults" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverSearchResultsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetProverSearchResultsRequest>
                    for GetProverSearchResultsSvc<T> {
                        type Response = super::GetProverSearchResultsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProverSearchResultsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_search_results(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverSearchResultsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredBidHistory" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredBidHistorySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetFilteredBidHistoryRequest>
                    for GetFilteredBidHistorySvc<T> {
                        type Response = super::GetFilteredBidHistoryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredBidHistoryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_bid_history(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredBidHistorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTEEWhitelistStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetTEEWhitelistStatusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetTeeWhitelistStatusRequest>
                    for GetTEEWhitelistStatusSvc<T> {
                        type Response = super::GetTeeWhitelistStatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTeeWhitelistStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_tee_whitelist_status(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTEEWhitelistStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetSettlementRequest" => {
                    #[allow(non_camel_case_types)]
                    struct GetSettlementRequestSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetSettlementRequestRequest>
                    for GetSettlementRequestSvc<T> {
                        type Response = super::GetSettlementRequestResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSettlementRequestRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_settlement_request(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSettlementRequestSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredSettlementRequests" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredSettlementRequestsSvc<T: ProverNetwork>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::GetFilteredSettlementRequestsRequest,
                    > for GetFilteredSettlementRequestsSvc<T> {
                        type Response = super::GetFilteredSettlementRequestsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GetFilteredSettlementRequestsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_settlement_requests(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredSettlementRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProvers" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProversSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetFilteredProversRequest>
                    for GetFilteredProversSvc<T> {
                        type Response = super::GetFilteredProversResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredProversRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_provers(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProversSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetStakerStakeBalance" => {
                    #[allow(non_camel_case_types)]
                    struct GetStakerStakeBalanceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetStakerStakeBalanceRequest>
                    for GetStakerStakeBalanceSvc<T> {
                        type Response = super::GetStakerStakeBalanceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetStakerStakeBalanceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_staker_stake_balance(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetStakerStakeBalanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverStakeBalance" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverStakeBalanceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<super::GetProverStakeBalanceRequest>
                    for GetProverStakeBalanceSvc<T> {
                        type Response = super::GetProverStakeBalanceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProverStakeBalanceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_stake_balance(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverStakeBalanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredStakerStakeBalanceLogs" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredStakerStakeBalanceLogsSvc<T: ProverNetwork>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::GetFilteredStakerStakeBalanceLogsRequest,
                    > for GetFilteredStakerStakeBalanceLogsSvc<T> {
                        type Response = super::GetFilteredStakerStakeBalanceLogsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GetFilteredStakerStakeBalanceLogsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_staker_stake_balance_logs(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredStakerStakeBalanceLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProverStakeBalanceLogs" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProverStakeBalanceLogsSvc<T: ProverNetwork>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ProverNetwork,
                    > tonic::server::UnaryService<
                        super::GetFilteredProverStakeBalanceLogsRequest,
                    > for GetFilteredProverStakeBalanceLogsSvc<T> {
                        type Response = super::GetFilteredProverStakeBalanceLogsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GetFilteredProverStakeBalanceLogsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_prover_stake_balance_logs(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProverStakeBalanceLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", tonic::Code::Unimplemented as i32)
                                .header(
                                    http::header::CONTENT_TYPE,
                                    tonic::metadata::GRPC_CONTENT_TYPE,
                                )
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T> Clone for ProverNetworkServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "network.ProverNetwork";
    impl<T> tonic::server::NamedService for ProverNetworkServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
