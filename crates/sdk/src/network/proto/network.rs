// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RequestProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RequestProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RequestProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The version of the prover to use.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// The mode for the request.
    #[prost(enumeration = "ProofMode", tag = "4")]
    pub mode: i32,
    /// The strategy for fulfiller assignment.
    #[prost(enumeration = "FulfillmentStrategy", tag = "5")]
    pub strategy: i32,
    /// The stdin resource identifier.
    #[prost(string, tag = "6")]
    pub stdin_uri: ::prost::alloc::string::String,
    /// The deadline for the request.
    #[prost(uint64, tag = "7")]
    pub deadline: u64,
    /// The cycle limit for the request.
    #[prost(uint64, tag = "8")]
    pub cycle_limit: u64,
    /// The gas limit for the request. If 0, the cycle_limit is used.
    #[prost(uint64, tag = "9")]
    pub gas_limit: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RequestProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RequestProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RequestProofResponseBody {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FulfillProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<FulfillProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FulfillProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The proof bytes.
    #[prost(bytes = "vec", tag = "3")]
    pub proof: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FulfillProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<FulfillProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct FulfillProofResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ExecuteProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<ExecuteProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ExecuteProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "3")]
    pub execution_status: i32,
    /// The optional public values hash of the request execution, only included if
    /// the request is valid.
    #[prost(bytes = "vec", optional, tag = "4")]
    pub public_values_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional cycles used when executing the request, only included if the
    /// request is valid.
    #[prost(uint64, optional, tag = "5")]
    pub cycles: ::core::option::Option<u64>,
    /// The optional amount of gas used when executing the request, only included if
    /// the request is valid.
    #[prost(uint64, optional, tag = "6")]
    pub gas_used: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ExecuteProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<ExecuteProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExecuteProofResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FailFulfillmentRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<FailFulfillmentRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FailFulfillmentRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FailFulfillmentResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<FailFulfillmentResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct FailFulfillmentResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FailExecutionRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<FailExecutionRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FailExecutionRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FailExecutionResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<FailExecutionResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct FailExecutionResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ProofRequest {
    /// The request identifier.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The version of the prover to use.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// The mode for the proof.
    #[prost(enumeration = "ProofMode", tag = "4")]
    pub mode: i32,
    /// The strategy for fulfiller assignment.
    #[prost(enumeration = "FulfillmentStrategy", tag = "5")]
    pub strategy: i32,
    /// The program resource identifier.
    #[prost(string, tag = "6")]
    pub program_uri: ::prost::alloc::string::String,
    /// The stdin resource identifier.
    #[prost(string, tag = "7")]
    pub stdin_uri: ::prost::alloc::string::String,
    /// The deadline for the request.
    #[prost(uint64, tag = "8")]
    pub deadline: u64,
    /// The cycle limit for the request.
    #[prost(uint64, tag = "9")]
    pub cycle_limit: u64,
    /// The gas price for the request.
    #[prost(uint64, optional, tag = "10")]
    pub gas_price: ::core::option::Option<u64>,
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "11")]
    pub fulfillment_status: i32,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "12")]
    pub execution_status: i32,
    /// The requester address that signed the request.
    #[prost(bytes = "vec", tag = "13")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
    /// The fulfiller address that fulfilled the request.
    #[prost(bytes = "vec", optional, tag = "14")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional name to refer to an alias of the program id.
    #[prost(string, optional, tag = "15")]
    pub program_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the requester address.
    #[prost(string, optional, tag = "16")]
    pub requester_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "17")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the request was created.
    #[prost(uint64, tag = "18")]
    pub created_at: u64,
    /// The unix timestamp of when the request was updated.
    #[prost(uint64, tag = "19")]
    pub updated_at: u64,
    /// The unix timestamp of when the request was fulfilled. Only included if
    /// the request has a fulfillment status of FULFILLED.
    #[prost(uint64, optional, tag = "20")]
    pub fulfilled_at: ::core::option::Option<u64>,
    /// The transaction hash of the request.
    #[prost(bytes = "vec", tag = "21")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The cycle used during the execution of the request. Only included if the
    /// request has an execution status of EXECUTED.
    #[prost(uint64, optional, tag = "22")]
    pub cycles: ::core::option::Option<u64>,
    /// The public values hash from the execution of the request. Only included if
    /// the request has an execution status of EXECUTED.
    #[prost(bytes = "vec", optional, tag = "23")]
    pub public_values_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The amount deducted from the fulfiller's balance. Only included if the
    /// request has a fulfillment status of ASSIGNED.
    #[prost(string, optional, tag = "24")]
    pub deduction_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// The amount refunded to the fulfiller's balance. Only included if the
    /// request has a fulfillment status of EXECUTED.
    #[prost(string, optional, tag = "25")]
    pub refund_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// The gas limit for the request.
    #[prost(uint64, tag = "26")]
    pub gas_limit: u64,
    /// The amount of gas used for the request.
    #[prost(uint64, optional, tag = "27")]
    pub gas_used: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestStatusRequest {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestStatusResponse {
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "1")]
    pub fulfillment_status: i32,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "2")]
    pub execution_status: i32,
    /// The transaction hash of the request.
    #[prost(bytes = "vec", tag = "3")]
    pub request_tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The deadline of the request. A request should be ignored if it is past
    /// its deadline.
    #[prost(uint64, tag = "4")]
    pub deadline: u64,
    /// The optional transaction hash of the proof fulfill. Only included if the
    /// request has a fulfillment status of FULFILLED.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub fulfill_tx_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional proof URI, where you can download the result of the request.
    /// Only included if the request has a fulfillment status of FULFILLED.
    #[prost(string, optional, tag = "6")]
    pub proof_uri: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional public values hash from the execution of the request. Only
    /// included if the request has an execution status of EXECUTED.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub public_values_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestDetailsRequest {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestDetailsResponse {
    /// The detailed request.
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<ProofRequest>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProofRequestsRequest {
    /// The optional version of the requests to filter for.
    #[prost(string, optional, tag = "1")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional fulfillment status of the requests to filter for.
    #[prost(enumeration = "FulfillmentStatus", optional, tag = "2")]
    pub fulfillment_status: ::core::option::Option<i32>,
    /// The optional execution status of the requests to filter for.
    #[prost(enumeration = "ExecutionStatus", optional, tag = "3")]
    pub execution_status: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp deadline of the requests to filter for.
    /// Only returns requests with deadlines after this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub minimum_deadline: ::core::option::Option<u64>,
    /// The optional verification key hash of the program to filter for.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub vk_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional requester address to filter for.
    #[prost(bytes = "vec", optional, tag = "6")]
    pub requester: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional fulfiller address to filter for.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional minimum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "8")]
    pub from: ::core::option::Option<u64>,
    /// The optional maximum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "9")]
    pub to: ::core::option::Option<u64>,
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "10")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "11")]
    pub page: ::core::option::Option<u32>,
    /// The optional mode of the requests to filter for.
    #[prost(enumeration = "ProofMode", optional, tag = "12")]
    pub mode: ::core::option::Option<i32>,
    /// The optional bidder address to filter out. Only returns requests that
    /// have not been bid by this address.
    #[prost(bytes = "vec", optional, tag = "13")]
    pub not_bid_by: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProofRequestsResponse {
    /// The requests that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<ProofRequest>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetSearchResultsRequest {
    /// The search query string.
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SearchResult {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetSearchResultsResponse {
    /// List of matching request IDs with optional names.
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<SearchResult>,
    /// List of matching program IDs with optional names.
    #[prost(message, repeated, tag = "2")]
    pub programs: ::prost::alloc::vec::Vec<SearchResult>,
    /// List of matching requester IDs with optional names.
    #[prost(message, repeated, tag = "3")]
    pub requesters: ::prost::alloc::vec::Vec<SearchResult>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestMetricsRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional interval in days for volume calculation.
    #[prost(uint64, optional, tag = "2")]
    pub volume_interval_days: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetProofRequestMetricsResponse {
    /// The total number of proofs.
    #[prost(uint64, tag = "1")]
    pub total_proofs: u64,
    /// The total number of cycles.
    #[prost(uint64, tag = "2")]
    pub total_cycles: u64,
    /// The volume in the specified interval.
    #[prost(uint64, tag = "3")]
    pub volume: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestGraphRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional interval in days for the graph range.
    #[prost(uint64, optional, tag = "2")]
    pub range_interval_days: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GraphData {
    /// The timestamp of the data point.
    #[prost(string, tag = "1")]
    pub timestamp: ::prost::alloc::string::String,
    /// The value at this timestamp.
    #[prost(uint64, tag = "2")]
    pub value: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestGraphResponse {
    /// The time series data points.
    #[prost(message, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<GraphData>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetAnalyticsGraphsRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional interval in days for the graph range.
    #[prost(uint64, optional, tag = "2")]
    pub range_interval_days: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetAnalyticsGraphsResponse {
    /// The time series data points for proof count.
    #[prost(message, repeated, tag = "1")]
    pub proofs: ::prost::alloc::vec::Vec<GraphData>,
    /// The time series data points for program count.
    #[prost(message, repeated, tag = "2")]
    pub programs: ::prost::alloc::vec::Vec<GraphData>,
    /// The time series data points for cycle count.
    #[prost(message, repeated, tag = "3")]
    pub cycles: ::prost::alloc::vec::Vec<GraphData>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetNonceRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetNonceResponse {
    /// The nonce of the account.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct Delegation {
    /// The address of the owner.
    #[prost(bytes = "vec", tag = "1")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    /// The address of the delegate (the account with granted permissions).
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
    /// Whether the delegation has been accepted.
    #[prost(bool, tag = "3")]
    pub accepted: bool,
    /// The unix timestamp of when the delegation was created.
    #[prost(uint64, tag = "4")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredDelegationsRequest {
    /// The optional owner address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub owner: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "2")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "3")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredDelegationsResponse {
    /// The delegations that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub delegations: ::prost::alloc::vec::Vec<Delegation>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddDelegationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AddDelegationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddDelegationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The delegate address to add.
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddDelegationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AddDelegationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddDelegationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RemoveDelegationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RemoveDelegationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RemoveDelegationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The delegate address to remove.
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RemoveDelegationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RemoveDelegationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveDelegationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct TerminateDelegationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<TerminateDelegationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct TerminateDelegationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the owner whose delegation to terminate.
    #[prost(bytes = "vec", tag = "2")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct TerminateDelegationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<TerminateDelegationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct TerminateDelegationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AcceptDelegationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AcceptDelegationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AcceptDelegationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the owner who requested the delegation
    #[prost(bytes = "vec", tag = "2")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AcceptDelegationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AcceptDelegationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct AcceptDelegationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetAccountNameRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetAccountNameRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetAccountNameRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the account to update the name of. Only the sender can
    /// update the name unless authorized.
    #[prost(bytes = "vec", tag = "2")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The name of the account. Must be unique.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetAccountNameResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetAccountNameResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetAccountNameResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetAccountNameRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetAccountNameResponse {
    /// The name of the account.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetTermsSignatureRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTermsSignatureResponse {
    /// Whether the account has signed the terms.
    #[prost(bool, tag = "1")]
    pub is_signed: bool,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetTermsSignatureRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The message accepting the terms of service.
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetTermsSignatureResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct Account {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The custom name of the account (optional).
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter handle of the account (optional).
    #[prost(string, optional, tag = "3")]
    pub twitter_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter name of the account (optional).
    #[prost(string, optional, tag = "4")]
    pub twitter_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter username of the account (optional).
    #[prost(string, optional, tag = "5")]
    pub twitter_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter image of the account (optional).
    #[prost(string, optional, tag = "6")]
    pub twitter_image: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether the account wants to use their twitter handle to set their name.
    #[prost(bool, tag = "7")]
    pub use_twitter_handle: bool,
    /// Whether the account wants to use their twitter image to set their image.
    #[prost(bool, tag = "8")]
    pub use_twitter_image: bool,
    /// The code of the account (optional).
    #[prost(string, optional, tag = "9")]
    pub code: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether the account has completed onboarding.
    #[prost(bool, tag = "10")]
    pub is_onboarded: bool,
    /// The version of the captcha game the account has completed.
    #[prost(int32, optional, tag = "11")]
    pub last_captcha_version: ::core::option::Option<i32>,
    /// The turbo high score of the account.
    #[prost(int32, optional, tag = "12")]
    pub turbo_high_score: ::core::option::Option<i32>,
    /// The version of the quiz game the account has completed.
    #[prost(int32, optional, tag = "13")]
    pub last_quiz_version: ::core::option::Option<i32>,
    /// The whitelist id of the account (optional).
    #[prost(int64, optional, tag = "14")]
    pub whitelist_id: ::core::option::Option<i64>,
    /// The social platform type from the whitelist (optional).
    #[prost(enumeration = "SocialPlatform", optional, tag = "15")]
    pub whitelist_social_platform: ::core::option::Option<i32>,
    /// The social handle from the whitelist (optional).
    #[prost(string, optional, tag = "16")]
    pub whitelist_social_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The social id from the whitelist (optional).
    #[prost(string, optional, tag = "17")]
    pub whitelist_social_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The social image from the whitelist (optional).
    #[prost(string, optional, tag = "18")]
    pub whitelist_social_image: ::core::option::Option<::prost::alloc::string::String>,
    /// The GPU ID of the account (optional).
    #[prost(int64, optional, tag = "19")]
    pub gpu_id: ::core::option::Option<i64>,
    /// The GPU delegate address (optional).
    #[prost(bytes = "vec", optional, tag = "20")]
    pub gpu_delegate: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The GPU variant type (optional).
    #[prost(enumeration = "GpuVariant", optional, tag = "21")]
    pub gpu_variant: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetAccountRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetAccountResponse {
    /// The account details.
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Account>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetTeeWhitelistStatusRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTeeWhitelistStatusResponse {
    /// The whitelist status.
    #[prost(bool, tag = "1")]
    pub is_whitelisted: bool,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct Program {
    /// The verification key hash.
    #[prost(bytes = "vec", tag = "1")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The verification key.
    #[prost(bytes = "vec", tag = "2")]
    pub vk: ::prost::alloc::vec::Vec<u8>,
    /// The program resource identifier.
    #[prost(string, tag = "3")]
    pub program_uri: ::prost::alloc::string::String,
    /// The optional name of the program.
    #[prost(string, optional, tag = "4")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The owner of the program.
    #[prost(bytes = "vec", tag = "5")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    /// The unix timestamp of when the program was created.
    #[prost(uint64, tag = "6")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProgramRequest {
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "1")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProgramResponse {
    /// The program details.
    #[prost(message, optional, tag = "1")]
    pub program: ::core::option::Option<Program>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct CreateProgramRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<CreateProgramRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct CreateProgramRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The verification key hash.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The verification key.
    #[prost(bytes = "vec", tag = "3")]
    pub vk: ::prost::alloc::vec::Vec<u8>,
    /// The program resource identifier.
    #[prost(string, tag = "4")]
    pub program_uri: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct CreateProgramResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<CreateProgramResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateProgramResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetProgramNameRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetProgramNameRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetProgramNameRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier of the program to update the name of. Only the original
    /// program creator can update the name unless authorized.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The name of the program. Must be unique.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetProgramNameResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetProgramNameResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetProgramNameResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceResponse {
    /// The amount of credits owned by the account.
    #[prost(string, tag = "1")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct BalanceLog {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The type of balance change operation.
    #[prost(enumeration = "BalanceOperation", tag = "2")]
    pub operation: i32,
    /// The amount of the change (can be positive or negative).
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    /// The transaction hash that caused this change.
    #[prost(bytes = "vec", tag = "4")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The unix timestamp of when this change occurred.
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBalanceLogsRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional type of operations to filter for.
    #[prost(enumeration = "BalanceOperation", optional, tag = "2")]
    pub operation: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp to filter logs from. Only returns
    /// logs after this timestamp.
    #[prost(uint64, optional, tag = "3")]
    pub minimum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum unix timestamp to filter logs to. Only returns
    /// logs before this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub maximum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum number of logs to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "5")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "6")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBalanceLogsResponse {
    /// The balance logs that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub logs: ::prost::alloc::vec::Vec<BalanceLog>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddCreditRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AddCreditRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddCreditRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the account to add credits to.
    #[prost(bytes = "vec", tag = "2")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The amount of credits to add.
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddCreditResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AddCreditResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddCreditResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLatestBridgeBlockRequest {
    /// The chain ID of the bridge.
    #[prost(uint32, tag = "1")]
    pub chain_id: u32,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLatestBridgeBlockResponse {
    /// The latest processed block in the bridge.
    #[prost(uint64, tag = "1")]
    pub block_number: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGasPriceEstimateRequest {
    #[prost(enumeration = "FulfillmentStrategy", tag = "1")]
    pub strategy: i32,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGasPriceEstimateResponse {
    #[prost(uint64, tag = "1")]
    pub gas_price: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionDetailsRequest {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct TransactionDetails {
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "4")]
    pub nonce: u64,
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
    #[prost(string, optional, tag = "6")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "7")]
    pub request_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionDetailsResponse {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<TransactionDetails>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct Reservation {
    /// The address of the requester.
    #[prost(bytes = "vec", tag = "1")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
    /// The address of the fulfiller.
    #[prost(bytes = "vec", tag = "2")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The optional name to refer to an alias of the requester address.
    #[prost(string, optional, tag = "3")]
    pub requester_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "4")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the reservation was created.
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredReservationsRequest {
    /// Requester address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub requester: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional maximum number of reservations to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "2")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "3")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredReservationsResponse {
    /// The reservations that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub reservations: ::prost::alloc::vec::Vec<Reservation>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddReservationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AddReservationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddReservationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the requester to add reservation for.
    #[prost(bytes = "vec", tag = "2")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
    /// The address of the fulfiller to reserve.
    #[prost(bytes = "vec", tag = "3")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddReservationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AddReservationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddReservationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RemoveReservationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RemoveReservationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RemoveReservationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the requester to remove reservation for.
    #[prost(bytes = "vec", tag = "2")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RemoveReservationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RemoveReservationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveReservationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct BidRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<BidRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct BidRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The request ID to bid on.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct BidResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<BidResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct BidResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SettleRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SettleRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SettleRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The request ID to settle bids for.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SettleResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SettleResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SettleResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct Claims {
    /// The subject of the JWT.
    #[prost(bytes = "vec", tag = "1")]
    pub sub: ::prost::alloc::vec::Vec<u8>,
    /// The expiration time of the JWT.
    #[prost(uint64, tag = "2")]
    pub exp: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SignInRequest {
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The SIWE message.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SignInResponse {
    /// The JSON Web Token (JWT) to use for authentication.
    #[prost(string, tag = "1")]
    pub jwt: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetOnboardedAccountsCountRequest {}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetOnboardedAccountsCountResponse {
    /// The number of accounts that have been onboarded.
    #[prost(uint64, tag = "1")]
    pub count: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct OnboardedAccount {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The unix timestamp of when the account was onboarded.
    #[prost(uint64, tag = "2")]
    pub created_at: u64,
    /// The optional name of the account.
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional twitter handle of the account.
    #[prost(string, optional, tag = "4")]
    pub image: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional invite code referrer of the account.
    #[prost(string, optional, tag = "5")]
    pub referrer: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFilteredOnboardedAccountsRequest {
    /// The optional maximum number of entries to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredOnboardedAccountsResponse {
    /// The accounts that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub accounts: ::prost::alloc::vec::Vec<OnboardedAccount>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct LeaderboardRow {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The rank of the account.
    #[prost(uint64, tag = "2")]
    pub rank: u64,
    /// The optional name of the account.
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional twitter handle of the account.
    #[prost(string, optional, tag = "4")]
    pub image: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional invite code referrer of the account.
    #[prost(string, optional, tag = "5")]
    pub referrer: ::core::option::Option<::prost::alloc::string::String>,
    /// The number of requests.
    #[prost(uint64, tag = "6")]
    pub requests: u64,
    /// The number of cycles.
    #[prost(uint64, tag = "7")]
    pub cycles: u64,
    /// The number of redeemed stars.
    #[prost(uint64, tag = "8")]
    pub redeemed_stars: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct LeaderboardRowWithExtraStars {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The rank of the account.
    #[prost(uint64, tag = "2")]
    pub rank: u64,
    /// The optional name of the account.
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional twitter handle of the account.
    #[prost(string, optional, tag = "4")]
    pub image: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional invite code referrer of the account.
    #[prost(string, optional, tag = "5")]
    pub referrer: ::core::option::Option<::prost::alloc::string::String>,
    /// The number of requests.
    #[prost(uint64, tag = "6")]
    pub requests: u64,
    /// The number of cycles.
    #[prost(uint64, tag = "7")]
    pub cycles: u64,
    /// The number of redeemed stars.
    #[prost(uint64, tag = "8")]
    pub redeemed_stars: u64,
    /// The number of pending stars (total - redeemed).
    #[prost(uint64, tag = "9")]
    pub pending_stars: u64,
    /// The number of referral stars (already counted in pending stars / redeemed stars).
    #[prost(uint64, tag = "10")]
    pub referral_stars: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLeaderboardRequest {
    /// The optional maximum number of entries to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetLeaderboardResponse {
    /// The leaderboard entries.
    #[prost(message, repeated, tag = "1")]
    pub leaderboard: ::prost::alloc::vec::Vec<LeaderboardRow>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetLeaderboardStatsRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetLeaderboardStatsResponse {
    /// The leaderboard stats for the account.
    #[prost(message, optional, tag = "1")]
    pub stats: ::core::option::Option<LeaderboardRowWithExtraStars>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ReferralCode {
    /// The code.
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    /// The optional account's address that redeemed the code.
    #[prost(bytes = "vec", optional, tag = "2")]
    pub referred_account: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional account's name that redeemed the code.
    #[prost(string, optional, tag = "3")]
    pub referred_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional account's image that redeemed the code.
    #[prost(string, optional, tag = "4")]
    pub referred_image: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the code was created.
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetCodesRequest {
    /// The account to get the codes for.
    #[prost(bytes = "vec", tag = "1")]
    pub account: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetCodesResponse {
    /// The codes that the account has.
    #[prost(message, repeated, tag = "1")]
    pub codes: ::prost::alloc::vec::Vec<ReferralCode>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RedeemCodeRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RedeemCodeRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RedeemCodeRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The code to redeem.
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RedeemCodeResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RedeemCodeResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct RedeemCodeResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ConnectTwitterRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<ConnectTwitterRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ConnectTwitterRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The callback URI redirected to.
    #[prost(string, tag = "2")]
    pub callback_uri: ::prost::alloc::string::String,
    /// The code from Twitter.
    #[prost(string, tag = "3")]
    pub code: ::prost::alloc::string::String,
    /// The code verifier used in the initial Twitter request.
    #[prost(string, tag = "4")]
    pub code_verifier: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ConnectTwitterResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<ConnectTwitterResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConnectTwitterResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct CompleteOnboardingRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<CompleteOnboardingRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct CompleteOnboardingRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct CompleteOnboardingResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<CompleteOnboardingResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct CompleteOnboardingResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetUseTwitterHandleRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetUseTwitterHandleRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetUseTwitterHandleRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// Whether to display the Twitter handle.
    #[prost(bool, tag = "2")]
    pub should_display: bool,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetUseTwitterHandleResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetUseTwitterHandleResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetUseTwitterHandleResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetUseTwitterImageRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetUseTwitterImageRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetUseTwitterImageRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// Whether to display the Twitter profile picture.
    #[prost(bool, tag = "2")]
    pub should_display: bool,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetUseTwitterImageResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetUseTwitterImageResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetUseTwitterImageResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RequestRandomProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RequestRandomProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestRandomProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RequestRandomProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RequestRandomProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RequestRandomProofResponseBody {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The name of the randomly selected program.
    #[prost(string, tag = "2")]
    pub program_name: ::prost::alloc::string::String,
    /// The number of bonus stars earned.
    #[prost(uint64, tag = "3")]
    pub stars: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SubmitCaptchaGameRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SubmitCaptchaGameRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SubmitCaptchaGameRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The list of integer answers for the captcha game.
    #[prost(int32, repeated, tag = "2")]
    pub fake_images: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SubmitCaptchaGameResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SubmitCaptchaGameResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitCaptchaGameResponseBody {
    /// The number of correct answers submitted.
    #[prost(uint32, tag = "1")]
    pub correct_count: u32,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RedeemStarsRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RedeemStarsRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct RedeemStarsRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RedeemStarsResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RedeemStarsResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RedeemStarsResponseBody {
    /// The base number of stars that were redeemed.
    #[prost(uint64, tag = "1")]
    pub base_stars: u64,
    /// The multiplier that was applied.
    #[prost(string, tag = "2")]
    pub multiplier: ::prost::alloc::string::String,
    /// The final number of stars after applying the multiplier.
    #[prost(uint64, tag = "3")]
    pub final_stars: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFlappyLeaderboardRequest {
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FlappyBirdEntry {
    /// The unique ID of the proof request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The account that submitted the proof request.
    #[prost(bytes = "vec", tag = "2")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
    /// The number of cycles used.
    #[prost(uint64, tag = "3")]
    pub cycles: u64,
    /// The player's score.
    #[prost(uint64, tag = "4")]
    pub score: u64,
    /// The twitter username of the account.
    #[prost(string, optional, tag = "5")]
    pub twitter_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter image of the account.
    #[prost(string, optional, tag = "6")]
    pub twitter_image: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether the account wants to use their twitter handle to set their name.
    #[prost(bool, tag = "7")]
    pub use_twitter_handle: bool,
    /// Whether the account wants to use their twitter image to set their image.
    #[prost(bool, tag = "8")]
    pub use_twitter_image: bool,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFlappyLeaderboardResponse {
    /// List of flappy bird leaderboard entries.
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<FlappyBirdEntry>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetTurboHighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetTurboHighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetTurboHighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetTurboHighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetTurboHighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetTurboHighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SubmitQuizGameRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SubmitQuizGameRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SubmitQuizGameRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The list of integer answers for the quiz game.
    #[prost(int32, repeated, tag = "2")]
    pub answers: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SubmitQuizGameResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SubmitQuizGameResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitQuizGameResponseBody {
    /// The number of correct answers submitted.
    #[prost(uint32, tag = "1")]
    pub correct_count: u32,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTurboLeaderboardRequest {
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct TurboLeaderboardEntry {
    /// The account that submitted the proof request.
    #[prost(bytes = "vec", tag = "1")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
    /// The player's score.
    #[prost(uint64, tag = "2")]
    pub score: u64,
    /// The twitter username of the account.
    #[prost(string, optional, tag = "3")]
    pub twitter_handle: ::core::option::Option<::prost::alloc::string::String>,
    /// The twitter image of the account.
    #[prost(string, optional, tag = "4")]
    pub twitter_image: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether the account wants to use their twitter handle to set their name.
    #[prost(bool, tag = "5")]
    pub use_twitter_handle: bool,
    /// Whether the account wants to use their twitter image to set their image.
    #[prost(bool, tag = "6")]
    pub use_twitter_image: bool,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetTurboLeaderboardResponse {
    /// List of turbo leaderboard entries.
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<TurboLeaderboardEntry>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SubmitEthBlockMetadataRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SubmitEthBlockMetadataBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SubmitEthBlockMetadataBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The request identifier for which this metadata is for.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The chain identifier.
    #[prost(uint32, tag = "3")]
    pub chain_id: u32,
    /// The block hash.
    #[prost(bytes = "vec", tag = "4")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    /// The block number.
    #[prost(uint64, tag = "5")]
    pub number: u64,
    /// The block timestamp.
    #[prost(uint64, tag = "6")]
    pub timestamp: u64,
    /// The block transaction count.
    #[prost(uint64, tag = "7")]
    pub tx_count: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SubmitEthBlockMetadataResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SubmitEthBlockMetadataResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitEthBlockMetadataResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct Bid {
    /// The address of the bidder.
    #[prost(bytes = "vec", tag = "1")]
    pub bidder: ::prost::alloc::vec::Vec<u8>,
    /// The amount of the bid.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct EthBlockRequest {
    /// The request identifier.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The version of the prover to use.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// The mode for the proof.
    #[prost(enumeration = "ProofMode", tag = "4")]
    pub mode: i32,
    /// The strategy for fulfiller assignment.
    #[prost(enumeration = "FulfillmentStrategy", tag = "5")]
    pub strategy: i32,
    /// The program resource identifier.
    #[prost(string, tag = "6")]
    pub program_uri: ::prost::alloc::string::String,
    /// The stdin resource identifier.
    #[prost(string, tag = "7")]
    pub stdin_uri: ::prost::alloc::string::String,
    /// The deadline for the request.
    #[prost(uint64, tag = "8")]
    pub deadline: u64,
    /// The cycle limit for the request.
    #[prost(uint64, tag = "9")]
    pub cycle_limit: u64,
    /// The gas price for the request.
    #[prost(uint64, optional, tag = "10")]
    pub gas_price: ::core::option::Option<u64>,
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "11")]
    pub fulfillment_status: i32,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "12")]
    pub execution_status: i32,
    /// The requester address that signed the request.
    #[prost(bytes = "vec", tag = "13")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
    /// The fulfiller address that fulfilled the request.
    #[prost(bytes = "vec", optional, tag = "14")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional name to refer to an alias of the program id.
    #[prost(string, optional, tag = "15")]
    pub program_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the requester address.
    #[prost(string, optional, tag = "16")]
    pub requester_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "17")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the request was created.
    #[prost(uint64, tag = "18")]
    pub created_at: u64,
    /// The unix timestamp of when the request was updated.
    #[prost(uint64, tag = "19")]
    pub updated_at: u64,
    /// The unix timestamp of when the request was fulfilled. Only included if
    /// the request has a fulfillment status of FULFILLED.
    #[prost(uint64, optional, tag = "20")]
    pub fulfilled_at: ::core::option::Option<u64>,
    /// The transaction hash of the request.
    #[prost(bytes = "vec", tag = "21")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The cycle used during the execution of the request. Only included if the
    /// request has an execution status of EXECUTED.
    #[prost(uint64, optional, tag = "22")]
    pub cycles: ::core::option::Option<u64>,
    /// The public values hash from the execution of the request. Only included if
    /// the request has an execution status of EXECUTED.
    #[prost(bytes = "vec", optional, tag = "23")]
    pub public_values_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The amount deducted from the fulfiller's balance. Only included if the
    /// request has a fulfillment status of ASSIGNED.
    #[prost(string, optional, tag = "24")]
    pub deduction_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// The amount refunded to the fulfiller's balance. Only included if the
    /// request has a fulfillment status of EXECUTED.
    #[prost(string, optional, tag = "25")]
    pub refund_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// The chain id of the request.
    #[prost(uint32, tag = "26")]
    pub chain_id: u32,
    /// The block hash of the request.
    #[prost(bytes = "vec", tag = "27")]
    pub block_hash: ::prost::alloc::vec::Vec<u8>,
    /// The block number of the request.
    #[prost(uint64, tag = "28")]
    pub block_number: u64,
    /// The block timestamp of the request.
    #[prost(uint64, tag = "29")]
    pub block_timestamp: u64,
    /// The block transaction count of the request.
    #[prost(uint64, tag = "30")]
    pub block_tx_count: u64,
    /// The bids for the request.
    #[prost(message, repeated, tag = "31")]
    pub bids: ::prost::alloc::vec::Vec<Bid>,
    /// When the auction was settled.
    #[prost(uint64, optional, tag = "32")]
    pub settled_at: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredEthBlockRequestsRequest {
    /// The optional version of the requests to filter for.
    #[prost(string, optional, tag = "1")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional fulfillment status of the requests to filter for.
    #[prost(enumeration = "FulfillmentStatus", optional, tag = "2")]
    pub fulfillment_status: ::core::option::Option<i32>,
    /// The optional execution status of the requests to filter for.
    #[prost(enumeration = "ExecutionStatus", optional, tag = "3")]
    pub execution_status: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp deadline of the requests to filter for.
    /// Only returns requests with deadlines after this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub minimum_deadline: ::core::option::Option<u64>,
    /// The optional verification key hash of the program to filter for.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub vk_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional requester address to filter for.
    #[prost(bytes = "vec", optional, tag = "6")]
    pub requester: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional fulfiller address to filter for.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional minimum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "8")]
    pub from: ::core::option::Option<u64>,
    /// The optional maximum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "9")]
    pub to: ::core::option::Option<u64>,
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "10")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "11")]
    pub page: ::core::option::Option<u32>,
    /// The optional mode of the requests to filter for.
    #[prost(enumeration = "ProofMode", optional, tag = "12")]
    pub mode: ::core::option::Option<i32>,
    /// The optional bidder address to filter out. Only returns requests that
    /// have not been bid by this address.
    #[prost(bytes = "vec", optional, tag = "13")]
    pub not_bid_by: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredEthBlockRequestsResponse {
    /// The list of filtered requests.
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<EthBlockRequest>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct Set2048HighScoreRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<Set2048HighScoreRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct Set2048HighScoreRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The high score to set.
    #[prost(uint64, tag = "2")]
    pub high_score: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct Set2048HighScoreResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<Set2048HighScoreResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct Set2048HighScoreResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SocialIdentity {
    /// The social platform.
    #[prost(enumeration = "SocialPlatform", tag = "1")]
    pub platform: i32,
    /// The social handle to check.
    #[prost(string, tag = "2")]
    pub handle: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetWhitelistStatusRequest {
    #[prost(oneof = "get_whitelist_status_request::Identifier", tags = "1, 2")]
    pub identifier: ::core::option::Option<get_whitelist_status_request::Identifier>,
}
/// Nested message and enum types in `GetWhitelistStatusRequest`.
pub mod get_whitelist_status_request {
    #[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Oneof)]
    pub enum Identifier {
        /// The ethereum address to check.
        #[prost(bytes, tag = "1")]
        Address(::prost::alloc::vec::Vec<u8>),
        /// The social identity to check.
        #[prost(message, tag = "2")]
        SocialIdentity(super::SocialIdentity),
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetWhitelistStatusResponse {
    /// Whether the user is whitelisted.
    #[prost(bool, tag = "1")]
    pub is_whitelisted: bool,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetGpuDelegateRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetGpuDelegateRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetGpuDelegateRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The ethereum address to delegate to.
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetGpuDelegateResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetGpuDelegateResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetGpuDelegateResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ClaimGpuRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<ClaimGpuRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ClaimGpuRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The optional whitelisted social identity.
    #[prost(message, optional, tag = "2")]
    pub social_identity: ::core::option::Option<SocialIdentity>,
    /// The ethereum address to delegate to.
    #[prost(bytes = "vec", tag = "3")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
    /// The gpu variant.
    #[prost(enumeration = "GpuVariant", tag = "4")]
    pub variant: i32,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ClaimGpuResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<ClaimGpuResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClaimGpuResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetGpuVariantRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetGpuVariantRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetGpuVariantRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The gpu variant.
    #[prost(enumeration = "GpuVariant", tag = "2")]
    pub variant: i32,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetGpuVariantResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetGpuVariantResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetGpuVariantResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedTwitterRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<LinkWhitelistedTwitterRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedTwitterRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The callback URI redirected to.
    #[prost(string, tag = "2")]
    pub callback_uri: ::prost::alloc::string::String,
    /// The code from Twitter.
    #[prost(string, tag = "3")]
    pub code: ::prost::alloc::string::String,
    /// The code verifier used in the initial Twitter request.
    #[prost(string, tag = "4")]
    pub code_verifier: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedTwitterResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<LinkWhitelistedTwitterResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct LinkWhitelistedTwitterResponseBody {}
/// Format to help decode signature in backend.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum MessageFormat {
    /// Unspecified message format.
    UnspecifiedMessageFormat = 0,
    /// The message is in binary format.
    Binary = 1,
    /// The message is in JSON format.
    Json = 2,
}
impl MessageFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedMessageFormat => "UNSPECIFIED_MESSAGE_FORMAT",
            Self::Binary => "BINARY",
            Self::Json => "JSON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_MESSAGE_FORMAT" => Some(Self::UnspecifiedMessageFormat),
            "BINARY" => Some(Self::Binary),
            "JSON" => Some(Self::Json),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ProofMode {
    UnspecifiedProofMode = 0,
    /// The core proof mode.
    Core = 1,
    /// The compressed proof mode.
    Compressed = 2,
    /// The plonk proof mode.
    Plonk = 3,
    /// The groth16 proof mode.
    Groth16 = 4,
}
impl ProofMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedProofMode => "UNSPECIFIED_PROOF_MODE",
            Self::Core => "CORE",
            Self::Compressed => "COMPRESSED",
            Self::Plonk => "PLONK",
            Self::Groth16 => "GROTH16",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_PROOF_MODE" => Some(Self::UnspecifiedProofMode),
            "CORE" => Some(Self::Core),
            "COMPRESSED" => Some(Self::Compressed),
            "PLONK" => Some(Self::Plonk),
            "GROTH16" => Some(Self::Groth16),
            _ => None,
        }
    }
}
/// The different strategies that can be used for fulfilling requests.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum FulfillmentStrategy {
    UnspecifiedFulfillmentStrategy = 0,
    /// The hosted fulfillment strategy. Uses Succinct's on-demand prover to fulfill requests.
    Hosted = 1,
    /// The reserved fulfillment strategy. Uses an already existing agreement with a
    /// fulfiller to fulfill requests.
    Reserved = 2,
    /// The auction fulfillment strategy. Uses a decentralized proof contest to
    /// fulfill requests.
    Auction = 3,
}
impl FulfillmentStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedFulfillmentStrategy => "UNSPECIFIED_FULFILLMENT_STRATEGY",
            Self::Hosted => "HOSTED",
            Self::Reserved => "RESERVED",
            Self::Auction => "AUCTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_FULFILLMENT_STRATEGY" => Some(Self::UnspecifiedFulfillmentStrategy),
            "HOSTED" => Some(Self::Hosted),
            "RESERVED" => Some(Self::Reserved),
            "AUCTION" => Some(Self::Auction),
            _ => None,
        }
    }
}
/// The different fulfillment statuses that a request can be in.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum FulfillmentStatus {
    UnspecifiedFulfillmentStatus = 0,
    /// The request has been requested.
    Requested = 1,
    /// The request has been assigned to a fulfiller.
    Assigned = 2,
    /// The request has been fulfilled.
    Fulfilled = 3,
    /// The request cannot be fulfilled.
    Unfulfillable = 4,
}
impl FulfillmentStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedFulfillmentStatus => "UNSPECIFIED_FULFILLMENT_STATUS",
            Self::Requested => "REQUESTED",
            Self::Assigned => "ASSIGNED",
            Self::Fulfilled => "FULFILLED",
            Self::Unfulfillable => "UNFULFILLABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_FULFILLMENT_STATUS" => Some(Self::UnspecifiedFulfillmentStatus),
            "REQUESTED" => Some(Self::Requested),
            "ASSIGNED" => Some(Self::Assigned),
            "FULFILLED" => Some(Self::Fulfilled),
            "UNFULFILLABLE" => Some(Self::Unfulfillable),
            _ => None,
        }
    }
}
/// The different execution statuses that a request can be in.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ExecutionStatus {
    UnspecifiedExecutionStatus = 0,
    /// The request has not been executed.
    Unexecuted = 1,
    /// The request has been executed.
    Executed = 2,
    /// The request cannot be executed.
    Unexecutable = 3,
}
impl ExecutionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedExecutionStatus => "UNSPECIFIED_EXECUTION_STATUS",
            Self::Unexecuted => "UNEXECUTED",
            Self::Executed => "EXECUTED",
            Self::Unexecutable => "UNEXECUTABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_EXECUTION_STATUS" => Some(Self::UnspecifiedExecutionStatus),
            "UNEXECUTED" => Some(Self::Unexecuted),
            "EXECUTED" => Some(Self::Executed),
            "UNEXECUTABLE" => Some(Self::Unexecutable),
            _ => None,
        }
    }
}
/// The different types of balance changes that can occur.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum BalanceOperation {
    UnspecifiedBalanceChangeOperation = 0,
    /// A deposit operation (positive).
    Deposit = 1,
    /// A withdrawal operation (negative).
    Withdrawal = 2,
    /// A credit operation (positive).
    Credit = 3,
    /// A deduction operation (negative).
    Deduction = 4,
    /// A refund operation (positive).
    Refund = 5,
    /// A bid operation (negative).
    Bid = 6,
    /// A reward operation (positive).
    Reward = 7,
}
impl BalanceOperation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedBalanceChangeOperation => "UNSPECIFIED_BALANCE_CHANGE_OPERATION",
            Self::Deposit => "DEPOSIT",
            Self::Withdrawal => "WITHDRAWAL",
            Self::Credit => "CREDIT",
            Self::Deduction => "DEDUCTION",
            Self::Refund => "REFUND",
            Self::Bid => "BID",
            Self::Reward => "REWARD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_BALANCE_CHANGE_OPERATION" => Some(Self::UnspecifiedBalanceChangeOperation),
            "DEPOSIT" => Some(Self::Deposit),
            "WITHDRAWAL" => Some(Self::Withdrawal),
            "CREDIT" => Some(Self::Credit),
            "DEDUCTION" => Some(Self::Deduction),
            "REFUND" => Some(Self::Refund),
            "BID" => Some(Self::Bid),
            "REWARD" => Some(Self::Reward),
            _ => None,
        }
    }
}
/// The different social platforms.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum SocialPlatform {
    UnspecifiedPlatform = 0,
    /// The twitter platform.
    Twitter = 1,
    /// The github platform.
    Github = 2,
    /// The discord platform.
    Discord = 3,
}
impl SocialPlatform {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedPlatform => "UNSPECIFIED_PLATFORM",
            Self::Twitter => "TWITTER",
            Self::Github => "GITHUB",
            Self::Discord => "DISCORD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_PLATFORM" => Some(Self::UnspecifiedPlatform),
            "TWITTER" => Some(Self::Twitter),
            "GITHUB" => Some(Self::Github),
            "DISCORD" => Some(Self::Discord),
            _ => None,
        }
    }
}
/// The different gpu variants.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum GpuVariant {
    UnspecifiedVariant = 0,
    /// The blueberry variant.
    Blueberry = 1,
    /// The strawberry variant.
    Strawberry = 2,
    /// The lime variant.
    Lime = 3,
    /// The tangerine variant.
    Tangerine = 4,
    /// The grape variant.
    Grape = 5,
}
impl GpuVariant {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedVariant => "UNSPECIFIED_VARIANT",
            Self::Blueberry => "BLUEBERRY",
            Self::Strawberry => "STRAWBERRY",
            Self::Lime => "LIME",
            Self::Tangerine => "TANGERINE",
            Self::Grape => "GRAPE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_VARIANT" => Some(Self::UnspecifiedVariant),
            "BLUEBERRY" => Some(Self::Blueberry),
            "STRAWBERRY" => Some(Self::Strawberry),
            "LIME" => Some(Self::Lime),
            "TANGERINE" => Some(Self::Tangerine),
            "GRAPE" => Some(Self::Grape),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod prover_network_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct ProverNetworkClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ProverNetworkClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ProverNetworkClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ProverNetworkClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ProverNetworkClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a proof request.
        pub async fn request_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::RequestProofRequest>,
        ) -> std::result::Result<tonic::Response<super::RequestProofResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/RequestProof");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "RequestProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Fulfills a proof request. Only callable by the assigned fulfiller.
        pub async fn fulfill_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::FulfillProofRequest>,
        ) -> std::result::Result<tonic::Response<super::FulfillProofResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/FulfillProof");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "FulfillProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Executes a proof request. Only callable by the execution oracle.
        pub async fn execute_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecuteProofRequest>,
        ) -> std::result::Result<tonic::Response<super::ExecuteProofResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/ExecuteProof");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "ExecuteProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Fails fulfillment. Only callable by the assigned fulfiller.
        pub async fn fail_fulfillment(
            &mut self,
            request: impl tonic::IntoRequest<super::FailFulfillmentRequest>,
        ) -> std::result::Result<tonic::Response<super::FailFulfillmentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/FailFulfillment");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "FailFulfillment"));
            self.inner.unary(req, path, codec).await
        }
        /// Fails execution. Only callable by the execution oracle.
        pub async fn fail_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::FailExecutionRequest>,
        ) -> std::result::Result<tonic::Response<super::FailExecutionResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/FailExecution");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "FailExecution"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the status of a proof request.
        pub async fn get_proof_request_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProofRequestStatusRequest>,
        ) -> std::result::Result<tonic::Response<super::GetProofRequestStatusResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProofRequestStatus"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the details of a proof request.
        pub async fn get_proof_request_details(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProofRequestDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProofRequestDetailsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProofRequestDetails"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the proof requests that meet the filter criteria.
        pub async fn get_filtered_proof_requests(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredProofRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredProofRequestsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProofRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredProofRequests"));
            self.inner.unary(req, path, codec).await
        }
        /// Search for proof requests, programs, and requesters.
        pub async fn get_search_results(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSearchResultsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSearchResultsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetSearchResults");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetSearchResults"));
            self.inner.unary(req, path, codec).await
        }
        /// Get metrics for proof requests.
        pub async fn get_proof_request_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProofRequestMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProofRequestMetricsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProofRequestMetrics"));
            self.inner.unary(req, path, codec).await
        }
        /// Get time series data for proof requests.
        pub async fn get_proof_request_graph(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProofRequestGraphRequest>,
        ) -> std::result::Result<tonic::Response<super::GetProofRequestGraphResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetProofRequestGraph");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProofRequestGraph"));
            self.inner.unary(req, path, codec).await
        }
        /// Get analytics graphs for proof requests.
        pub async fn get_analytics_graphs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAnalyticsGraphsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAnalyticsGraphsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetAnalyticsGraphs");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetAnalyticsGraphs"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the nonce of the account.
        pub async fn get_nonce(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNonceRequest>,
        ) -> std::result::Result<tonic::Response<super::GetNonceResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetNonce");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetNonce"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the delegations of the account.
        pub async fn get_filtered_delegations(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredDelegationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredDelegationsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredDelegations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredDelegations"));
            self.inner.unary(req, path, codec).await
        }
        /// Add a delegation. Only callable by the owner of an account.
        pub async fn add_delegation(
            &mut self,
            request: impl tonic::IntoRequest<super::AddDelegationRequest>,
        ) -> std::result::Result<tonic::Response<super::AddDelegationResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/AddDelegation");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "AddDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Remove a delegation. Only callable by the owner of an account.
        pub async fn remove_delegation(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveDelegationRequest>,
        ) -> std::result::Result<tonic::Response<super::RemoveDelegationResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/RemoveDelegation");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RemoveDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Terminate a delegation. Only callable by the delegate of a delegation.
        pub async fn terminate_delegation(
            &mut self,
            request: impl tonic::IntoRequest<super::TerminateDelegationRequest>,
        ) -> std::result::Result<tonic::Response<super::TerminateDelegationResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/TerminateDelegation");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "TerminateDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Accept a delegation. Only callable by the delegate of a delegation.
        pub async fn accept_delegation(
            &mut self,
            request: impl tonic::IntoRequest<super::AcceptDelegationRequest>,
        ) -> std::result::Result<tonic::Response<super::AcceptDelegationResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/AcceptDelegation");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "AcceptDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the name of the account. Only callable by the owner of an account.
        pub async fn set_account_name(
            &mut self,
            request: impl tonic::IntoRequest<super::SetAccountNameRequest>,
        ) -> std::result::Result<tonic::Response<super::SetAccountNameResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetAccountName");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "SetAccountName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the name of the account.
        pub async fn get_account_name(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAccountNameRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAccountNameResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetAccountName");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetAccountName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get whether the account has signed the terms.
        pub async fn get_terms_signature(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTermsSignatureRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTermsSignatureResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetTermsSignature");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetTermsSignature"));
            self.inner.unary(req, path, codec).await
        }
        /// Set whether the account has signed the terms.
        pub async fn set_terms_signature(
            &mut self,
            request: impl tonic::IntoRequest<super::SetTermsSignatureRequest>,
        ) -> std::result::Result<tonic::Response<super::SetTermsSignatureResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetTermsSignature");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetTermsSignature"));
            self.inner.unary(req, path, codec).await
        }
        /// Get all the information about an account.
        pub async fn get_account(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAccountRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAccountResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetAccount");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetAccount"));
            self.inner.unary(req, path, codec).await
        }
        /// Get metadata about a program.
        pub async fn get_program(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProgramRequest>,
        ) -> std::result::Result<tonic::Response<super::GetProgramResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetProgram");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetProgram"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new program. Must be called before requesting proofs.
        pub async fn create_program(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateProgramRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateProgramResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/CreateProgram");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "CreateProgram"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the name of the program. Only callable by the owner.
        pub async fn set_program_name(
            &mut self,
            request: impl tonic::IntoRequest<super::SetProgramNameRequest>,
        ) -> std::result::Result<tonic::Response<super::SetProgramNameResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetProgramName");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "SetProgramName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the available balance of an account.
        pub async fn get_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBalanceRequest>,
        ) -> std::result::Result<tonic::Response<super::GetBalanceResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetBalance");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetBalance"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the balance logs that meet the filter criteria.
        pub async fn get_filtered_balance_logs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredBalanceLogsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredBalanceLogsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredBalanceLogs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredBalanceLogs"));
            self.inner.unary(req, path, codec).await
        }
        /// Add credit to an account.
        pub async fn add_credit(
            &mut self,
            request: impl tonic::IntoRequest<super::AddCreditRequest>,
        ) -> std::result::Result<tonic::Response<super::AddCreditResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/AddCredit");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "AddCredit"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the latest processed block in the bridge.
        pub async fn get_latest_bridge_block(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLatestBridgeBlockRequest>,
        ) -> std::result::Result<tonic::Response<super::GetLatestBridgeBlockResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetLatestBridgeBlock");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetLatestBridgeBlock"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the gas price estimate for a given fulfillment strategy.
        pub async fn get_gas_price_estimate(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGasPriceEstimateRequest>,
        ) -> std::result::Result<tonic::Response<super::GetGasPriceEstimateResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetGasPriceEstimate");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetGasPriceEstimate"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the details of a transaction.
        pub async fn get_transaction_details(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionDetailsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTransactionDetailsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetTransactionDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetTransactionDetails"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the reservations that meet the filter criteria.
        pub async fn get_filtered_reservations(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredReservationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredReservationsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredReservations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredReservations"));
            self.inner.unary(req, path, codec).await
        }
        /// Add a reservation for a requester.
        pub async fn add_reservation(
            &mut self,
            request: impl tonic::IntoRequest<super::AddReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::AddReservationResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/AddReservation");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "AddReservation"));
            self.inner.unary(req, path, codec).await
        }
        /// Remove a reservation for a requester.
        pub async fn remove_reservation(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::RemoveReservationResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/RemoveReservation");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RemoveReservation"));
            self.inner.unary(req, path, codec).await
        }
        /// Bid for a proof request. Provers that want to be assigned this request must first
        /// bid on it.
        pub async fn bid(
            &mut self,
            request: impl tonic::IntoRequest<super::BidRequest>,
        ) -> std::result::Result<tonic::Response<super::BidResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/Bid");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "Bid"));
            self.inner.unary(req, path, codec).await
        }
        /// Settle the bids on a proof request to choose the assigned prover. Only callable by
        /// the approved settler.
        pub async fn settle(
            &mut self,
            request: impl tonic::IntoRequest<super::SettleRequest>,
        ) -> std::result::Result<tonic::Response<super::SettleResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/Settle");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "Settle"));
            self.inner.unary(req, path, codec).await
        }
        /// Sign in with Ethereum
        pub async fn sign_in(
            &mut self,
            request: impl tonic::IntoRequest<super::SignInRequest>,
        ) -> std::result::Result<tonic::Response<super::SignInResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/SignIn");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "SignIn"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the accounts that meet the filter criteria.
        pub async fn get_onboarded_accounts_count(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOnboardedAccountsCountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetOnboardedAccountsCountResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetOnboardedAccountsCount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetOnboardedAccountsCount"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the accounts that have joined the leaderboard.
        pub async fn get_filtered_onboarded_accounts(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredOnboardedAccountsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredOnboardedAccountsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredOnboardedAccounts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredOnboardedAccounts"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the leaderboard.
        pub async fn get_leaderboard(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLeaderboardRequest>,
        ) -> std::result::Result<tonic::Response<super::GetLeaderboardResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetLeaderboard");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetLeaderboard"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the leaderboard stats for a given account.
        pub async fn get_leaderboard_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLeaderboardStatsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetLeaderboardStatsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetLeaderboardStats");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetLeaderboardStats"));
            self.inner.unary(req, path, codec).await
        }
        /// Get codes.
        pub async fn get_codes(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCodesRequest>,
        ) -> std::result::Result<tonic::Response<super::GetCodesResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetCodes");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetCodes"));
            self.inner.unary(req, path, codec).await
        }
        /// Redeem a code.
        pub async fn redeem_code(
            &mut self,
            request: impl tonic::IntoRequest<super::RedeemCodeRequest>,
        ) -> std::result::Result<tonic::Response<super::RedeemCodeResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/RedeemCode");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "RedeemCode"));
            self.inner.unary(req, path, codec).await
        }
        /// Connect a Twitter account.
        pub async fn connect_twitter(
            &mut self,
            request: impl tonic::IntoRequest<super::ConnectTwitterRequest>,
        ) -> std::result::Result<tonic::Response<super::ConnectTwitterResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/ConnectTwitter");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "ConnectTwitter"));
            self.inner.unary(req, path, codec).await
        }
        /// Complete onboarding.
        pub async fn complete_onboarding(
            &mut self,
            request: impl tonic::IntoRequest<super::CompleteOnboardingRequest>,
        ) -> std::result::Result<tonic::Response<super::CompleteOnboardingResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/CompleteOnboarding");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "CompleteOnboarding"));
            self.inner.unary(req, path, codec).await
        }
        /// Set if a user should display their Twitter handle.
        pub async fn set_use_twitter_handle(
            &mut self,
            request: impl tonic::IntoRequest<super::SetUseTwitterHandleRequest>,
        ) -> std::result::Result<tonic::Response<super::SetUseTwitterHandleResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetUseTwitterHandle");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetUseTwitterHandle"));
            self.inner.unary(req, path, codec).await
        }
        /// Set if a user should display their Twitter profile picture.
        pub async fn set_use_twitter_image(
            &mut self,
            request: impl tonic::IntoRequest<super::SetUseTwitterImageRequest>,
        ) -> std::result::Result<tonic::Response<super::SetUseTwitterImageResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetUseTwitterImage");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetUseTwitterImage"));
            self.inner.unary(req, path, codec).await
        }
        /// Request a random proof.
        pub async fn request_random_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::RequestRandomProofRequest>,
        ) -> std::result::Result<tonic::Response<super::RequestRandomProofResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/RequestRandomProof");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RequestRandomProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit answers for the captcha game.
        pub async fn submit_captcha_game(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitCaptchaGameRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitCaptchaGameResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SubmitCaptchaGame");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SubmitCaptchaGame"));
            self.inner.unary(req, path, codec).await
        }
        /// Redeem stars.
        pub async fn redeem_stars(
            &mut self,
            request: impl tonic::IntoRequest<super::RedeemStarsRequest>,
        ) -> std::result::Result<tonic::Response<super::RedeemStarsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/RedeemStars");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "RedeemStars"));
            self.inner.unary(req, path, codec).await
        }
        /// Get flappy leaderboard.
        pub async fn get_flappy_leaderboard(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFlappyLeaderboardRequest>,
        ) -> std::result::Result<tonic::Response<super::GetFlappyLeaderboardResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetFlappyLeaderboard");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFlappyLeaderboard"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the turbo game high score.
        pub async fn set_turbo_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::SetTurboHighScoreRequest>,
        ) -> std::result::Result<tonic::Response<super::SetTurboHighScoreResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetTurboHighScore");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetTurboHighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit answers for the quiz game.
        pub async fn submit_quiz_game(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitQuizGameRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitQuizGameResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SubmitQuizGame");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "SubmitQuizGame"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the turbo game leaderboard.
        pub async fn get_turbo_leaderboard(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTurboLeaderboardRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTurboLeaderboardResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetTurboLeaderboard");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetTurboLeaderboard"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit ETH block metadata.
        pub async fn submit_eth_block_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitEthBlockMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitEthBlockMetadataResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SubmitEthBlockMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SubmitEthBlockMetadata"));
            self.inner.unary(req, path, codec).await
        }
        /// Get ETH block requests that meet the filter criteria.
        pub async fn get_filtered_eth_block_requests(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredEthBlockRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredEthBlockRequestsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredEthBlockRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredEthBlockRequests"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the 2048 game high score.
        pub async fn set2048_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::Set2048HighScoreRequest>,
        ) -> std::result::Result<tonic::Response<super::Set2048HighScoreResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/Set2048HighScore");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "Set2048HighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Check if address or social identity is whitelisted.
        pub async fn get_whitelist_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetWhitelistStatusRequest>,
        ) -> std::result::Result<tonic::Response<super::GetWhitelistStatusResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetWhitelistStatus");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetWhitelistStatus"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the gpu delegate.
        pub async fn set_gpu_delegate(
            &mut self,
            request: impl tonic::IntoRequest<super::SetGpuDelegateRequest>,
        ) -> std::result::Result<tonic::Response<super::SetGpuDelegateResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetGpuDelegate");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "SetGpuDelegate"));
            self.inner.unary(req, path, codec).await
        }
        /// Claim a gpu.
        pub async fn claim_gpu(
            &mut self,
            request: impl tonic::IntoRequest<super::ClaimGpuRequest>,
        ) -> std::result::Result<tonic::Response<super::ClaimGpuResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/ClaimGpu");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "ClaimGpu"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the gpu variant.
        pub async fn set_gpu_variant(
            &mut self,
            request: impl tonic::IntoRequest<super::SetGpuVariantRequest>,
        ) -> std::result::Result<tonic::Response<super::SetGpuVariantResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetGpuVariant");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "SetGpuVariant"));
            self.inner.unary(req, path, codec).await
        }
        /// Link a whitelisted twitter account.
        pub async fn link_whitelisted_twitter(
            &mut self,
            request: impl tonic::IntoRequest<super::LinkWhitelistedTwitterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LinkWhitelistedTwitterResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/LinkWhitelistedTwitter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "LinkWhitelistedTwitter"));
            self.inner.unary(req, path, codec).await
        }
        /// Check if the user is whitelisted to use the TEE service.
        pub async fn get_tee_whitelist_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTeeWhitelistStatusRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTeeWhitelistStatusResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetTEEWhitelistStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetTEEWhitelistStatus"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod prover_network_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ProverNetworkServer.
    #[async_trait]
    pub trait ProverNetwork: std::marker::Send + std::marker::Sync + 'static {
        /// Creates a proof request.
        async fn request_proof(
            &self,
            request: tonic::Request<super::RequestProofRequest>,
        ) -> std::result::Result<tonic::Response<super::RequestProofResponse>, tonic::Status>;
        /// Fulfills a proof request. Only callable by the assigned fulfiller.
        async fn fulfill_proof(
            &self,
            request: tonic::Request<super::FulfillProofRequest>,
        ) -> std::result::Result<tonic::Response<super::FulfillProofResponse>, tonic::Status>;
        /// Executes a proof request. Only callable by the execution oracle.
        async fn execute_proof(
            &self,
            request: tonic::Request<super::ExecuteProofRequest>,
        ) -> std::result::Result<tonic::Response<super::ExecuteProofResponse>, tonic::Status>;
        /// Fails fulfillment. Only callable by the assigned fulfiller.
        async fn fail_fulfillment(
            &self,
            request: tonic::Request<super::FailFulfillmentRequest>,
        ) -> std::result::Result<tonic::Response<super::FailFulfillmentResponse>, tonic::Status>;
        /// Fails execution. Only callable by the execution oracle.
        async fn fail_execution(
            &self,
            request: tonic::Request<super::FailExecutionRequest>,
        ) -> std::result::Result<tonic::Response<super::FailExecutionResponse>, tonic::Status>;
        /// Get the status of a proof request.
        async fn get_proof_request_status(
            &self,
            request: tonic::Request<super::GetProofRequestStatusRequest>,
        ) -> std::result::Result<tonic::Response<super::GetProofRequestStatusResponse>, tonic::Status>;
        /// Get the details of a proof request.
        async fn get_proof_request_details(
            &self,
            request: tonic::Request<super::GetProofRequestDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProofRequestDetailsResponse>,
            tonic::Status,
        >;
        /// Get the proof requests that meet the filter criteria.
        async fn get_filtered_proof_requests(
            &self,
            request: tonic::Request<super::GetFilteredProofRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredProofRequestsResponse>,
            tonic::Status,
        >;
        /// Search for proof requests, programs, and requesters.
        async fn get_search_results(
            &self,
            request: tonic::Request<super::GetSearchResultsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSearchResultsResponse>, tonic::Status>;
        /// Get metrics for proof requests.
        async fn get_proof_request_metrics(
            &self,
            request: tonic::Request<super::GetProofRequestMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProofRequestMetricsResponse>,
            tonic::Status,
        >;
        /// Get time series data for proof requests.
        async fn get_proof_request_graph(
            &self,
            request: tonic::Request<super::GetProofRequestGraphRequest>,
        ) -> std::result::Result<tonic::Response<super::GetProofRequestGraphResponse>, tonic::Status>;
        /// Get analytics graphs for proof requests.
        async fn get_analytics_graphs(
            &self,
            request: tonic::Request<super::GetAnalyticsGraphsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAnalyticsGraphsResponse>, tonic::Status>;
        /// Get the nonce of the account.
        async fn get_nonce(
            &self,
            request: tonic::Request<super::GetNonceRequest>,
        ) -> std::result::Result<tonic::Response<super::GetNonceResponse>, tonic::Status>;
        /// Get the delegations of the account.
        async fn get_filtered_delegations(
            &self,
            request: tonic::Request<super::GetFilteredDelegationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredDelegationsResponse>,
            tonic::Status,
        >;
        /// Add a delegation. Only callable by the owner of an account.
        async fn add_delegation(
            &self,
            request: tonic::Request<super::AddDelegationRequest>,
        ) -> std::result::Result<tonic::Response<super::AddDelegationResponse>, tonic::Status>;
        /// Remove a delegation. Only callable by the owner of an account.
        async fn remove_delegation(
            &self,
            request: tonic::Request<super::RemoveDelegationRequest>,
        ) -> std::result::Result<tonic::Response<super::RemoveDelegationResponse>, tonic::Status>;
        /// Terminate a delegation. Only callable by the delegate of a delegation.
        async fn terminate_delegation(
            &self,
            request: tonic::Request<super::TerminateDelegationRequest>,
        ) -> std::result::Result<tonic::Response<super::TerminateDelegationResponse>, tonic::Status>;
        /// Accept a delegation. Only callable by the delegate of a delegation.
        async fn accept_delegation(
            &self,
            request: tonic::Request<super::AcceptDelegationRequest>,
        ) -> std::result::Result<tonic::Response<super::AcceptDelegationResponse>, tonic::Status>;
        /// Set the name of the account. Only callable by the owner of an account.
        async fn set_account_name(
            &self,
            request: tonic::Request<super::SetAccountNameRequest>,
        ) -> std::result::Result<tonic::Response<super::SetAccountNameResponse>, tonic::Status>;
        /// Get the name of the account.
        async fn get_account_name(
            &self,
            request: tonic::Request<super::GetAccountNameRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAccountNameResponse>, tonic::Status>;
        /// Get whether the account has signed the terms.
        async fn get_terms_signature(
            &self,
            request: tonic::Request<super::GetTermsSignatureRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTermsSignatureResponse>, tonic::Status>;
        /// Set whether the account has signed the terms.
        async fn set_terms_signature(
            &self,
            request: tonic::Request<super::SetTermsSignatureRequest>,
        ) -> std::result::Result<tonic::Response<super::SetTermsSignatureResponse>, tonic::Status>;
        /// Get all the information about an account.
        async fn get_account(
            &self,
            request: tonic::Request<super::GetAccountRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAccountResponse>, tonic::Status>;
        /// Get metadata about a program.
        async fn get_program(
            &self,
            request: tonic::Request<super::GetProgramRequest>,
        ) -> std::result::Result<tonic::Response<super::GetProgramResponse>, tonic::Status>;
        /// Create a new program. Must be called before requesting proofs.
        async fn create_program(
            &self,
            request: tonic::Request<super::CreateProgramRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateProgramResponse>, tonic::Status>;
        /// Set the name of the program. Only callable by the owner.
        async fn set_program_name(
            &self,
            request: tonic::Request<super::SetProgramNameRequest>,
        ) -> std::result::Result<tonic::Response<super::SetProgramNameResponse>, tonic::Status>;
        /// Get the available balance of an account.
        async fn get_balance(
            &self,
            request: tonic::Request<super::GetBalanceRequest>,
        ) -> std::result::Result<tonic::Response<super::GetBalanceResponse>, tonic::Status>;
        /// Get the balance logs that meet the filter criteria.
        async fn get_filtered_balance_logs(
            &self,
            request: tonic::Request<super::GetFilteredBalanceLogsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredBalanceLogsResponse>,
            tonic::Status,
        >;
        /// Add credit to an account.
        async fn add_credit(
            &self,
            request: tonic::Request<super::AddCreditRequest>,
        ) -> std::result::Result<tonic::Response<super::AddCreditResponse>, tonic::Status>;
        /// Get the latest processed block in the bridge.
        async fn get_latest_bridge_block(
            &self,
            request: tonic::Request<super::GetLatestBridgeBlockRequest>,
        ) -> std::result::Result<tonic::Response<super::GetLatestBridgeBlockResponse>, tonic::Status>;
        /// Get the gas price estimate for a given fulfillment strategy.
        async fn get_gas_price_estimate(
            &self,
            request: tonic::Request<super::GetGasPriceEstimateRequest>,
        ) -> std::result::Result<tonic::Response<super::GetGasPriceEstimateResponse>, tonic::Status>;
        /// Get the details of a transaction.
        async fn get_transaction_details(
            &self,
            request: tonic::Request<super::GetTransactionDetailsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTransactionDetailsResponse>, tonic::Status>;
        /// Get the reservations that meet the filter criteria.
        async fn get_filtered_reservations(
            &self,
            request: tonic::Request<super::GetFilteredReservationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredReservationsResponse>,
            tonic::Status,
        >;
        /// Add a reservation for a requester.
        async fn add_reservation(
            &self,
            request: tonic::Request<super::AddReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::AddReservationResponse>, tonic::Status>;
        /// Remove a reservation for a requester.
        async fn remove_reservation(
            &self,
            request: tonic::Request<super::RemoveReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::RemoveReservationResponse>, tonic::Status>;
        /// Bid for a proof request. Provers that want to be assigned this request must first
        /// bid on it.
        async fn bid(
            &self,
            request: tonic::Request<super::BidRequest>,
        ) -> std::result::Result<tonic::Response<super::BidResponse>, tonic::Status>;
        /// Settle the bids on a proof request to choose the assigned prover. Only callable by
        /// the approved settler.
        async fn settle(
            &self,
            request: tonic::Request<super::SettleRequest>,
        ) -> std::result::Result<tonic::Response<super::SettleResponse>, tonic::Status>;
        /// Sign in with Ethereum
        async fn sign_in(
            &self,
            request: tonic::Request<super::SignInRequest>,
        ) -> std::result::Result<tonic::Response<super::SignInResponse>, tonic::Status>;
        /// Get the accounts that meet the filter criteria.
        async fn get_onboarded_accounts_count(
            &self,
            request: tonic::Request<super::GetOnboardedAccountsCountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetOnboardedAccountsCountResponse>,
            tonic::Status,
        >;
        /// Get the accounts that have joined the leaderboard.
        async fn get_filtered_onboarded_accounts(
            &self,
            request: tonic::Request<super::GetFilteredOnboardedAccountsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredOnboardedAccountsResponse>,
            tonic::Status,
        >;
        /// Get the leaderboard.
        async fn get_leaderboard(
            &self,
            request: tonic::Request<super::GetLeaderboardRequest>,
        ) -> std::result::Result<tonic::Response<super::GetLeaderboardResponse>, tonic::Status>;
        /// Get the leaderboard stats for a given account.
        async fn get_leaderboard_stats(
            &self,
            request: tonic::Request<super::GetLeaderboardStatsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetLeaderboardStatsResponse>, tonic::Status>;
        /// Get codes.
        async fn get_codes(
            &self,
            request: tonic::Request<super::GetCodesRequest>,
        ) -> std::result::Result<tonic::Response<super::GetCodesResponse>, tonic::Status>;
        /// Redeem a code.
        async fn redeem_code(
            &self,
            request: tonic::Request<super::RedeemCodeRequest>,
        ) -> std::result::Result<tonic::Response<super::RedeemCodeResponse>, tonic::Status>;
        /// Connect a Twitter account.
        async fn connect_twitter(
            &self,
            request: tonic::Request<super::ConnectTwitterRequest>,
        ) -> std::result::Result<tonic::Response<super::ConnectTwitterResponse>, tonic::Status>;
        /// Complete onboarding.
        async fn complete_onboarding(
            &self,
            request: tonic::Request<super::CompleteOnboardingRequest>,
        ) -> std::result::Result<tonic::Response<super::CompleteOnboardingResponse>, tonic::Status>;
        /// Set if a user should display their Twitter handle.
        async fn set_use_twitter_handle(
            &self,
            request: tonic::Request<super::SetUseTwitterHandleRequest>,
        ) -> std::result::Result<tonic::Response<super::SetUseTwitterHandleResponse>, tonic::Status>;
        /// Set if a user should display their Twitter profile picture.
        async fn set_use_twitter_image(
            &self,
            request: tonic::Request<super::SetUseTwitterImageRequest>,
        ) -> std::result::Result<tonic::Response<super::SetUseTwitterImageResponse>, tonic::Status>;
        /// Request a random proof.
        async fn request_random_proof(
            &self,
            request: tonic::Request<super::RequestRandomProofRequest>,
        ) -> std::result::Result<tonic::Response<super::RequestRandomProofResponse>, tonic::Status>;
        /// Submit answers for the captcha game.
        async fn submit_captcha_game(
            &self,
            request: tonic::Request<super::SubmitCaptchaGameRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitCaptchaGameResponse>, tonic::Status>;
        /// Redeem stars.
        async fn redeem_stars(
            &self,
            request: tonic::Request<super::RedeemStarsRequest>,
        ) -> std::result::Result<tonic::Response<super::RedeemStarsResponse>, tonic::Status>;
        /// Get flappy leaderboard.
        async fn get_flappy_leaderboard(
            &self,
            request: tonic::Request<super::GetFlappyLeaderboardRequest>,
        ) -> std::result::Result<tonic::Response<super::GetFlappyLeaderboardResponse>, tonic::Status>;
        /// Set the turbo game high score.
        async fn set_turbo_high_score(
            &self,
            request: tonic::Request<super::SetTurboHighScoreRequest>,
        ) -> std::result::Result<tonic::Response<super::SetTurboHighScoreResponse>, tonic::Status>;
        /// Submit answers for the quiz game.
        async fn submit_quiz_game(
            &self,
            request: tonic::Request<super::SubmitQuizGameRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitQuizGameResponse>, tonic::Status>;
        /// Get the turbo game leaderboard.
        async fn get_turbo_leaderboard(
            &self,
            request: tonic::Request<super::GetTurboLeaderboardRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTurboLeaderboardResponse>, tonic::Status>;
        /// Submit ETH block metadata.
        async fn submit_eth_block_metadata(
            &self,
            request: tonic::Request<super::SubmitEthBlockMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitEthBlockMetadataResponse>,
            tonic::Status,
        >;
        /// Get ETH block requests that meet the filter criteria.
        async fn get_filtered_eth_block_requests(
            &self,
            request: tonic::Request<super::GetFilteredEthBlockRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredEthBlockRequestsResponse>,
            tonic::Status,
        >;
        /// Set the 2048 game high score.
        async fn set2048_high_score(
            &self,
            request: tonic::Request<super::Set2048HighScoreRequest>,
        ) -> std::result::Result<tonic::Response<super::Set2048HighScoreResponse>, tonic::Status>;
        /// Check if address or social identity is whitelisted.
        async fn get_whitelist_status(
            &self,
            request: tonic::Request<super::GetWhitelistStatusRequest>,
        ) -> std::result::Result<tonic::Response<super::GetWhitelistStatusResponse>, tonic::Status>;
        /// Set the gpu delegate.
        async fn set_gpu_delegate(
            &self,
            request: tonic::Request<super::SetGpuDelegateRequest>,
        ) -> std::result::Result<tonic::Response<super::SetGpuDelegateResponse>, tonic::Status>;
        /// Claim a gpu.
        async fn claim_gpu(
            &self,
            request: tonic::Request<super::ClaimGpuRequest>,
        ) -> std::result::Result<tonic::Response<super::ClaimGpuResponse>, tonic::Status>;
        /// Set the gpu variant.
        async fn set_gpu_variant(
            &self,
            request: tonic::Request<super::SetGpuVariantRequest>,
        ) -> std::result::Result<tonic::Response<super::SetGpuVariantResponse>, tonic::Status>;
        /// Link a whitelisted twitter account.
        async fn link_whitelisted_twitter(
            &self,
            request: tonic::Request<super::LinkWhitelistedTwitterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LinkWhitelistedTwitterResponse>,
            tonic::Status,
        >;
        /// Check if the user is whitelisted to use the TEE service.
        async fn get_tee_whitelist_status(
            &self,
            request: tonic::Request<super::GetTeeWhitelistStatusRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTeeWhitelistStatusResponse>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct ProverNetworkServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ProverNetworkServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ProverNetworkServer<T>
    where
        T: ProverNetwork,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/network.ProverNetwork/RequestProof" => {
                    #[allow(non_camel_case_types)]
                    struct RequestProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::RequestProofRequest>
                        for RequestProofSvc<T>
                    {
                        type Response = super::RequestProofResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RequestProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::request_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RequestProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/FulfillProof" => {
                    #[allow(non_camel_case_types)]
                    struct FulfillProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::FulfillProofRequest>
                        for FulfillProofSvc<T>
                    {
                        type Response = super::FulfillProofResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FulfillProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::fulfill_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FulfillProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ExecuteProof" => {
                    #[allow(non_camel_case_types)]
                    struct ExecuteProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::ExecuteProofRequest>
                        for ExecuteProofSvc<T>
                    {
                        type Response = super::ExecuteProofResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExecuteProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::execute_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecuteProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/FailFulfillment" => {
                    #[allow(non_camel_case_types)]
                    struct FailFulfillmentSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::FailFulfillmentRequest>
                        for FailFulfillmentSvc<T>
                    {
                        type Response = super::FailFulfillmentResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FailFulfillmentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::fail_fulfillment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FailFulfillmentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/FailExecution" => {
                    #[allow(non_camel_case_types)]
                    struct FailExecutionSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::FailExecutionRequest>
                        for FailExecutionSvc<T>
                    {
                        type Response = super::FailExecutionResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FailExecutionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::fail_execution(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FailExecutionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestStatusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetProofRequestStatusRequest>
                        for GetProofRequestStatusSvc<T>
                    {
                        type Response = super::GetProofRequestStatusResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProofRequestStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_status(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestDetails" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestDetailsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetProofRequestDetailsRequest>
                        for GetProofRequestDetailsSvc<T>
                    {
                        type Response = super::GetProofRequestDetailsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProofRequestDetailsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_details(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProofRequests" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProofRequestsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetFilteredProofRequestsRequest>
                        for GetFilteredProofRequestsSvc<T>
                    {
                        type Response = super::GetFilteredProofRequestsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredProofRequestsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_proof_requests(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProofRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetSearchResults" => {
                    #[allow(non_camel_case_types)]
                    struct GetSearchResultsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetSearchResultsRequest>
                        for GetSearchResultsSvc<T>
                    {
                        type Response = super::GetSearchResultsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSearchResultsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_search_results(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSearchResultsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestMetricsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetProofRequestMetricsRequest>
                        for GetProofRequestMetricsSvc<T>
                    {
                        type Response = super::GetProofRequestMetricsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProofRequestMetricsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_metrics(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestGraph" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestGraphSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetProofRequestGraphRequest>
                        for GetProofRequestGraphSvc<T>
                    {
                        type Response = super::GetProofRequestGraphResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProofRequestGraphRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_graph(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestGraphSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetAnalyticsGraphs" => {
                    #[allow(non_camel_case_types)]
                    struct GetAnalyticsGraphsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetAnalyticsGraphsRequest>
                        for GetAnalyticsGraphsSvc<T>
                    {
                        type Response = super::GetAnalyticsGraphsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAnalyticsGraphsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_analytics_graphs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAnalyticsGraphsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetNonce" => {
                    #[allow(non_camel_case_types)]
                    struct GetNonceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::GetNonceRequest> for GetNonceSvc<T> {
                        type Response = super::GetNonceResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetNonceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_nonce(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetNonceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredDelegations" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredDelegationsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetFilteredDelegationsRequest>
                        for GetFilteredDelegationsSvc<T>
                    {
                        type Response = super::GetFilteredDelegationsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredDelegationsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_delegations(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredDelegationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AddDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct AddDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::AddDelegationRequest>
                        for AddDelegationSvc<T>
                    {
                        type Response = super::AddDelegationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddDelegationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::add_delegation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RemoveDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::RemoveDelegationRequest>
                        for RemoveDelegationSvc<T>
                    {
                        type Response = super::RemoveDelegationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RemoveDelegationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::remove_delegation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/TerminateDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct TerminateDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::TerminateDelegationRequest>
                        for TerminateDelegationSvc<T>
                    {
                        type Response = super::TerminateDelegationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TerminateDelegationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::terminate_delegation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TerminateDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AcceptDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct AcceptDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::AcceptDelegationRequest>
                        for AcceptDelegationSvc<T>
                    {
                        type Response = super::AcceptDelegationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AcceptDelegationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::accept_delegation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AcceptDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetAccountName" => {
                    #[allow(non_camel_case_types)]
                    struct SetAccountNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::SetAccountNameRequest>
                        for SetAccountNameSvc<T>
                    {
                        type Response = super::SetAccountNameResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetAccountNameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_account_name(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetAccountNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetAccountName" => {
                    #[allow(non_camel_case_types)]
                    struct GetAccountNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::GetAccountNameRequest>
                        for GetAccountNameSvc<T>
                    {
                        type Response = super::GetAccountNameResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAccountNameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_account_name(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAccountNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTermsSignature" => {
                    #[allow(non_camel_case_types)]
                    struct GetTermsSignatureSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetTermsSignatureRequest>
                        for GetTermsSignatureSvc<T>
                    {
                        type Response = super::GetTermsSignatureResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTermsSignatureRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_terms_signature(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTermsSignatureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetTermsSignature" => {
                    #[allow(non_camel_case_types)]
                    struct SetTermsSignatureSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::SetTermsSignatureRequest>
                        for SetTermsSignatureSvc<T>
                    {
                        type Response = super::SetTermsSignatureResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetTermsSignatureRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_terms_signature(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetTermsSignatureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetAccount" => {
                    #[allow(non_camel_case_types)]
                    struct GetAccountSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::GetAccountRequest> for GetAccountSvc<T> {
                        type Response = super::GetAccountResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAccountRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_account(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAccountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProgram" => {
                    #[allow(non_camel_case_types)]
                    struct GetProgramSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::GetProgramRequest> for GetProgramSvc<T> {
                        type Response = super::GetProgramResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProgramRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_program(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProgramSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/CreateProgram" => {
                    #[allow(non_camel_case_types)]
                    struct CreateProgramSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::CreateProgramRequest>
                        for CreateProgramSvc<T>
                    {
                        type Response = super::CreateProgramResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateProgramRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::create_program(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateProgramSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetProgramName" => {
                    #[allow(non_camel_case_types)]
                    struct SetProgramNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::SetProgramNameRequest>
                        for SetProgramNameSvc<T>
                    {
                        type Response = super::SetProgramNameResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetProgramNameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_program_name(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetProgramNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetBalance" => {
                    #[allow(non_camel_case_types)]
                    struct GetBalanceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::GetBalanceRequest> for GetBalanceSvc<T> {
                        type Response = super::GetBalanceResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBalanceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_balance(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBalanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredBalanceLogs" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredBalanceLogsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetFilteredBalanceLogsRequest>
                        for GetFilteredBalanceLogsSvc<T>
                    {
                        type Response = super::GetFilteredBalanceLogsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredBalanceLogsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_balance_logs(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredBalanceLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AddCredit" => {
                    #[allow(non_camel_case_types)]
                    struct AddCreditSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::AddCreditRequest> for AddCreditSvc<T> {
                        type Response = super::AddCreditResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddCreditRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::add_credit(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddCreditSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLatestBridgeBlock" => {
                    #[allow(non_camel_case_types)]
                    struct GetLatestBridgeBlockSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetLatestBridgeBlockRequest>
                        for GetLatestBridgeBlockSvc<T>
                    {
                        type Response = super::GetLatestBridgeBlockResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetLatestBridgeBlockRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_latest_bridge_block(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLatestBridgeBlockSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetGasPriceEstimate" => {
                    #[allow(non_camel_case_types)]
                    struct GetGasPriceEstimateSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetGasPriceEstimateRequest>
                        for GetGasPriceEstimateSvc<T>
                    {
                        type Response = super::GetGasPriceEstimateResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetGasPriceEstimateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_gas_price_estimate(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetGasPriceEstimateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTransactionDetails" => {
                    #[allow(non_camel_case_types)]
                    struct GetTransactionDetailsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetTransactionDetailsRequest>
                        for GetTransactionDetailsSvc<T>
                    {
                        type Response = super::GetTransactionDetailsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTransactionDetailsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_transaction_details(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTransactionDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredReservations" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredReservationsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetFilteredReservationsRequest>
                        for GetFilteredReservationsSvc<T>
                    {
                        type Response = super::GetFilteredReservationsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredReservationsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_reservations(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredReservationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AddReservation" => {
                    #[allow(non_camel_case_types)]
                    struct AddReservationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::AddReservationRequest>
                        for AddReservationSvc<T>
                    {
                        type Response = super::AddReservationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddReservationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::add_reservation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddReservationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RemoveReservation" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveReservationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::RemoveReservationRequest>
                        for RemoveReservationSvc<T>
                    {
                        type Response = super::RemoveReservationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RemoveReservationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::remove_reservation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveReservationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Bid" => {
                    #[allow(non_camel_case_types)]
                    struct BidSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::BidRequest> for BidSvc<T> {
                        type Response = super::BidResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as ProverNetwork>::bid(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Settle" => {
                    #[allow(non_camel_case_types)]
                    struct SettleSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::SettleRequest> for SettleSvc<T> {
                        type Response = super::SettleResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SettleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as ProverNetwork>::settle(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SettleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SignIn" => {
                    #[allow(non_camel_case_types)]
                    struct SignInSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::SignInRequest> for SignInSvc<T> {
                        type Response = super::SignInResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SignInRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as ProverNetwork>::sign_in(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SignInSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetOnboardedAccountsCount" => {
                    #[allow(non_camel_case_types)]
                    struct GetOnboardedAccountsCountSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetOnboardedAccountsCountRequest>
                        for GetOnboardedAccountsCountSvc<T>
                    {
                        type Response = super::GetOnboardedAccountsCountResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetOnboardedAccountsCountRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_onboarded_accounts_count(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOnboardedAccountsCountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredOnboardedAccounts" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredOnboardedAccountsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetFilteredOnboardedAccountsRequest>
                        for GetFilteredOnboardedAccountsSvc<T>
                    {
                        type Response = super::GetFilteredOnboardedAccountsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredOnboardedAccountsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_onboarded_accounts(
                                    &inner, request,
                                )
                                .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredOnboardedAccountsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLeaderboard" => {
                    #[allow(non_camel_case_types)]
                    struct GetLeaderboardSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::GetLeaderboardRequest>
                        for GetLeaderboardSvc<T>
                    {
                        type Response = super::GetLeaderboardResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetLeaderboardRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_leaderboard(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLeaderboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLeaderboardStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetLeaderboardStatsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetLeaderboardStatsRequest>
                        for GetLeaderboardStatsSvc<T>
                    {
                        type Response = super::GetLeaderboardStatsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetLeaderboardStatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_leaderboard_stats(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLeaderboardStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetCodes" => {
                    #[allow(non_camel_case_types)]
                    struct GetCodesSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::GetCodesRequest> for GetCodesSvc<T> {
                        type Response = super::GetCodesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCodesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_codes(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCodesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RedeemCode" => {
                    #[allow(non_camel_case_types)]
                    struct RedeemCodeSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::RedeemCodeRequest> for RedeemCodeSvc<T> {
                        type Response = super::RedeemCodeResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RedeemCodeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::redeem_code(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RedeemCodeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ConnectTwitter" => {
                    #[allow(non_camel_case_types)]
                    struct ConnectTwitterSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::ConnectTwitterRequest>
                        for ConnectTwitterSvc<T>
                    {
                        type Response = super::ConnectTwitterResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ConnectTwitterRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::connect_twitter(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConnectTwitterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/CompleteOnboarding" => {
                    #[allow(non_camel_case_types)]
                    struct CompleteOnboardingSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::CompleteOnboardingRequest>
                        for CompleteOnboardingSvc<T>
                    {
                        type Response = super::CompleteOnboardingResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CompleteOnboardingRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::complete_onboarding(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CompleteOnboardingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetUseTwitterHandle" => {
                    #[allow(non_camel_case_types)]
                    struct SetUseTwitterHandleSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::SetUseTwitterHandleRequest>
                        for SetUseTwitterHandleSvc<T>
                    {
                        type Response = super::SetUseTwitterHandleResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetUseTwitterHandleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_use_twitter_handle(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetUseTwitterHandleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetUseTwitterImage" => {
                    #[allow(non_camel_case_types)]
                    struct SetUseTwitterImageSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::SetUseTwitterImageRequest>
                        for SetUseTwitterImageSvc<T>
                    {
                        type Response = super::SetUseTwitterImageResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetUseTwitterImageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_use_twitter_image(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetUseTwitterImageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RequestRandomProof" => {
                    #[allow(non_camel_case_types)]
                    struct RequestRandomProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::RequestRandomProofRequest>
                        for RequestRandomProofSvc<T>
                    {
                        type Response = super::RequestRandomProofResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RequestRandomProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::request_random_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RequestRandomProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SubmitCaptchaGame" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitCaptchaGameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::SubmitCaptchaGameRequest>
                        for SubmitCaptchaGameSvc<T>
                    {
                        type Response = super::SubmitCaptchaGameResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubmitCaptchaGameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::submit_captcha_game(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitCaptchaGameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RedeemStars" => {
                    #[allow(non_camel_case_types)]
                    struct RedeemStarsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::RedeemStarsRequest>
                        for RedeemStarsSvc<T>
                    {
                        type Response = super::RedeemStarsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RedeemStarsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::redeem_stars(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RedeemStarsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFlappyLeaderboard" => {
                    #[allow(non_camel_case_types)]
                    struct GetFlappyLeaderboardSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetFlappyLeaderboardRequest>
                        for GetFlappyLeaderboardSvc<T>
                    {
                        type Response = super::GetFlappyLeaderboardResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFlappyLeaderboardRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_flappy_leaderboard(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFlappyLeaderboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetTurboHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetTurboHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::SetTurboHighScoreRequest>
                        for SetTurboHighScoreSvc<T>
                    {
                        type Response = super::SetTurboHighScoreResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetTurboHighScoreRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_turbo_high_score(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetTurboHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SubmitQuizGame" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitQuizGameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::SubmitQuizGameRequest>
                        for SubmitQuizGameSvc<T>
                    {
                        type Response = super::SubmitQuizGameResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubmitQuizGameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::submit_quiz_game(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitQuizGameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTurboLeaderboard" => {
                    #[allow(non_camel_case_types)]
                    struct GetTurboLeaderboardSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetTurboLeaderboardRequest>
                        for GetTurboLeaderboardSvc<T>
                    {
                        type Response = super::GetTurboLeaderboardResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTurboLeaderboardRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_turbo_leaderboard(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTurboLeaderboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SubmitEthBlockMetadata" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitEthBlockMetadataSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::SubmitEthBlockMetadataRequest>
                        for SubmitEthBlockMetadataSvc<T>
                    {
                        type Response = super::SubmitEthBlockMetadataResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubmitEthBlockMetadataRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::submit_eth_block_metadata(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitEthBlockMetadataSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredEthBlockRequests" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredEthBlockRequestsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetFilteredEthBlockRequestsRequest>
                        for GetFilteredEthBlockRequestsSvc<T>
                    {
                        type Response = super::GetFilteredEthBlockRequestsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredEthBlockRequestsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_eth_block_requests(
                                    &inner, request,
                                )
                                .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredEthBlockRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Set2048HighScore" => {
                    #[allow(non_camel_case_types)]
                    struct Set2048HighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::Set2048HighScoreRequest>
                        for Set2048HighScoreSvc<T>
                    {
                        type Response = super::Set2048HighScoreResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::Set2048HighScoreRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set2048_high_score(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = Set2048HighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetWhitelistStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetWhitelistStatusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetWhitelistStatusRequest>
                        for GetWhitelistStatusSvc<T>
                    {
                        type Response = super::GetWhitelistStatusResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetWhitelistStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_whitelist_status(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetWhitelistStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetGpuDelegate" => {
                    #[allow(non_camel_case_types)]
                    struct SetGpuDelegateSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::SetGpuDelegateRequest>
                        for SetGpuDelegateSvc<T>
                    {
                        type Response = super::SetGpuDelegateResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetGpuDelegateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_gpu_delegate(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetGpuDelegateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ClaimGpu" => {
                    #[allow(non_camel_case_types)]
                    struct ClaimGpuSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::ClaimGpuRequest> for ClaimGpuSvc<T> {
                        type Response = super::ClaimGpuResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ClaimGpuRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::claim_gpu(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ClaimGpuSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetGpuVariant" => {
                    #[allow(non_camel_case_types)]
                    struct SetGpuVariantSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::SetGpuVariantRequest>
                        for SetGpuVariantSvc<T>
                    {
                        type Response = super::SetGpuVariantResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetGpuVariantRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_gpu_variant(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetGpuVariantSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/LinkWhitelistedTwitter" => {
                    #[allow(non_camel_case_types)]
                    struct LinkWhitelistedTwitterSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::LinkWhitelistedTwitterRequest>
                        for LinkWhitelistedTwitterSvc<T>
                    {
                        type Response = super::LinkWhitelistedTwitterResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LinkWhitelistedTwitterRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::link_whitelisted_twitter(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkWhitelistedTwitterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTEEWhitelistStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetTEEWhitelistStatusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetTeeWhitelistStatusRequest>
                        for GetTEEWhitelistStatusSvc<T>
                    {
                        type Response = super::GetTeeWhitelistStatusResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTeeWhitelistStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_tee_whitelist_status(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTEEWhitelistStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", tonic::Code::Unimplemented as i32)
                        .header(http::header::CONTENT_TYPE, tonic::metadata::GRPC_CONTENT_TYPE)
                        .body(empty_body())
                        .unwrap())
                }),
            }
        }
    }
    impl<T> Clone for ProverNetworkServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "network.ProverNetwork";
    impl<T> tonic::server::NamedService for ProverNetworkServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
