// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RequestProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RequestProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RequestProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The version of the prover to use.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// The mode for the request.
    #[prost(enumeration = "ProofMode", tag = "4")]
    pub mode: i32,
    /// The strategy for fulfiller assignment.
    #[prost(enumeration = "FulfillmentStrategy", tag = "5")]
    pub strategy: i32,
    /// The stdin resource identifier.
    #[prost(string, tag = "6")]
    pub stdin_uri: ::prost::alloc::string::String,
    /// The deadline for the request.
    #[prost(uint64, tag = "7")]
    pub deadline: u64,
    /// The cycle limit for the request.
    #[prost(uint64, tag = "8")]
    pub cycle_limit: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RequestProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RequestProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RequestProofResponseBody {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FulfillProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<FulfillProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FulfillProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The proof bytes.
    #[prost(bytes = "vec", tag = "3")]
    pub proof: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FulfillProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<FulfillProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct FulfillProofResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ExecuteProofRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<ExecuteProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ExecuteProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "3")]
    pub execution_status: i32,
    /// The optional public values hash of the request execution, only included if
    /// the request is valid.
    #[prost(bytes = "vec", optional, tag = "4")]
    pub public_values_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional cycles used when executing the request, only included if the
    /// request is valid.
    #[prost(uint64, optional, tag = "5")]
    pub cycles: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ExecuteProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<ExecuteProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExecuteProofResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FailFulfillmentRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<FailFulfillmentRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FailFulfillmentRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FailFulfillmentResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<FailFulfillmentResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct FailFulfillmentResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FailExecutionRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<FailExecutionRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FailExecutionRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FailExecutionResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<FailExecutionResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct FailExecutionResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ProofRequest {
    /// The request identifier.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The version of the prover to use.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// The mode for the proof.
    #[prost(enumeration = "ProofMode", tag = "4")]
    pub mode: i32,
    /// The strategy for fulfiller assignment.
    #[prost(enumeration = "FulfillmentStrategy", tag = "5")]
    pub strategy: i32,
    /// The program resource identifier.
    #[prost(string, tag = "6")]
    pub program_uri: ::prost::alloc::string::String,
    /// The stdin resource identifier.
    #[prost(string, tag = "7")]
    pub stdin_uri: ::prost::alloc::string::String,
    /// The deadline for the request.
    #[prost(uint64, tag = "8")]
    pub deadline: u64,
    /// The cycle limit for the request.
    #[prost(uint64, tag = "9")]
    pub cycle_limit: u64,
    /// The gas price for the request.
    #[prost(uint64, optional, tag = "10")]
    pub gas_price: ::core::option::Option<u64>,
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "11")]
    pub fulfillment_status: i32,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "12")]
    pub execution_status: i32,
    /// The requester address that signed the request.
    #[prost(bytes = "vec", tag = "13")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
    /// The fulfiller address that fulfilled the request.
    #[prost(bytes = "vec", optional, tag = "14")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional name to refer to an alias of the program id.
    #[prost(string, optional, tag = "15")]
    pub program_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the requester address.
    #[prost(string, optional, tag = "16")]
    pub requester_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "17")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the request was created.
    #[prost(uint64, tag = "18")]
    pub created_at: u64,
    /// The unix timestamp of when the request was updated.
    #[prost(uint64, tag = "19")]
    pub updated_at: u64,
    /// The unix timestamp of when the request was fulfilled.
    #[prost(uint64, optional, tag = "20")]
    pub fulfilled_at: ::core::option::Option<u64>,
    /// The transaction hash of the request.
    #[prost(bytes = "vec", tag = "21")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The cycle count for the request.
    #[prost(uint64, optional, tag = "22")]
    pub cycles: ::core::option::Option<u64>,
    /// The amount deducted from the fulfiller's balance.
    #[prost(string, optional, tag = "23")]
    pub deduction_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// The amount refunded to the fulfiller's balance.
    #[prost(string, optional, tag = "24")]
    pub refund_amount: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestStatusRequest {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestStatusResponse {
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "1")]
    pub fulfillment_status: i32,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "2")]
    pub execution_status: i32,
    /// The transaction hash of the request.
    #[prost(bytes = "vec", tag = "3")]
    pub request_tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The optional transaction hash of the proof fulfill. Only included if the
    /// request has a fulfillment status of FULFILLED.
    #[prost(bytes = "vec", optional, tag = "4")]
    pub fulfill_tx_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional proof URI, where you can download the result of the request.
    /// Only included if the request has a fulfillment status of FULFILLED.
    #[prost(string, optional, tag = "5")]
    pub proof_uri: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestDetailsRequest {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestDetailsResponse {
    /// The detailed request.
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<ProofRequest>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProofRequestsRequest {
    /// The optional version of the requests to filter for.
    #[prost(string, optional, tag = "1")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional fulfillment status of the requests to filter for.
    #[prost(enumeration = "FulfillmentStatus", optional, tag = "2")]
    pub fulfillment_status: ::core::option::Option<i32>,
    /// The optional execution status of the requests to filter for.
    #[prost(enumeration = "ExecutionStatus", optional, tag = "3")]
    pub execution_status: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp deadline of the requests to filter for.
    /// Only returns requests with deadlines after this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub minimum_deadline: ::core::option::Option<u64>,
    /// The optional verification key hash of the program to filter for.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub vk_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional requester address to filter for.
    #[prost(bytes = "vec", optional, tag = "6")]
    pub requester: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional fulfiller address to filter for.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub fulfiller: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional minimum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "8")]
    pub from: ::core::option::Option<u64>,
    /// The optional maximum creation unix timestamp of the requests to filter for.
    #[prost(uint64, optional, tag = "9")]
    pub to: ::core::option::Option<u64>,
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "10")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "11")]
    pub page: ::core::option::Option<u32>,
    /// The optional mode of the requests to filter for.
    #[prost(enumeration = "ProofMode", optional, tag = "12")]
    pub mode: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredProofRequestsResponse {
    /// The requests that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<ProofRequest>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetSearchResultsRequest {
    /// The search query string.
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SearchResult {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetSearchResultsResponse {
    /// List of matching request IDs with optional names.
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<SearchResult>,
    /// List of matching program IDs with optional names.
    #[prost(message, repeated, tag = "2")]
    pub programs: ::prost::alloc::vec::Vec<SearchResult>,
    /// List of matching requester IDs with optional names.
    #[prost(message, repeated, tag = "3")]
    pub requesters: ::prost::alloc::vec::Vec<SearchResult>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestMetricsRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional interval in days for volume calculation.
    #[prost(uint64, optional, tag = "2")]
    pub volume_interval_days: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetProofRequestMetricsResponse {
    /// The total number of proofs.
    #[prost(uint64, tag = "1")]
    pub total_proofs: u64,
    /// The total number of cycles.
    #[prost(uint64, tag = "2")]
    pub total_cycles: u64,
    /// The volume in the specified interval.
    #[prost(uint64, tag = "3")]
    pub volume: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestGraphRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional interval in days for the graph range.
    #[prost(uint64, optional, tag = "2")]
    pub range_interval_days: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GraphData {
    /// The timestamp of the data point.
    #[prost(string, tag = "1")]
    pub timestamp: ::prost::alloc::string::String,
    /// The value at this timestamp.
    #[prost(uint64, tag = "2")]
    pub value: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestGraphResponse {
    /// The time series data points.
    #[prost(message, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<GraphData>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetAnalyticsGraphsRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional interval in days for the graph range.
    #[prost(uint64, optional, tag = "2")]
    pub range_interval_days: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetAnalyticsGraphsResponse {
    /// The time series data points for proof count.
    #[prost(message, repeated, tag = "1")]
    pub proofs: ::prost::alloc::vec::Vec<GraphData>,
    /// The time series data points for program count.
    #[prost(message, repeated, tag = "2")]
    pub programs: ::prost::alloc::vec::Vec<GraphData>,
    /// The time series data points for cycle count.
    #[prost(message, repeated, tag = "3")]
    pub cycles: ::prost::alloc::vec::Vec<GraphData>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetNonceRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetNonceResponse {
    /// The nonce of the account.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct Delegation {
    /// The address of the owner.
    #[prost(bytes = "vec", tag = "1")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    /// The address of the delegate (the account with granted permissions).
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
    /// Whether the delegation has been accepted.
    #[prost(bool, tag = "3")]
    pub accepted: bool,
    /// The unix timestamp of when the delegation was created.
    #[prost(uint64, tag = "4")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredDelegationsRequest {
    /// The optional owner address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub owner: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional maximum number of requests to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "2")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "3")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredDelegationsResponse {
    /// The delegations that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub delegations: ::prost::alloc::vec::Vec<Delegation>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddDelegationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AddDelegationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddDelegationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The delegate address to add.
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddDelegationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AddDelegationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddDelegationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RemoveDelegationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RemoveDelegationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RemoveDelegationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The delegate address to remove.
    #[prost(bytes = "vec", tag = "2")]
    pub delegate: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RemoveDelegationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RemoveDelegationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveDelegationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AcceptDelegationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AcceptDelegationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AcceptDelegationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the owner who requested the delegation
    #[prost(bytes = "vec", tag = "2")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AcceptDelegationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AcceptDelegationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct AcceptDelegationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetAccountNameRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetAccountNameRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetAccountNameRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the account to update the name of. Only the sender can
    /// update the name unless authorized.
    #[prost(bytes = "vec", tag = "2")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The name of the account. Must be unique.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetAccountNameResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetAccountNameResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetAccountNameResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetAccountNameRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetAccountNameResponse {
    /// The name of the account.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetTermsSignatureRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTermsSignatureResponse {
    /// Whether the account has signed the terms.
    #[prost(bool, tag = "1")]
    pub is_signed: bool,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetTermsSignatureRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the account.
    #[prost(bytes = "vec", tag = "2")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetTermsSignatureResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetTermsSignatureResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct Program {
    /// The verification key hash.
    #[prost(bytes = "vec", tag = "1")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The verification key.
    #[prost(bytes = "vec", tag = "2")]
    pub vk: ::prost::alloc::vec::Vec<u8>,
    /// The program resource identifier.
    #[prost(string, tag = "3")]
    pub program_uri: ::prost::alloc::string::String,
    /// The optional name of the program.
    #[prost(string, optional, tag = "4")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The owner of the program.
    #[prost(bytes = "vec", tag = "5")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    /// The unix timestamp of when the program was created.
    #[prost(uint64, tag = "6")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProgramRequest {
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "1")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProgramResponse {
    /// The program details.
    #[prost(message, optional, tag = "1")]
    pub program: ::core::option::Option<Program>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct CreateProgramRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<CreateProgramRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct CreateProgramRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The verification key hash.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The verification key.
    #[prost(bytes = "vec", tag = "3")]
    pub vk: ::prost::alloc::vec::Vec<u8>,
    /// The program resource identifier.
    #[prost(string, tag = "4")]
    pub program_uri: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct CreateProgramResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<CreateProgramResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateProgramResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetProgramNameRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SetProgramNameRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetProgramNameRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The identifier of the program to update the name of. Only the original
    /// program creator can update the name unless authorized.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The name of the program. Must be unique.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SetProgramNameResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SetProgramNameResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetProgramNameResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceRequest {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceResponse {
    /// The amount of credits owned by the account.
    #[prost(string, tag = "1")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct BalanceLog {
    /// The address of the account.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The type of balance change operation.
    #[prost(enumeration = "BalanceOperation", tag = "2")]
    pub operation: i32,
    /// The amount of the change (can be positive or negative).
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    /// The transaction hash that caused this change.
    #[prost(bytes = "vec", tag = "4")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The unix timestamp of when this change occurred.
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBalanceLogsRequest {
    /// The optional address to filter for.
    #[prost(bytes = "vec", optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional type of operations to filter for.
    #[prost(enumeration = "BalanceOperation", optional, tag = "2")]
    pub operation: ::core::option::Option<i32>,
    /// The optional minimum unix timestamp to filter logs from. Only returns
    /// logs after this timestamp.
    #[prost(uint64, optional, tag = "3")]
    pub minimum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum unix timestamp to filter logs to. Only returns
    /// logs before this timestamp.
    #[prost(uint64, optional, tag = "4")]
    pub maximum_timestamp: ::core::option::Option<u64>,
    /// The optional maximum number of logs to return (default is 10, maximum is 100).
    #[prost(uint32, optional, tag = "5")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "6")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredBalanceLogsResponse {
    /// The balance logs that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub logs: ::prost::alloc::vec::Vec<BalanceLog>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddCreditRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AddCreditRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddCreditRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the account to add credits to.
    #[prost(bytes = "vec", tag = "2")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The amount of credits to add.
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddCreditResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AddCreditResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddCreditResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLatestBridgeBlockRequest {
    /// The chain ID of the bridge.
    #[prost(uint32, tag = "1")]
    pub chain_id: u32,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetLatestBridgeBlockResponse {
    /// The latest processed block in the bridge.
    #[prost(uint64, tag = "1")]
    pub block_number: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGasPriceEstimateRequest {
    #[prost(enumeration = "FulfillmentStrategy", tag = "1")]
    pub strategy: i32,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGasPriceEstimateResponse {
    #[prost(uint64, tag = "1")]
    pub gas_price: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionDetailsRequest {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct TransactionDetails {
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "4")]
    pub nonce: u64,
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
    #[prost(string, optional, tag = "6")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "7")]
    pub request_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionDetailsResponse {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<TransactionDetails>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct Reservation {
    /// The address of the requester.
    #[prost(bytes = "vec", tag = "1")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
    /// The address of the fulfiller.
    #[prost(bytes = "vec", tag = "2")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
    /// The optional name to refer to an alias of the requester address.
    #[prost(string, optional, tag = "3")]
    pub requester_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional name to refer to an alias of the fulfiller address.
    #[prost(string, optional, tag = "4")]
    pub fulfiller_name: ::core::option::Option<::prost::alloc::string::String>,
    /// The unix timestamp of when the reservation was created.
    #[prost(uint64, tag = "5")]
    pub created_at: u64,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFilteredReservationsRequest {
    /// The optional maximum number of reservations to return (default is 10,
    /// maximum is 100).
    #[prost(uint32, optional, tag = "1")]
    pub limit: ::core::option::Option<u32>,
    /// The optional page number to return (default is 1).
    #[prost(uint32, optional, tag = "2")]
    pub page: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetFilteredReservationsResponse {
    /// The reservations that matched the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub reservations: ::prost::alloc::vec::Vec<Reservation>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddReservationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<AddReservationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddReservationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the requester to add reservation for.
    #[prost(bytes = "vec", tag = "2")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
    /// The address of the fulfiller to reserve.
    #[prost(bytes = "vec", tag = "3")]
    pub fulfiller: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct AddReservationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AddReservationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddReservationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RemoveReservationRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<RemoveReservationRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RemoveReservationRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The address of the requester to remove reservation for.
    #[prost(bytes = "vec", tag = "2")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RemoveReservationResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RemoveReservationResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveReservationResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct BidRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<BidRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct BidRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The request ID to bid on.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct BidResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<BidResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct BidResponseBody {}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SettleRequest {
    /// The message format of the body.
    #[prost(enumeration = "MessageFormat", tag = "1")]
    pub format: i32,
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<SettleRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SettleRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The request ID to settle bids for.
    #[prost(bytes = "vec", tag = "2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SettleResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<SettleResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SettleResponseBody {}
/// Format to help decode signature in backend.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum MessageFormat {
    /// Unspecified message format.
    UnspecifiedMessageFormat = 0,
    /// The message is in binary format.
    Binary = 1,
    /// The message is in JSON format.
    Json = 2,
}
impl MessageFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedMessageFormat => "UNSPECIFIED_MESSAGE_FORMAT",
            Self::Binary => "BINARY",
            Self::Json => "JSON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_MESSAGE_FORMAT" => Some(Self::UnspecifiedMessageFormat),
            "BINARY" => Some(Self::Binary),
            "JSON" => Some(Self::Json),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ProofMode {
    UnspecifiedProofMode = 0,
    /// The core proof mode.
    Core = 1,
    /// The compressed proof mode.
    Compressed = 2,
    /// The plonk proof mode.
    Plonk = 3,
    /// The groth16 proof mode.
    Groth16 = 4,
}
impl ProofMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedProofMode => "UNSPECIFIED_PROOF_MODE",
            Self::Core => "CORE",
            Self::Compressed => "COMPRESSED",
            Self::Plonk => "PLONK",
            Self::Groth16 => "GROTH16",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_PROOF_MODE" => Some(Self::UnspecifiedProofMode),
            "CORE" => Some(Self::Core),
            "COMPRESSED" => Some(Self::Compressed),
            "PLONK" => Some(Self::Plonk),
            "GROTH16" => Some(Self::Groth16),
            _ => None,
        }
    }
}
/// The different strategies that can be used for fulfilling requests.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum FulfillmentStrategy {
    UnspecifiedFulfillmentStrategy = 0,
    /// The hosted fulfillment strategy. Uses Succinct's on-demand prover to fulfill requests.
    Hosted = 1,
    /// The reserved fulfillment strategy. Uses an already existing agreement with a
    /// fulfiller to fulfill requests.
    Reserved = 2,
    /// The auction fulfillment strategy. Uses a decentralized proof contest to
    /// fulfill requests.
    Auction = 3,
}
impl FulfillmentStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedFulfillmentStrategy => "UNSPECIFIED_FULFILLMENT_STRATEGY",
            Self::Hosted => "HOSTED",
            Self::Reserved => "RESERVED",
            Self::Auction => "AUCTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_FULFILLMENT_STRATEGY" => Some(Self::UnspecifiedFulfillmentStrategy),
            "HOSTED" => Some(Self::Hosted),
            "RESERVED" => Some(Self::Reserved),
            "AUCTION" => Some(Self::Auction),
            _ => None,
        }
    }
}
/// The different fulfillment statuses that a request can be in.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum FulfillmentStatus {
    UnspecifiedFulfillmentStatus = 0,
    /// The request has been requested.
    Requested = 1,
    /// The request has been assigned to a fulfiller.
    Assigned = 2,
    /// The request has been fulfilled.
    Fulfilled = 3,
    /// The request cannot be fulfilled.
    Unfulfillable = 4,
}
impl FulfillmentStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedFulfillmentStatus => "UNSPECIFIED_FULFILLMENT_STATUS",
            Self::Requested => "REQUESTED",
            Self::Assigned => "ASSIGNED",
            Self::Fulfilled => "FULFILLED",
            Self::Unfulfillable => "UNFULFILLABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_FULFILLMENT_STATUS" => Some(Self::UnspecifiedFulfillmentStatus),
            "REQUESTED" => Some(Self::Requested),
            "ASSIGNED" => Some(Self::Assigned),
            "FULFILLED" => Some(Self::Fulfilled),
            "UNFULFILLABLE" => Some(Self::Unfulfillable),
            _ => None,
        }
    }
}
/// The different execution statuses that a request can be in.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ExecutionStatus {
    UnspecifiedExecutionStatus = 0,
    /// The request has not been executed.
    Unexecuted = 1,
    /// The request has been executed.
    Executed = 2,
    /// The request cannot be executed.
    Unexecutable = 3,
}
impl ExecutionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedExecutionStatus => "UNSPECIFIED_EXECUTION_STATUS",
            Self::Unexecuted => "UNEXECUTED",
            Self::Executed => "EXECUTED",
            Self::Unexecutable => "UNEXECUTABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_EXECUTION_STATUS" => Some(Self::UnspecifiedExecutionStatus),
            "UNEXECUTED" => Some(Self::Unexecuted),
            "EXECUTED" => Some(Self::Executed),
            "UNEXECUTABLE" => Some(Self::Unexecutable),
            _ => None,
        }
    }
}
/// The different types of balance changes that can occur.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum BalanceOperation {
    UnspecifiedBalanceChangeOperation = 0,
    /// A deposit operation (positive).
    Deposit = 1,
    /// A withdrawal operation (negative).
    Withdrawal = 2,
    /// A credit operation (positive).
    Credit = 3,
    /// A deduction operation (negative).
    Deduction = 4,
    /// A refund operation (positive).
    Refund = 5,
    /// A bid operation (negative).
    Bid = 6,
}
impl BalanceOperation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedBalanceChangeOperation => "UNSPECIFIED_BALANCE_CHANGE_OPERATION",
            Self::Deposit => "DEPOSIT",
            Self::Withdrawal => "WITHDRAWAL",
            Self::Credit => "CREDIT",
            Self::Deduction => "DEDUCTION",
            Self::Refund => "REFUND",
            Self::Bid => "BID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_BALANCE_CHANGE_OPERATION" => Some(Self::UnspecifiedBalanceChangeOperation),
            "DEPOSIT" => Some(Self::Deposit),
            "WITHDRAWAL" => Some(Self::Withdrawal),
            "CREDIT" => Some(Self::Credit),
            "DEDUCTION" => Some(Self::Deduction),
            "REFUND" => Some(Self::Refund),
            "BID" => Some(Self::Bid),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod prover_network_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct ProverNetworkClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ProverNetworkClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ProverNetworkClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ProverNetworkClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ProverNetworkClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a proof request.
        pub async fn request_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::RequestProofRequest>,
        ) -> std::result::Result<tonic::Response<super::RequestProofResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/RequestProof");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "RequestProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Fulfills a proof request. Only callable by the assigned fulfiller.
        pub async fn fulfill_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::FulfillProofRequest>,
        ) -> std::result::Result<tonic::Response<super::FulfillProofResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/FulfillProof");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "FulfillProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Executes a proof request. Only callable by the execution oracle.
        pub async fn execute_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecuteProofRequest>,
        ) -> std::result::Result<tonic::Response<super::ExecuteProofResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/ExecuteProof");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "ExecuteProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Fails fulfillment. Only callable by the assigned fulfiller.
        pub async fn fail_fulfillment(
            &mut self,
            request: impl tonic::IntoRequest<super::FailFulfillmentRequest>,
        ) -> std::result::Result<tonic::Response<super::FailFulfillmentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/FailFulfillment");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "FailFulfillment"));
            self.inner.unary(req, path, codec).await
        }
        /// Fails execution. Only callable by the execution oracle.
        pub async fn fail_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::FailExecutionRequest>,
        ) -> std::result::Result<tonic::Response<super::FailExecutionResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/FailExecution");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "FailExecution"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the status of a proof request.
        pub async fn get_proof_request_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProofRequestStatusRequest>,
        ) -> std::result::Result<tonic::Response<super::GetProofRequestStatusResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProofRequestStatus"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the details of a proof request.
        pub async fn get_proof_request_details(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProofRequestDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProofRequestDetailsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProofRequestDetails"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the proof requests that meet the filter criteria.
        pub async fn get_filtered_proof_requests(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredProofRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredProofRequestsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProofRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredProofRequests"));
            self.inner.unary(req, path, codec).await
        }
        /// Search for proof requests, programs, and requesters.
        pub async fn get_search_results(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSearchResultsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSearchResultsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetSearchResults");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetSearchResults"));
            self.inner.unary(req, path, codec).await
        }
        /// Get metrics for proof requests.
        pub async fn get_proof_request_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProofRequestMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProofRequestMetricsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProofRequestMetrics"));
            self.inner.unary(req, path, codec).await
        }
        /// Get time series data for proof requests.
        pub async fn get_proof_request_graph(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProofRequestGraphRequest>,
        ) -> std::result::Result<tonic::Response<super::GetProofRequestGraphResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetProofRequestGraph");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProofRequestGraph"));
            self.inner.unary(req, path, codec).await
        }
        /// Get analytics graphs for proof requests.
        pub async fn get_analytics_graphs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAnalyticsGraphsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAnalyticsGraphsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetAnalyticsGraphs");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetAnalyticsGraphs"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the nonce of the account.
        pub async fn get_nonce(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNonceRequest>,
        ) -> std::result::Result<tonic::Response<super::GetNonceResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetNonce");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetNonce"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the delegations of the account.
        pub async fn get_filtered_delegations(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredDelegationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredDelegationsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredDelegations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredDelegations"));
            self.inner.unary(req, path, codec).await
        }
        /// Add a delegation. Only callable by the owner of an account.
        pub async fn add_delegation(
            &mut self,
            request: impl tonic::IntoRequest<super::AddDelegationRequest>,
        ) -> std::result::Result<tonic::Response<super::AddDelegationResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/AddDelegation");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "AddDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Remove a delegation. Only callable by the owner of an account.
        pub async fn remove_delegation(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveDelegationRequest>,
        ) -> std::result::Result<tonic::Response<super::RemoveDelegationResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/RemoveDelegation");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RemoveDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Accept a delegation. Only callable by the delegate of a delegation.
        pub async fn accept_delegation(
            &mut self,
            request: impl tonic::IntoRequest<super::AcceptDelegationRequest>,
        ) -> std::result::Result<tonic::Response<super::AcceptDelegationResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/AcceptDelegation");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "AcceptDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the name of the account. Only callable by the owner of an account.
        pub async fn set_account_name(
            &mut self,
            request: impl tonic::IntoRequest<super::SetAccountNameRequest>,
        ) -> std::result::Result<tonic::Response<super::SetAccountNameResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetAccountName");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "SetAccountName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the name of the account.
        pub async fn get_account_name(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAccountNameRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAccountNameResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetAccountName");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetAccountName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get whether the account has signed the terms.
        pub async fn get_terms_signature(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTermsSignatureRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTermsSignatureResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetTermsSignature");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetTermsSignature"));
            self.inner.unary(req, path, codec).await
        }
        /// Set whether the account has signed the terms.
        pub async fn set_terms_signature(
            &mut self,
            request: impl tonic::IntoRequest<super::SetTermsSignatureRequest>,
        ) -> std::result::Result<tonic::Response<super::SetTermsSignatureResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetTermsSignature");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetTermsSignature"));
            self.inner.unary(req, path, codec).await
        }
        /// Get metadata about a program.
        pub async fn get_program(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProgramRequest>,
        ) -> std::result::Result<tonic::Response<super::GetProgramResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetProgram");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetProgram"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new program. Must be called before requesting proofs.
        pub async fn create_program(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateProgramRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateProgramResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/CreateProgram");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "CreateProgram"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the name of the program. Only callable by the owner.
        pub async fn set_program_name(
            &mut self,
            request: impl tonic::IntoRequest<super::SetProgramNameRequest>,
        ) -> std::result::Result<tonic::Response<super::SetProgramNameResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetProgramName");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "SetProgramName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the available balance of an account.
        pub async fn get_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBalanceRequest>,
        ) -> std::result::Result<tonic::Response<super::GetBalanceResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetBalance");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetBalance"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the balance logs that meet the filter criteria.
        pub async fn get_filtered_balance_logs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredBalanceLogsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredBalanceLogsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredBalanceLogs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredBalanceLogs"));
            self.inner.unary(req, path, codec).await
        }
        /// Add credit to an account.
        pub async fn add_credit(
            &mut self,
            request: impl tonic::IntoRequest<super::AddCreditRequest>,
        ) -> std::result::Result<tonic::Response<super::AddCreditResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/AddCredit");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "AddCredit"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the latest processed block in the bridge.
        pub async fn get_latest_bridge_block(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLatestBridgeBlockRequest>,
        ) -> std::result::Result<tonic::Response<super::GetLatestBridgeBlockResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetLatestBridgeBlock");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetLatestBridgeBlock"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the gas price estimate for a given fulfillment strategy.
        pub async fn get_gas_price_estimate(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGasPriceEstimateRequest>,
        ) -> std::result::Result<tonic::Response<super::GetGasPriceEstimateResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetGasPriceEstimate");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetGasPriceEstimate"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the details of a transaction.
        pub async fn get_transaction_details(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionDetailsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTransactionDetailsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetTransactionDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetTransactionDetails"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the reservations that meet the filter criteria.
        pub async fn get_filtered_reservations(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFilteredReservationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredReservationsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredReservations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredReservations"));
            self.inner.unary(req, path, codec).await
        }
        /// Add a reservation for a requester.
        pub async fn add_reservation(
            &mut self,
            request: impl tonic::IntoRequest<super::AddReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::AddReservationResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/AddReservation");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "AddReservation"));
            self.inner.unary(req, path, codec).await
        }
        /// Remove a reservation for a requester.
        pub async fn remove_reservation(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::RemoveReservationResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/RemoveReservation");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RemoveReservation"));
            self.inner.unary(req, path, codec).await
        }
        /// Bid for a proof request. Provers that want to be assigned this request must first
        /// bid on it.
        pub async fn bid(
            &mut self,
            request: impl tonic::IntoRequest<super::BidRequest>,
        ) -> std::result::Result<tonic::Response<super::BidResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/Bid");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "Bid"));
            self.inner.unary(req, path, codec).await
        }
        /// Settle the bids on a proof request to choose the assigned prover. Only callable by
        /// the approved settler.
        pub async fn settle(
            &mut self,
            request: impl tonic::IntoRequest<super::SettleRequest>,
        ) -> std::result::Result<tonic::Response<super::SettleResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/Settle");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "Settle"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod prover_network_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ProverNetworkServer.
    #[async_trait]
    pub trait ProverNetwork: std::marker::Send + std::marker::Sync + 'static {
        /// Creates a proof request.
        async fn request_proof(
            &self,
            request: tonic::Request<super::RequestProofRequest>,
        ) -> std::result::Result<tonic::Response<super::RequestProofResponse>, tonic::Status>;
        /// Fulfills a proof request. Only callable by the assigned fulfiller.
        async fn fulfill_proof(
            &self,
            request: tonic::Request<super::FulfillProofRequest>,
        ) -> std::result::Result<tonic::Response<super::FulfillProofResponse>, tonic::Status>;
        /// Executes a proof request. Only callable by the execution oracle.
        async fn execute_proof(
            &self,
            request: tonic::Request<super::ExecuteProofRequest>,
        ) -> std::result::Result<tonic::Response<super::ExecuteProofResponse>, tonic::Status>;
        /// Fails fulfillment. Only callable by the assigned fulfiller.
        async fn fail_fulfillment(
            &self,
            request: tonic::Request<super::FailFulfillmentRequest>,
        ) -> std::result::Result<tonic::Response<super::FailFulfillmentResponse>, tonic::Status>;
        /// Fails execution. Only callable by the execution oracle.
        async fn fail_execution(
            &self,
            request: tonic::Request<super::FailExecutionRequest>,
        ) -> std::result::Result<tonic::Response<super::FailExecutionResponse>, tonic::Status>;
        /// Get the status of a proof request.
        async fn get_proof_request_status(
            &self,
            request: tonic::Request<super::GetProofRequestStatusRequest>,
        ) -> std::result::Result<tonic::Response<super::GetProofRequestStatusResponse>, tonic::Status>;
        /// Get the details of a proof request.
        async fn get_proof_request_details(
            &self,
            request: tonic::Request<super::GetProofRequestDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProofRequestDetailsResponse>,
            tonic::Status,
        >;
        /// Get the proof requests that meet the filter criteria.
        async fn get_filtered_proof_requests(
            &self,
            request: tonic::Request<super::GetFilteredProofRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredProofRequestsResponse>,
            tonic::Status,
        >;
        /// Search for proof requests, programs, and requesters.
        async fn get_search_results(
            &self,
            request: tonic::Request<super::GetSearchResultsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSearchResultsResponse>, tonic::Status>;
        /// Get metrics for proof requests.
        async fn get_proof_request_metrics(
            &self,
            request: tonic::Request<super::GetProofRequestMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProofRequestMetricsResponse>,
            tonic::Status,
        >;
        /// Get time series data for proof requests.
        async fn get_proof_request_graph(
            &self,
            request: tonic::Request<super::GetProofRequestGraphRequest>,
        ) -> std::result::Result<tonic::Response<super::GetProofRequestGraphResponse>, tonic::Status>;
        /// Get analytics graphs for proof requests.
        async fn get_analytics_graphs(
            &self,
            request: tonic::Request<super::GetAnalyticsGraphsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAnalyticsGraphsResponse>, tonic::Status>;
        /// Get the nonce of the account.
        async fn get_nonce(
            &self,
            request: tonic::Request<super::GetNonceRequest>,
        ) -> std::result::Result<tonic::Response<super::GetNonceResponse>, tonic::Status>;
        /// Get the delegations of the account.
        async fn get_filtered_delegations(
            &self,
            request: tonic::Request<super::GetFilteredDelegationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredDelegationsResponse>,
            tonic::Status,
        >;
        /// Add a delegation. Only callable by the owner of an account.
        async fn add_delegation(
            &self,
            request: tonic::Request<super::AddDelegationRequest>,
        ) -> std::result::Result<tonic::Response<super::AddDelegationResponse>, tonic::Status>;
        /// Remove a delegation. Only callable by the owner of an account.
        async fn remove_delegation(
            &self,
            request: tonic::Request<super::RemoveDelegationRequest>,
        ) -> std::result::Result<tonic::Response<super::RemoveDelegationResponse>, tonic::Status>;
        /// Accept a delegation. Only callable by the delegate of a delegation.
        async fn accept_delegation(
            &self,
            request: tonic::Request<super::AcceptDelegationRequest>,
        ) -> std::result::Result<tonic::Response<super::AcceptDelegationResponse>, tonic::Status>;
        /// Set the name of the account. Only callable by the owner of an account.
        async fn set_account_name(
            &self,
            request: tonic::Request<super::SetAccountNameRequest>,
        ) -> std::result::Result<tonic::Response<super::SetAccountNameResponse>, tonic::Status>;
        /// Get the name of the account.
        async fn get_account_name(
            &self,
            request: tonic::Request<super::GetAccountNameRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAccountNameResponse>, tonic::Status>;
        /// Get whether the account has signed the terms.
        async fn get_terms_signature(
            &self,
            request: tonic::Request<super::GetTermsSignatureRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTermsSignatureResponse>, tonic::Status>;
        /// Set whether the account has signed the terms.
        async fn set_terms_signature(
            &self,
            request: tonic::Request<super::SetTermsSignatureRequest>,
        ) -> std::result::Result<tonic::Response<super::SetTermsSignatureResponse>, tonic::Status>;
        /// Get metadata about a program.
        async fn get_program(
            &self,
            request: tonic::Request<super::GetProgramRequest>,
        ) -> std::result::Result<tonic::Response<super::GetProgramResponse>, tonic::Status>;
        /// Create a new program. Must be called before requesting proofs.
        async fn create_program(
            &self,
            request: tonic::Request<super::CreateProgramRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateProgramResponse>, tonic::Status>;
        /// Set the name of the program. Only callable by the owner.
        async fn set_program_name(
            &self,
            request: tonic::Request<super::SetProgramNameRequest>,
        ) -> std::result::Result<tonic::Response<super::SetProgramNameResponse>, tonic::Status>;
        /// Get the available balance of an account.
        async fn get_balance(
            &self,
            request: tonic::Request<super::GetBalanceRequest>,
        ) -> std::result::Result<tonic::Response<super::GetBalanceResponse>, tonic::Status>;
        /// Get the balance logs that meet the filter criteria.
        async fn get_filtered_balance_logs(
            &self,
            request: tonic::Request<super::GetFilteredBalanceLogsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredBalanceLogsResponse>,
            tonic::Status,
        >;
        /// Add credit to an account.
        async fn add_credit(
            &self,
            request: tonic::Request<super::AddCreditRequest>,
        ) -> std::result::Result<tonic::Response<super::AddCreditResponse>, tonic::Status>;
        /// Get the latest processed block in the bridge.
        async fn get_latest_bridge_block(
            &self,
            request: tonic::Request<super::GetLatestBridgeBlockRequest>,
        ) -> std::result::Result<tonic::Response<super::GetLatestBridgeBlockResponse>, tonic::Status>;
        /// Get the gas price estimate for a given fulfillment strategy.
        async fn get_gas_price_estimate(
            &self,
            request: tonic::Request<super::GetGasPriceEstimateRequest>,
        ) -> std::result::Result<tonic::Response<super::GetGasPriceEstimateResponse>, tonic::Status>;
        /// Get the details of a transaction.
        async fn get_transaction_details(
            &self,
            request: tonic::Request<super::GetTransactionDetailsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTransactionDetailsResponse>, tonic::Status>;
        /// Get the reservations that meet the filter criteria.
        async fn get_filtered_reservations(
            &self,
            request: tonic::Request<super::GetFilteredReservationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFilteredReservationsResponse>,
            tonic::Status,
        >;
        /// Add a reservation for a requester.
        async fn add_reservation(
            &self,
            request: tonic::Request<super::AddReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::AddReservationResponse>, tonic::Status>;
        /// Remove a reservation for a requester.
        async fn remove_reservation(
            &self,
            request: tonic::Request<super::RemoveReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::RemoveReservationResponse>, tonic::Status>;
        /// Bid for a proof request. Provers that want to be assigned this request must first
        /// bid on it.
        async fn bid(
            &self,
            request: tonic::Request<super::BidRequest>,
        ) -> std::result::Result<tonic::Response<super::BidResponse>, tonic::Status>;
        /// Settle the bids on a proof request to choose the assigned prover. Only callable by
        /// the approved settler.
        async fn settle(
            &self,
            request: tonic::Request<super::SettleRequest>,
        ) -> std::result::Result<tonic::Response<super::SettleResponse>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct ProverNetworkServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ProverNetworkServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ProverNetworkServer<T>
    where
        T: ProverNetwork,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/network.ProverNetwork/RequestProof" => {
                    #[allow(non_camel_case_types)]
                    struct RequestProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::RequestProofRequest>
                        for RequestProofSvc<T>
                    {
                        type Response = super::RequestProofResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RequestProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::request_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RequestProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/FulfillProof" => {
                    #[allow(non_camel_case_types)]
                    struct FulfillProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::FulfillProofRequest>
                        for FulfillProofSvc<T>
                    {
                        type Response = super::FulfillProofResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FulfillProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::fulfill_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FulfillProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ExecuteProof" => {
                    #[allow(non_camel_case_types)]
                    struct ExecuteProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::ExecuteProofRequest>
                        for ExecuteProofSvc<T>
                    {
                        type Response = super::ExecuteProofResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExecuteProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::execute_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecuteProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/FailFulfillment" => {
                    #[allow(non_camel_case_types)]
                    struct FailFulfillmentSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::FailFulfillmentRequest>
                        for FailFulfillmentSvc<T>
                    {
                        type Response = super::FailFulfillmentResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FailFulfillmentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::fail_fulfillment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FailFulfillmentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/FailExecution" => {
                    #[allow(non_camel_case_types)]
                    struct FailExecutionSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::FailExecutionRequest>
                        for FailExecutionSvc<T>
                    {
                        type Response = super::FailExecutionResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FailExecutionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::fail_execution(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FailExecutionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestStatusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetProofRequestStatusRequest>
                        for GetProofRequestStatusSvc<T>
                    {
                        type Response = super::GetProofRequestStatusResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProofRequestStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_status(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestDetails" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestDetailsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetProofRequestDetailsRequest>
                        for GetProofRequestDetailsSvc<T>
                    {
                        type Response = super::GetProofRequestDetailsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProofRequestDetailsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_details(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProofRequests" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProofRequestsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetFilteredProofRequestsRequest>
                        for GetFilteredProofRequestsSvc<T>
                    {
                        type Response = super::GetFilteredProofRequestsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredProofRequestsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_proof_requests(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProofRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetSearchResults" => {
                    #[allow(non_camel_case_types)]
                    struct GetSearchResultsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetSearchResultsRequest>
                        for GetSearchResultsSvc<T>
                    {
                        type Response = super::GetSearchResultsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSearchResultsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_search_results(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSearchResultsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestMetricsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetProofRequestMetricsRequest>
                        for GetProofRequestMetricsSvc<T>
                    {
                        type Response = super::GetProofRequestMetricsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProofRequestMetricsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_metrics(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestGraph" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestGraphSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetProofRequestGraphRequest>
                        for GetProofRequestGraphSvc<T>
                    {
                        type Response = super::GetProofRequestGraphResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProofRequestGraphRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_graph(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestGraphSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetAnalyticsGraphs" => {
                    #[allow(non_camel_case_types)]
                    struct GetAnalyticsGraphsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetAnalyticsGraphsRequest>
                        for GetAnalyticsGraphsSvc<T>
                    {
                        type Response = super::GetAnalyticsGraphsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAnalyticsGraphsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_analytics_graphs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAnalyticsGraphsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetNonce" => {
                    #[allow(non_camel_case_types)]
                    struct GetNonceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::GetNonceRequest> for GetNonceSvc<T> {
                        type Response = super::GetNonceResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetNonceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_nonce(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetNonceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredDelegations" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredDelegationsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetFilteredDelegationsRequest>
                        for GetFilteredDelegationsSvc<T>
                    {
                        type Response = super::GetFilteredDelegationsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredDelegationsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_delegations(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredDelegationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AddDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct AddDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::AddDelegationRequest>
                        for AddDelegationSvc<T>
                    {
                        type Response = super::AddDelegationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddDelegationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::add_delegation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RemoveDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::RemoveDelegationRequest>
                        for RemoveDelegationSvc<T>
                    {
                        type Response = super::RemoveDelegationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RemoveDelegationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::remove_delegation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AcceptDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct AcceptDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::AcceptDelegationRequest>
                        for AcceptDelegationSvc<T>
                    {
                        type Response = super::AcceptDelegationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AcceptDelegationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::accept_delegation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AcceptDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetAccountName" => {
                    #[allow(non_camel_case_types)]
                    struct SetAccountNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::SetAccountNameRequest>
                        for SetAccountNameSvc<T>
                    {
                        type Response = super::SetAccountNameResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetAccountNameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_account_name(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetAccountNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetAccountName" => {
                    #[allow(non_camel_case_types)]
                    struct GetAccountNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::GetAccountNameRequest>
                        for GetAccountNameSvc<T>
                    {
                        type Response = super::GetAccountNameResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAccountNameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_account_name(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAccountNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTermsSignature" => {
                    #[allow(non_camel_case_types)]
                    struct GetTermsSignatureSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetTermsSignatureRequest>
                        for GetTermsSignatureSvc<T>
                    {
                        type Response = super::GetTermsSignatureResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTermsSignatureRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_terms_signature(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTermsSignatureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetTermsSignature" => {
                    #[allow(non_camel_case_types)]
                    struct SetTermsSignatureSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::SetTermsSignatureRequest>
                        for SetTermsSignatureSvc<T>
                    {
                        type Response = super::SetTermsSignatureResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetTermsSignatureRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_terms_signature(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetTermsSignatureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProgram" => {
                    #[allow(non_camel_case_types)]
                    struct GetProgramSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::GetProgramRequest> for GetProgramSvc<T> {
                        type Response = super::GetProgramResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProgramRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_program(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProgramSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/CreateProgram" => {
                    #[allow(non_camel_case_types)]
                    struct CreateProgramSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::CreateProgramRequest>
                        for CreateProgramSvc<T>
                    {
                        type Response = super::CreateProgramResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateProgramRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::create_program(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateProgramSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetProgramName" => {
                    #[allow(non_camel_case_types)]
                    struct SetProgramNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::SetProgramNameRequest>
                        for SetProgramNameSvc<T>
                    {
                        type Response = super::SetProgramNameResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetProgramNameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_program_name(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetProgramNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetBalance" => {
                    #[allow(non_camel_case_types)]
                    struct GetBalanceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::GetBalanceRequest> for GetBalanceSvc<T> {
                        type Response = super::GetBalanceResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBalanceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_balance(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBalanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredBalanceLogs" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredBalanceLogsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetFilteredBalanceLogsRequest>
                        for GetFilteredBalanceLogsSvc<T>
                    {
                        type Response = super::GetFilteredBalanceLogsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredBalanceLogsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_balance_logs(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredBalanceLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AddCredit" => {
                    #[allow(non_camel_case_types)]
                    struct AddCreditSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::AddCreditRequest> for AddCreditSvc<T> {
                        type Response = super::AddCreditResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddCreditRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::add_credit(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddCreditSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLatestBridgeBlock" => {
                    #[allow(non_camel_case_types)]
                    struct GetLatestBridgeBlockSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetLatestBridgeBlockRequest>
                        for GetLatestBridgeBlockSvc<T>
                    {
                        type Response = super::GetLatestBridgeBlockResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetLatestBridgeBlockRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_latest_bridge_block(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLatestBridgeBlockSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetGasPriceEstimate" => {
                    #[allow(non_camel_case_types)]
                    struct GetGasPriceEstimateSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetGasPriceEstimateRequest>
                        for GetGasPriceEstimateSvc<T>
                    {
                        type Response = super::GetGasPriceEstimateResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetGasPriceEstimateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_gas_price_estimate(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetGasPriceEstimateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTransactionDetails" => {
                    #[allow(non_camel_case_types)]
                    struct GetTransactionDetailsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetTransactionDetailsRequest>
                        for GetTransactionDetailsSvc<T>
                    {
                        type Response = super::GetTransactionDetailsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTransactionDetailsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_transaction_details(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTransactionDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredReservations" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredReservationsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::GetFilteredReservationsRequest>
                        for GetFilteredReservationsSvc<T>
                    {
                        type Response = super::GetFilteredReservationsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFilteredReservationsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_reservations(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredReservationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AddReservation" => {
                    #[allow(non_camel_case_types)]
                    struct AddReservationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::AddReservationRequest>
                        for AddReservationSvc<T>
                    {
                        type Response = super::AddReservationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddReservationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::add_reservation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddReservationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RemoveReservation" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveReservationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::RemoveReservationRequest>
                        for RemoveReservationSvc<T>
                    {
                        type Response = super::RemoveReservationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RemoveReservationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::remove_reservation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveReservationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Bid" => {
                    #[allow(non_camel_case_types)]
                    struct BidSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::BidRequest> for BidSvc<T> {
                        type Response = super::BidResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as ProverNetwork>::bid(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Settle" => {
                    #[allow(non_camel_case_types)]
                    struct SettleSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork> tonic::server::UnaryService<super::SettleRequest> for SettleSvc<T> {
                        type Response = super::SettleResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SettleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as ProverNetwork>::settle(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SettleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", tonic::Code::Unimplemented as i32)
                        .header(http::header::CONTENT_TYPE, tonic::metadata::GRPC_CONTENT_TYPE)
                        .body(empty_body())
                        .unwrap())
                }),
            }
        }
    }
    impl<T> Clone for ProverNetworkServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "network.ProverNetwork";
    impl<T> tonic::server::NamedService for ProverNetworkServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
