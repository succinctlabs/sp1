// This file is @generated by prost-build.
/// Generated client implementations.
pub mod prover_network_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct ProverNetworkClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ProverNetworkClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ProverNetworkClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ProverNetworkClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ProverNetworkClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a proof request.
        pub async fn request_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::RequestProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RequestProofResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/RequestProof");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "RequestProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Fulfills a proof request. Only callable by the assigned fulfiller.
        pub async fn fulfill_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::FulfillProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::FulfillProofResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/FulfillProof");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "FulfillProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Executes a proof request. Only callable by the execution oracle.
        pub async fn execute_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::ExecuteProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ExecuteProofResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/ExecuteProof");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "ExecuteProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Fails fulfillment. Only callable by the assigned fulfiller.
        pub async fn fail_fulfillment(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::FailFulfillmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::FailFulfillmentResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/FailFulfillment");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "FailFulfillment"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the status of a proof request.
        pub async fn get_proof_request_status(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetProofRequestStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestStatusResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProofRequestStatus"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the details of a proof request.
        pub async fn get_proof_request_details(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetProofRequestDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestDetailsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProofRequestDetails"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the proof requests that meet the filter criteria.
        pub async fn get_filtered_proof_requests(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetFilteredProofRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProofRequestsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProofRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredProofRequests"));
            self.inner.unary(req, path, codec).await
        }
        /// Subscribe to proof requests that meet the filter criteria.
        pub async fn subscribe_proof_requests(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetFilteredProofRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::super::types::ProofRequest>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SubscribeProofRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SubscribeProofRequests"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Search for proof requests, programs, and requesters.
        pub async fn get_search_results(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetSearchResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetSearchResultsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetSearchResults");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetSearchResults"));
            self.inner.unary(req, path, codec).await
        }
        /// Get metrics for proof requests.
        pub async fn get_proof_request_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetProofRequestMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestMetricsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProofRequestMetrics"));
            self.inner.unary(req, path, codec).await
        }
        /// Get time series data for proof requests.
        pub async fn get_proof_request_graph(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetProofRequestGraphRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestGraphResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetProofRequestGraph");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProofRequestGraph"));
            self.inner.unary(req, path, codec).await
        }
        /// Get analytics graphs for proof requests.
        pub async fn get_analytics_graphs(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetAnalyticsGraphsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAnalyticsGraphsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetAnalyticsGraphs");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetAnalyticsGraphs"));
            self.inner.unary(req, path, codec).await
        }
        /// Get overview graphs for proof requests.
        pub async fn get_overview_graphs(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetOverviewGraphsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetOverviewGraphsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetOverviewGraphs");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetOverviewGraphs"));
            self.inner.unary(req, path, codec).await
        }
        /// Get network proof request parameters.
        pub async fn get_proof_request_params(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetProofRequestParamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestParamsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProofRequestParams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProofRequestParams"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the nonce of the account.
        pub async fn get_nonce(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetNonceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetNonceResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetNonce");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetNonce"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the name of the account.
        pub async fn set_account_name(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetAccountNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetAccountNameResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetAccountName");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "SetAccountName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the name of the account.
        pub async fn get_account_name(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetAccountNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAccountNameResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetAccountName");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetAccountName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get whether the account has signed the terms.
        pub async fn get_terms_signature(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetTermsSignatureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTermsSignatureResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetTermsSignature");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetTermsSignature"));
            self.inner.unary(req, path, codec).await
        }
        /// Set whether the account has signed the terms.
        pub async fn set_terms_signature(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetTermsSignatureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetTermsSignatureResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetTermsSignature");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetTermsSignature"));
            self.inner.unary(req, path, codec).await
        }
        /// Get all the information about an account.
        pub async fn get_account(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAccountResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetAccount");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetAccount"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the owner of an account. Returns itself if the account is not delegated.
        pub async fn get_owner(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetOwnerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetOwnerResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetOwner");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetOwner"));
            self.inner.unary(req, path, codec).await
        }
        /// Get metadata about a program.
        pub async fn get_program(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProgramResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetProgram");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetProgram"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new program. Must be called before requesting proofs.
        pub async fn create_program(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::CreateProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::CreateProgramResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/CreateProgram");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "CreateProgram"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the name of the program. Only callable by the owner.
        pub async fn set_program_name(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetProgramNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetProgramNameResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetProgramName");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "SetProgramName"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the available balance of an account.
        pub async fn get_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetBalanceResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetBalance");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetBalance"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the available delegated balance of an account.
        pub async fn get_delegated_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetDelegatedBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetDelegatedBalanceResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetDelegatedBalance");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetDelegatedBalance"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the balance logs that meet the filter criteria.
        pub async fn get_filtered_balance_logs(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetFilteredBalanceLogsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredBalanceLogsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredBalanceLogs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredBalanceLogs"));
            self.inner.unary(req, path, codec).await
        }
        /// Add credit to an account.
        pub async fn add_credit(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::AddCreditRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::AddCreditResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/AddCredit");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "AddCredit"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the latest processed block in the bridge.
        pub async fn get_latest_bridge_block(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetLatestBridgeBlockRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLatestBridgeBlockResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetLatestBridgeBlock");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetLatestBridgeBlock"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the gas price estimate for a given fulfillment strategy.
        pub async fn get_gas_price_estimate(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetGasPriceEstimateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetGasPriceEstimateResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetGasPriceEstimate");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetGasPriceEstimate"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the details of a transaction.
        pub async fn get_transaction_details(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetTransactionDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTransactionDetailsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetTransactionDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetTransactionDetails"));
            self.inner.unary(req, path, codec).await
        }
        /// Add a charge to an account.
        pub async fn add_reserved_charge(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::AddReservedChargeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::AddReservedChargeResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/AddReservedCharge");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "AddReservedCharge"));
            self.inner.unary(req, path, codec).await
        }
        /// Get prorated billing summary by month for a specified payer.
        pub async fn get_billing_summary(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetBillingSummaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetBillingSummaryResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetBillingSummary");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetBillingSummary"));
            self.inner.unary(req, path, codec).await
        }
        /// Update the charge type price for a reservation.
        pub async fn update_price(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::UpdatePriceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::UpdatePriceResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/UpdatePrice");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "UpdatePrice"));
            self.inner.unary(req, path, codec).await
        }
        /// Get filtered and paginated clusters/fulfillers with prices.
        pub async fn get_filtered_clusters(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetFilteredClustersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredClustersResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetFilteredClusters");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredClusters"));
            self.inner.unary(req, path, codec).await
        }
        /// Get usage summary by month for a specified payer.
        pub async fn get_usage_summary(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetUsageSummaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetUsageSummaryResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetUsageSummary");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetUsageSummary"));
            self.inner.unary(req, path, codec).await
        }
        /// Transfer $PROVE from one account to another.
        pub async fn transfer(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::TransferRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::TransferResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/Transfer");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "Transfer"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the reservations that meet the filter criteria.
        pub async fn get_filtered_reservations(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetFilteredReservationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredReservationsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredReservations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredReservations"));
            self.inner.unary(req, path, codec).await
        }
        /// Add a reservation for a requester.
        pub async fn add_reservation(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::AddReservationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::AddReservationResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/AddReservation");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "AddReservation"));
            self.inner.unary(req, path, codec).await
        }
        /// Remove a reservation for a requester.
        pub async fn remove_reservation(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::RemoveReservationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RemoveReservationResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/RemoveReservation");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RemoveReservation"));
            self.inner.unary(req, path, codec).await
        }
        /// Bid for a proof request. Provers that want to be assigned this request must first
        /// bid on it.
        pub async fn bid(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::BidRequest>,
        ) -> std::result::Result<tonic::Response<super::super::types::BidResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/Bid");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "Bid"));
            self.inner.unary(req, path, codec).await
        }
        /// Settle the bids on a proof request to choose the assigned prover. Only callable by
        /// the approved auctioneer.
        pub async fn settle(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SettleRequest>,
        ) -> std::result::Result<tonic::Response<super::super::types::SettleResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/Settle");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "Settle"));
            self.inner.unary(req, path, codec).await
        }
        /// Sign in with Ethereum
        pub async fn sign_in(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SignInRequest>,
        ) -> std::result::Result<tonic::Response<super::super::types::SignInResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/SignIn");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "SignIn"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the accounts that meet the filter criteria.
        pub async fn get_onboarded_accounts_count(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetOnboardedAccountsCountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetOnboardedAccountsCountResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetOnboardedAccountsCount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetOnboardedAccountsCount"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the accounts that have joined the leaderboard.
        pub async fn get_filtered_onboarded_accounts(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetFilteredOnboardedAccountsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredOnboardedAccountsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredOnboardedAccounts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredOnboardedAccounts"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the leaderboard.
        pub async fn get_leaderboard(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLeaderboardResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetLeaderboard");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetLeaderboard"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the leaderboard stats for a given account.
        pub async fn get_leaderboard_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetLeaderboardStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLeaderboardStatsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetLeaderboardStats");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetLeaderboardStats"));
            self.inner.unary(req, path, codec).await
        }
        /// Get codes.
        pub async fn get_codes(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetCodesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetCodesResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetCodes");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetCodes"));
            self.inner.unary(req, path, codec).await
        }
        /// Redeem a code.
        pub async fn redeem_code(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::RedeemCodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RedeemCodeResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/RedeemCode");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "RedeemCode"));
            self.inner.unary(req, path, codec).await
        }
        /// Connect a Twitter account.
        pub async fn connect_twitter(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::ConnectTwitterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ConnectTwitterResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/ConnectTwitter");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "ConnectTwitter"));
            self.inner.unary(req, path, codec).await
        }
        /// Complete onboarding.
        pub async fn complete_onboarding(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::CompleteOnboardingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::CompleteOnboardingResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/CompleteOnboarding");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "CompleteOnboarding"));
            self.inner.unary(req, path, codec).await
        }
        /// Set if a user should display their Twitter handle.
        pub async fn set_use_twitter_handle(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetUseTwitterHandleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetUseTwitterHandleResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetUseTwitterHandle");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetUseTwitterHandle"));
            self.inner.unary(req, path, codec).await
        }
        /// Set if a user should display their Twitter profile picture.
        pub async fn set_use_twitter_image(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetUseTwitterImageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetUseTwitterImageResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetUseTwitterImage");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetUseTwitterImage"));
            self.inner.unary(req, path, codec).await
        }
        /// Request a random proof.
        pub async fn request_random_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::RequestRandomProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RequestRandomProofResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/RequestRandomProof");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RequestRandomProof"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit answers for the captcha game.
        pub async fn submit_captcha_game(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SubmitCaptchaGameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SubmitCaptchaGameResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SubmitCaptchaGame");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SubmitCaptchaGame"));
            self.inner.unary(req, path, codec).await
        }
        /// Redeem stars.
        pub async fn redeem_stars(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::RedeemStarsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RedeemStarsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/RedeemStars");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "RedeemStars"));
            self.inner.unary(req, path, codec).await
        }
        /// Get flappy leaderboard.
        pub async fn get_flappy_leaderboard(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetFlappyLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFlappyLeaderboardResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetFlappyLeaderboard");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFlappyLeaderboard"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the turbo game high score.
        pub async fn set_turbo_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetTurboHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetTurboHighScoreResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetTurboHighScore");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetTurboHighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit answers for the quiz game.
        pub async fn submit_quiz_game(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SubmitQuizGameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SubmitQuizGameResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SubmitQuizGame");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "SubmitQuizGame"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the turbo game leaderboard.
        pub async fn get_turbo_leaderboard(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetTurboLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTurboLeaderboardResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetTurboLeaderboard");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetTurboLeaderboard"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit ETH block metadata.
        pub async fn submit_eth_block_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SubmitEthBlockMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SubmitEthBlockMetadataResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SubmitEthBlockMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SubmitEthBlockMetadata"));
            self.inner.unary(req, path, codec).await
        }
        /// Get ETH block requests that meet the filter criteria.
        pub async fn get_filtered_eth_block_requests(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetFilteredEthBlockRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredEthBlockRequestsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredEthBlockRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredEthBlockRequests"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the 2048 game high score.
        pub async fn set2048_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::Set2048HighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::Set2048HighScoreResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/Set2048HighScore");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "Set2048HighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the volleyball game high score.
        pub async fn set_volleyball_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetVolleyballHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetVolleyballHighScoreResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetVolleyballHighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetVolleyballHighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Get ETH block proof requests metrics.
        pub async fn get_eth_block_request_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetEthBlockRequestMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetEthBlockRequestMetricsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetEthBlockRequestMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetEthBlockRequestMetrics"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the turbo time trial high score.
        pub async fn set_turbo_time_trial_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetTurboTimeTrialHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetTurboTimeTrialHighScoreResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetTurboTimeTrialHighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetTurboTimeTrialHighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the coin craze high score.
        pub async fn set_coin_craze_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetCoinCrazeHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetCoinCrazeHighScoreResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/SetCoinCrazeHighScore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetCoinCrazeHighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the lean high score.
        pub async fn set_lean_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetLeanHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetLeanHighScoreResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetLeanHighScore");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetLeanHighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the flow high score.
        pub async fn set_flow_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetFlowHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetFlowHighScoreResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetFlowHighScore");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetFlowHighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the rollup high score.
        pub async fn set_rollup_high_score(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetRollupHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetRollupHighScoreResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetRollupHighScore");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetRollupHighScore"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the pending stars for an account.
        pub async fn get_pending_stars(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetPendingStarsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetPendingStarsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetPendingStars");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetPendingStars"));
            self.inner.unary(req, path, codec).await
        }
        /// Check if address or social identity is whitelisted.
        pub async fn get_whitelist_status(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetWhitelistStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetWhitelistStatusResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetWhitelistStatus");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetWhitelistStatus"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the gpu delegate.
        pub async fn set_gpu_delegate(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetGpuDelegateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetGpuDelegateResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetGpuDelegate");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "SetGpuDelegate"));
            self.inner.unary(req, path, codec).await
        }
        /// Claim a gpu.
        pub async fn claim_gpu(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::ClaimGpuRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ClaimGpuResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/ClaimGpu");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "ClaimGpu"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the gpu variant.
        pub async fn set_gpu_variant(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetGpuVariantRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetGpuVariantResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetGpuVariant");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "SetGpuVariant"));
            self.inner.unary(req, path, codec).await
        }
        /// Link a whitelisted twitter account.
        pub async fn link_whitelisted_twitter(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::LinkWhitelistedTwitterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::LinkWhitelistedTwitterResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/LinkWhitelistedTwitter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "LinkWhitelistedTwitter"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve the proving key for your account. Must have claimed a gpu and self-delegated to
        /// yourself.
        pub async fn retrieve_proving_key(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::RetrieveProvingKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RetrieveProvingKeyResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/RetrieveProvingKey");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "RetrieveProvingKey"));
            self.inner.unary(req, path, codec).await
        }
        /// Link a whitelisted github account.
        pub async fn link_whitelisted_github(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::LinkWhitelistedGithubRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::LinkWhitelistedGithubResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/LinkWhitelistedGithub",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "LinkWhitelistedGithub"));
            self.inner.unary(req, path, codec).await
        }
        /// Link a whitelisted discord account.
        pub async fn link_whitelisted_discord(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::LinkWhitelistedDiscordRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::LinkWhitelistedDiscordResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/LinkWhitelistedDiscord",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "LinkWhitelistedDiscord"));
            self.inner.unary(req, path, codec).await
        }
        /// Get prover leaderboard.
        pub async fn get_prover_leaderboard(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetProverLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverLeaderboardResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetProverLeaderboard");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProverLeaderboard"));
            self.inner.unary(req, path, codec).await
        }
        /// Get filtered gpus.
        pub async fn get_filtered_gpus(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetFilteredGpusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredGpusResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetFilteredGpus");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredGpus"));
            self.inner.unary(req, path, codec).await
        }
        /// Set the gpu coordinates.
        pub async fn set_gpu_coordinates(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetGpuCoordinatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetGpuCoordinatesResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetGpuCoordinates");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "SetGpuCoordinates"));
            self.inner.unary(req, path, codec).await
        }
        /// Get points.
        pub async fn get_points(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetPointsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetPointsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetPoints");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetPoints"));
            self.inner.unary(req, path, codec).await
        }
        /// Process clicks.
        pub async fn process_clicks(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::ProcessClicksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ProcessClicksResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/ProcessClicks");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "ProcessClicks"));
            self.inner.unary(req, path, codec).await
        }
        /// Purchase upgrade.
        pub async fn purchase_upgrade(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::PurchaseUpgradeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::PurchaseUpgradeResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/PurchaseUpgrade");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "PurchaseUpgrade"));
            self.inner.unary(req, path, codec).await
        }
        /// Place a bet.
        pub async fn bet(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::BetRequest>,
        ) -> std::result::Result<tonic::Response<super::super::types::BetResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/Bet");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "Bet"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the status of a proof contest.
        pub async fn get_contest_details(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetContestDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetContestDetailsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetContestDetails");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetContestDetails"));
            self.inner.unary(req, path, codec).await
        }
        /// Get latest contest id.
        pub async fn get_latest_contest(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetLatestContestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLatestContestResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetLatestContest");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetLatestContest"));
            self.inner.unary(req, path, codec).await
        }
        /// Get contest bettors.
        pub async fn get_contest_bettors(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetContestBettorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetContestBettorsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetContestBettors");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetContestBettors"));
            self.inner.unary(req, path, codec).await
        }
        /// Get gpu metrics.
        pub async fn get_gpu_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetGpuMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetGpuMetricsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetGpuMetrics");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetGpuMetrics"));
            self.inner.unary(req, path, codec).await
        }
        /// Get filtered prover activity.
        pub async fn get_filtered_prover_activity(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetFilteredProverActivityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProverActivityResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProverActivity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredProverActivity"));
            self.inner.unary(req, path, codec).await
        }
        /// Get prover metrics.
        pub async fn get_prover_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetProverMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverMetricsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetProverMetrics");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProverMetrics"));
            self.inner.unary(req, path, codec).await
        }
        /// Get filtered bet history.
        pub async fn get_filtered_bet_history(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetFilteredBetHistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredBetHistoryResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredBetHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredBetHistory"));
            self.inner.unary(req, path, codec).await
        }
        /// Get gpu team stats.
        pub async fn get_gpu_team_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetGpuTeamStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetGpuTeamStatsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetGpuTeamStats");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetGpuTeamStats"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the config values.
        pub async fn get_config_values(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetConfigValuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetConfigValuesResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetConfigValues");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetConfigValues"));
            self.inner.unary(req, path, codec).await
        }
        /// Get metrics for a specific prover
        pub async fn get_prover_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetProverStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverStatsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetProverStats");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetProverStats"));
            self.inner.unary(req, path, codec).await
        }
        /// Get statistics for all provers with pagination
        pub async fn get_filtered_prover_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetFilteredProverStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProverStatsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProverStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredProverStats"));
            self.inner.unary(req, path, codec).await
        }
        /// Get detailed statistics for a single prover by address
        pub async fn get_prover_stats_detail(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetProverStatsDetailRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverStatsDetailResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetProverStatsDetail");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProverStatsDetail"));
            self.inner.unary(req, path, codec).await
        }
        /// Get search results for provers
        pub async fn get_prover_search_results(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetProverSearchResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverSearchResultsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProverSearchResults",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProverSearchResults"));
            self.inner.unary(req, path, codec).await
        }
        /// Get paginated auction history
        pub async fn get_filtered_bid_history(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetFilteredBidHistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredBidHistoryResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredBidHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredBidHistory"));
            self.inner.unary(req, path, codec).await
        }
        /// Check if the user is whitelisted to use the TEE service.
        pub async fn get_tee_whitelist_status(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetTeeWhitelistStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTeeWhitelistStatusResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetTEEWhitelistStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetTEEWhitelistStatus"));
            self.inner.unary(req, path, codec).await
        }
        ///
        /// Settlement
        ///
        /// These methods are for settling orders to L1.
        pub async fn get_settlement_request(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetSettlementRequestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetSettlementRequestResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetSettlementRequest");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetSettlementRequest"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_filtered_settlement_requests(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetFilteredSettlementRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredSettlementRequestsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredSettlementRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredSettlementRequests"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the provers that meet the filter criteria.
        pub async fn get_filtered_provers(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetFilteredProversRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProversResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetFilteredProvers");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredProvers"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the available balance of a staker.
        pub async fn get_staker_stake_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetStakerStakeBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetStakerStakeBalanceResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetStakerStakeBalance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetStakerStakeBalance"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the available balance of a prover.
        pub async fn get_prover_stake_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetProverStakeBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverStakeBalanceResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetProverStakeBalance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetProverStakeBalance"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the staker balance logs that meet the filter criteria.
        pub async fn get_filtered_staker_stake_balance_logs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredStakerStakeBalanceLogsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredStakerStakeBalanceLogsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredStakerStakeBalanceLogs",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "network.ProverNetwork",
                "GetFilteredStakerStakeBalanceLogs",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Get the prover balance logs that meet the filter criteria.
        pub async fn get_filtered_prover_stake_balance_logs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::types::GetFilteredProverStakeBalanceLogsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProverStakeBalanceLogsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredProverStakeBalanceLogs",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "network.ProverNetwork",
                "GetFilteredProverStakeBalanceLogs",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Set a delegation.
        pub async fn set_delegation(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::SetDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetDelegationResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/SetDelegation");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "SetDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Get a delegation.
        pub async fn get_delegation(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetDelegationResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/network.ProverNetwork/GetDelegation");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("network.ProverNetwork", "GetDelegation"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the withdrawal receipts of an account.
        pub async fn get_filtered_withdrawal_receipts(
            &mut self,
            request: impl tonic::IntoRequest<super::super::types::GetFilteredWithdrawalReceiptsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredWithdrawalReceiptsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/network.ProverNetwork/GetFilteredWithdrawalReceipts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("network.ProverNetwork", "GetFilteredWithdrawalReceipts"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod prover_network_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ProverNetworkServer.
    #[async_trait]
    pub trait ProverNetwork: std::marker::Send + std::marker::Sync + 'static {
        /// Creates a proof request.
        async fn request_proof(
            &self,
            request: tonic::Request<super::super::types::RequestProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RequestProofResponse>,
            tonic::Status,
        >;
        /// Fulfills a proof request. Only callable by the assigned fulfiller.
        async fn fulfill_proof(
            &self,
            request: tonic::Request<super::super::types::FulfillProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::FulfillProofResponse>,
            tonic::Status,
        >;
        /// Executes a proof request. Only callable by the execution oracle.
        async fn execute_proof(
            &self,
            request: tonic::Request<super::super::types::ExecuteProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ExecuteProofResponse>,
            tonic::Status,
        >;
        /// Fails fulfillment. Only callable by the assigned fulfiller.
        async fn fail_fulfillment(
            &self,
            request: tonic::Request<super::super::types::FailFulfillmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::FailFulfillmentResponse>,
            tonic::Status,
        >;
        /// Get the status of a proof request.
        async fn get_proof_request_status(
            &self,
            request: tonic::Request<super::super::types::GetProofRequestStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestStatusResponse>,
            tonic::Status,
        >;
        /// Get the details of a proof request.
        async fn get_proof_request_details(
            &self,
            request: tonic::Request<super::super::types::GetProofRequestDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestDetailsResponse>,
            tonic::Status,
        >;
        /// Get the proof requests that meet the filter criteria.
        async fn get_filtered_proof_requests(
            &self,
            request: tonic::Request<super::super::types::GetFilteredProofRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProofRequestsResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the SubscribeProofRequests method.
        type SubscribeProofRequestsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::super::types::ProofRequest, tonic::Status>,
            > + std::marker::Send
            + 'static;
        /// Subscribe to proof requests that meet the filter criteria.
        async fn subscribe_proof_requests(
            &self,
            request: tonic::Request<super::super::types::GetFilteredProofRequestsRequest>,
        ) -> std::result::Result<tonic::Response<Self::SubscribeProofRequestsStream>, tonic::Status>;
        /// Search for proof requests, programs, and requesters.
        async fn get_search_results(
            &self,
            request: tonic::Request<super::super::types::GetSearchResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetSearchResultsResponse>,
            tonic::Status,
        >;
        /// Get metrics for proof requests.
        async fn get_proof_request_metrics(
            &self,
            request: tonic::Request<super::super::types::GetProofRequestMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestMetricsResponse>,
            tonic::Status,
        >;
        /// Get time series data for proof requests.
        async fn get_proof_request_graph(
            &self,
            request: tonic::Request<super::super::types::GetProofRequestGraphRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestGraphResponse>,
            tonic::Status,
        >;
        /// Get analytics graphs for proof requests.
        async fn get_analytics_graphs(
            &self,
            request: tonic::Request<super::super::types::GetAnalyticsGraphsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAnalyticsGraphsResponse>,
            tonic::Status,
        >;
        /// Get overview graphs for proof requests.
        async fn get_overview_graphs(
            &self,
            request: tonic::Request<super::super::types::GetOverviewGraphsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetOverviewGraphsResponse>,
            tonic::Status,
        >;
        /// Get network proof request parameters.
        async fn get_proof_request_params(
            &self,
            request: tonic::Request<super::super::types::GetProofRequestParamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProofRequestParamsResponse>,
            tonic::Status,
        >;
        /// Get the nonce of the account.
        async fn get_nonce(
            &self,
            request: tonic::Request<super::super::types::GetNonceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetNonceResponse>,
            tonic::Status,
        >;
        /// Set the name of the account.
        async fn set_account_name(
            &self,
            request: tonic::Request<super::super::types::SetAccountNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetAccountNameResponse>,
            tonic::Status,
        >;
        /// Get the name of the account.
        async fn get_account_name(
            &self,
            request: tonic::Request<super::super::types::GetAccountNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAccountNameResponse>,
            tonic::Status,
        >;
        /// Get whether the account has signed the terms.
        async fn get_terms_signature(
            &self,
            request: tonic::Request<super::super::types::GetTermsSignatureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTermsSignatureResponse>,
            tonic::Status,
        >;
        /// Set whether the account has signed the terms.
        async fn set_terms_signature(
            &self,
            request: tonic::Request<super::super::types::SetTermsSignatureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetTermsSignatureResponse>,
            tonic::Status,
        >;
        /// Get all the information about an account.
        async fn get_account(
            &self,
            request: tonic::Request<super::super::types::GetAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetAccountResponse>,
            tonic::Status,
        >;
        /// Get the owner of an account. Returns itself if the account is not delegated.
        async fn get_owner(
            &self,
            request: tonic::Request<super::super::types::GetOwnerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetOwnerResponse>,
            tonic::Status,
        >;
        /// Get metadata about a program.
        async fn get_program(
            &self,
            request: tonic::Request<super::super::types::GetProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProgramResponse>,
            tonic::Status,
        >;
        /// Create a new program. Must be called before requesting proofs.
        async fn create_program(
            &self,
            request: tonic::Request<super::super::types::CreateProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::CreateProgramResponse>,
            tonic::Status,
        >;
        /// Set the name of the program. Only callable by the owner.
        async fn set_program_name(
            &self,
            request: tonic::Request<super::super::types::SetProgramNameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetProgramNameResponse>,
            tonic::Status,
        >;
        /// Get the available balance of an account.
        async fn get_balance(
            &self,
            request: tonic::Request<super::super::types::GetBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetBalanceResponse>,
            tonic::Status,
        >;
        /// Get the available delegated balance of an account.
        async fn get_delegated_balance(
            &self,
            request: tonic::Request<super::super::types::GetDelegatedBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetDelegatedBalanceResponse>,
            tonic::Status,
        >;
        /// Get the balance logs that meet the filter criteria.
        async fn get_filtered_balance_logs(
            &self,
            request: tonic::Request<super::super::types::GetFilteredBalanceLogsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredBalanceLogsResponse>,
            tonic::Status,
        >;
        /// Add credit to an account.
        async fn add_credit(
            &self,
            request: tonic::Request<super::super::types::AddCreditRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::AddCreditResponse>,
            tonic::Status,
        >;
        /// Get the latest processed block in the bridge.
        async fn get_latest_bridge_block(
            &self,
            request: tonic::Request<super::super::types::GetLatestBridgeBlockRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLatestBridgeBlockResponse>,
            tonic::Status,
        >;
        /// Get the gas price estimate for a given fulfillment strategy.
        async fn get_gas_price_estimate(
            &self,
            request: tonic::Request<super::super::types::GetGasPriceEstimateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetGasPriceEstimateResponse>,
            tonic::Status,
        >;
        /// Get the details of a transaction.
        async fn get_transaction_details(
            &self,
            request: tonic::Request<super::super::types::GetTransactionDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTransactionDetailsResponse>,
            tonic::Status,
        >;
        /// Add a charge to an account.
        async fn add_reserved_charge(
            &self,
            request: tonic::Request<super::super::types::AddReservedChargeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::AddReservedChargeResponse>,
            tonic::Status,
        >;
        /// Get prorated billing summary by month for a specified payer.
        async fn get_billing_summary(
            &self,
            request: tonic::Request<super::super::types::GetBillingSummaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetBillingSummaryResponse>,
            tonic::Status,
        >;
        /// Update the charge type price for a reservation.
        async fn update_price(
            &self,
            request: tonic::Request<super::super::types::UpdatePriceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::UpdatePriceResponse>,
            tonic::Status,
        >;
        /// Get filtered and paginated clusters/fulfillers with prices.
        async fn get_filtered_clusters(
            &self,
            request: tonic::Request<super::super::types::GetFilteredClustersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredClustersResponse>,
            tonic::Status,
        >;
        /// Get usage summary by month for a specified payer.
        async fn get_usage_summary(
            &self,
            request: tonic::Request<super::super::types::GetUsageSummaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetUsageSummaryResponse>,
            tonic::Status,
        >;
        /// Transfer $PROVE from one account to another.
        async fn transfer(
            &self,
            request: tonic::Request<super::super::types::TransferRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::TransferResponse>,
            tonic::Status,
        >;
        /// Get the reservations that meet the filter criteria.
        async fn get_filtered_reservations(
            &self,
            request: tonic::Request<super::super::types::GetFilteredReservationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredReservationsResponse>,
            tonic::Status,
        >;
        /// Add a reservation for a requester.
        async fn add_reservation(
            &self,
            request: tonic::Request<super::super::types::AddReservationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::AddReservationResponse>,
            tonic::Status,
        >;
        /// Remove a reservation for a requester.
        async fn remove_reservation(
            &self,
            request: tonic::Request<super::super::types::RemoveReservationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RemoveReservationResponse>,
            tonic::Status,
        >;
        /// Bid for a proof request. Provers that want to be assigned this request must first
        /// bid on it.
        async fn bid(
            &self,
            request: tonic::Request<super::super::types::BidRequest>,
        ) -> std::result::Result<tonic::Response<super::super::types::BidResponse>, tonic::Status>;
        /// Settle the bids on a proof request to choose the assigned prover. Only callable by
        /// the approved auctioneer.
        async fn settle(
            &self,
            request: tonic::Request<super::super::types::SettleRequest>,
        ) -> std::result::Result<tonic::Response<super::super::types::SettleResponse>, tonic::Status>;
        /// Sign in with Ethereum
        async fn sign_in(
            &self,
            request: tonic::Request<super::super::types::SignInRequest>,
        ) -> std::result::Result<tonic::Response<super::super::types::SignInResponse>, tonic::Status>;
        /// Get the accounts that meet the filter criteria.
        async fn get_onboarded_accounts_count(
            &self,
            request: tonic::Request<super::super::types::GetOnboardedAccountsCountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetOnboardedAccountsCountResponse>,
            tonic::Status,
        >;
        /// Get the accounts that have joined the leaderboard.
        async fn get_filtered_onboarded_accounts(
            &self,
            request: tonic::Request<super::super::types::GetFilteredOnboardedAccountsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredOnboardedAccountsResponse>,
            tonic::Status,
        >;
        /// Get the leaderboard.
        async fn get_leaderboard(
            &self,
            request: tonic::Request<super::super::types::GetLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLeaderboardResponse>,
            tonic::Status,
        >;
        /// Get the leaderboard stats for a given account.
        async fn get_leaderboard_stats(
            &self,
            request: tonic::Request<super::super::types::GetLeaderboardStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLeaderboardStatsResponse>,
            tonic::Status,
        >;
        /// Get codes.
        async fn get_codes(
            &self,
            request: tonic::Request<super::super::types::GetCodesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetCodesResponse>,
            tonic::Status,
        >;
        /// Redeem a code.
        async fn redeem_code(
            &self,
            request: tonic::Request<super::super::types::RedeemCodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RedeemCodeResponse>,
            tonic::Status,
        >;
        /// Connect a Twitter account.
        async fn connect_twitter(
            &self,
            request: tonic::Request<super::super::types::ConnectTwitterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ConnectTwitterResponse>,
            tonic::Status,
        >;
        /// Complete onboarding.
        async fn complete_onboarding(
            &self,
            request: tonic::Request<super::super::types::CompleteOnboardingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::CompleteOnboardingResponse>,
            tonic::Status,
        >;
        /// Set if a user should display their Twitter handle.
        async fn set_use_twitter_handle(
            &self,
            request: tonic::Request<super::super::types::SetUseTwitterHandleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetUseTwitterHandleResponse>,
            tonic::Status,
        >;
        /// Set if a user should display their Twitter profile picture.
        async fn set_use_twitter_image(
            &self,
            request: tonic::Request<super::super::types::SetUseTwitterImageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetUseTwitterImageResponse>,
            tonic::Status,
        >;
        /// Request a random proof.
        async fn request_random_proof(
            &self,
            request: tonic::Request<super::super::types::RequestRandomProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RequestRandomProofResponse>,
            tonic::Status,
        >;
        /// Submit answers for the captcha game.
        async fn submit_captcha_game(
            &self,
            request: tonic::Request<super::super::types::SubmitCaptchaGameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SubmitCaptchaGameResponse>,
            tonic::Status,
        >;
        /// Redeem stars.
        async fn redeem_stars(
            &self,
            request: tonic::Request<super::super::types::RedeemStarsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RedeemStarsResponse>,
            tonic::Status,
        >;
        /// Get flappy leaderboard.
        async fn get_flappy_leaderboard(
            &self,
            request: tonic::Request<super::super::types::GetFlappyLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFlappyLeaderboardResponse>,
            tonic::Status,
        >;
        /// Set the turbo game high score.
        async fn set_turbo_high_score(
            &self,
            request: tonic::Request<super::super::types::SetTurboHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetTurboHighScoreResponse>,
            tonic::Status,
        >;
        /// Submit answers for the quiz game.
        async fn submit_quiz_game(
            &self,
            request: tonic::Request<super::super::types::SubmitQuizGameRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SubmitQuizGameResponse>,
            tonic::Status,
        >;
        /// Get the turbo game leaderboard.
        async fn get_turbo_leaderboard(
            &self,
            request: tonic::Request<super::super::types::GetTurboLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTurboLeaderboardResponse>,
            tonic::Status,
        >;
        /// Submit ETH block metadata.
        async fn submit_eth_block_metadata(
            &self,
            request: tonic::Request<super::super::types::SubmitEthBlockMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SubmitEthBlockMetadataResponse>,
            tonic::Status,
        >;
        /// Get ETH block requests that meet the filter criteria.
        async fn get_filtered_eth_block_requests(
            &self,
            request: tonic::Request<super::super::types::GetFilteredEthBlockRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredEthBlockRequestsResponse>,
            tonic::Status,
        >;
        /// Set the 2048 game high score.
        async fn set2048_high_score(
            &self,
            request: tonic::Request<super::super::types::Set2048HighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::Set2048HighScoreResponse>,
            tonic::Status,
        >;
        /// Set the volleyball game high score.
        async fn set_volleyball_high_score(
            &self,
            request: tonic::Request<super::super::types::SetVolleyballHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetVolleyballHighScoreResponse>,
            tonic::Status,
        >;
        /// Get ETH block proof requests metrics.
        async fn get_eth_block_request_metrics(
            &self,
            request: tonic::Request<super::super::types::GetEthBlockRequestMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetEthBlockRequestMetricsResponse>,
            tonic::Status,
        >;
        /// Set the turbo time trial high score.
        async fn set_turbo_time_trial_high_score(
            &self,
            request: tonic::Request<super::super::types::SetTurboTimeTrialHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetTurboTimeTrialHighScoreResponse>,
            tonic::Status,
        >;
        /// Set the coin craze high score.
        async fn set_coin_craze_high_score(
            &self,
            request: tonic::Request<super::super::types::SetCoinCrazeHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetCoinCrazeHighScoreResponse>,
            tonic::Status,
        >;
        /// Set the lean high score.
        async fn set_lean_high_score(
            &self,
            request: tonic::Request<super::super::types::SetLeanHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetLeanHighScoreResponse>,
            tonic::Status,
        >;
        /// Set the flow high score.
        async fn set_flow_high_score(
            &self,
            request: tonic::Request<super::super::types::SetFlowHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetFlowHighScoreResponse>,
            tonic::Status,
        >;
        /// Set the rollup high score.
        async fn set_rollup_high_score(
            &self,
            request: tonic::Request<super::super::types::SetRollupHighScoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetRollupHighScoreResponse>,
            tonic::Status,
        >;
        /// Get the pending stars for an account.
        async fn get_pending_stars(
            &self,
            request: tonic::Request<super::super::types::GetPendingStarsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetPendingStarsResponse>,
            tonic::Status,
        >;
        /// Check if address or social identity is whitelisted.
        async fn get_whitelist_status(
            &self,
            request: tonic::Request<super::super::types::GetWhitelistStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetWhitelistStatusResponse>,
            tonic::Status,
        >;
        /// Set the gpu delegate.
        async fn set_gpu_delegate(
            &self,
            request: tonic::Request<super::super::types::SetGpuDelegateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetGpuDelegateResponse>,
            tonic::Status,
        >;
        /// Claim a gpu.
        async fn claim_gpu(
            &self,
            request: tonic::Request<super::super::types::ClaimGpuRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ClaimGpuResponse>,
            tonic::Status,
        >;
        /// Set the gpu variant.
        async fn set_gpu_variant(
            &self,
            request: tonic::Request<super::super::types::SetGpuVariantRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetGpuVariantResponse>,
            tonic::Status,
        >;
        /// Link a whitelisted twitter account.
        async fn link_whitelisted_twitter(
            &self,
            request: tonic::Request<super::super::types::LinkWhitelistedTwitterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::LinkWhitelistedTwitterResponse>,
            tonic::Status,
        >;
        /// Retrieve the proving key for your account. Must have claimed a gpu and self-delegated to
        /// yourself.
        async fn retrieve_proving_key(
            &self,
            request: tonic::Request<super::super::types::RetrieveProvingKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::RetrieveProvingKeyResponse>,
            tonic::Status,
        >;
        /// Link a whitelisted github account.
        async fn link_whitelisted_github(
            &self,
            request: tonic::Request<super::super::types::LinkWhitelistedGithubRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::LinkWhitelistedGithubResponse>,
            tonic::Status,
        >;
        /// Link a whitelisted discord account.
        async fn link_whitelisted_discord(
            &self,
            request: tonic::Request<super::super::types::LinkWhitelistedDiscordRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::LinkWhitelistedDiscordResponse>,
            tonic::Status,
        >;
        /// Get prover leaderboard.
        async fn get_prover_leaderboard(
            &self,
            request: tonic::Request<super::super::types::GetProverLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverLeaderboardResponse>,
            tonic::Status,
        >;
        /// Get filtered gpus.
        async fn get_filtered_gpus(
            &self,
            request: tonic::Request<super::super::types::GetFilteredGpusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredGpusResponse>,
            tonic::Status,
        >;
        /// Set the gpu coordinates.
        async fn set_gpu_coordinates(
            &self,
            request: tonic::Request<super::super::types::SetGpuCoordinatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetGpuCoordinatesResponse>,
            tonic::Status,
        >;
        /// Get points.
        async fn get_points(
            &self,
            request: tonic::Request<super::super::types::GetPointsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetPointsResponse>,
            tonic::Status,
        >;
        /// Process clicks.
        async fn process_clicks(
            &self,
            request: tonic::Request<super::super::types::ProcessClicksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::ProcessClicksResponse>,
            tonic::Status,
        >;
        /// Purchase upgrade.
        async fn purchase_upgrade(
            &self,
            request: tonic::Request<super::super::types::PurchaseUpgradeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::PurchaseUpgradeResponse>,
            tonic::Status,
        >;
        /// Place a bet.
        async fn bet(
            &self,
            request: tonic::Request<super::super::types::BetRequest>,
        ) -> std::result::Result<tonic::Response<super::super::types::BetResponse>, tonic::Status>;
        /// Get the status of a proof contest.
        async fn get_contest_details(
            &self,
            request: tonic::Request<super::super::types::GetContestDetailsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetContestDetailsResponse>,
            tonic::Status,
        >;
        /// Get latest contest id.
        async fn get_latest_contest(
            &self,
            request: tonic::Request<super::super::types::GetLatestContestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetLatestContestResponse>,
            tonic::Status,
        >;
        /// Get contest bettors.
        async fn get_contest_bettors(
            &self,
            request: tonic::Request<super::super::types::GetContestBettorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetContestBettorsResponse>,
            tonic::Status,
        >;
        /// Get gpu metrics.
        async fn get_gpu_metrics(
            &self,
            request: tonic::Request<super::super::types::GetGpuMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetGpuMetricsResponse>,
            tonic::Status,
        >;
        /// Get filtered prover activity.
        async fn get_filtered_prover_activity(
            &self,
            request: tonic::Request<super::super::types::GetFilteredProverActivityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProverActivityResponse>,
            tonic::Status,
        >;
        /// Get prover metrics.
        async fn get_prover_metrics(
            &self,
            request: tonic::Request<super::super::types::GetProverMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverMetricsResponse>,
            tonic::Status,
        >;
        /// Get filtered bet history.
        async fn get_filtered_bet_history(
            &self,
            request: tonic::Request<super::super::types::GetFilteredBetHistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredBetHistoryResponse>,
            tonic::Status,
        >;
        /// Get gpu team stats.
        async fn get_gpu_team_stats(
            &self,
            request: tonic::Request<super::super::types::GetGpuTeamStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetGpuTeamStatsResponse>,
            tonic::Status,
        >;
        /// Get the config values.
        async fn get_config_values(
            &self,
            request: tonic::Request<super::super::types::GetConfigValuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetConfigValuesResponse>,
            tonic::Status,
        >;
        /// Get metrics for a specific prover
        async fn get_prover_stats(
            &self,
            request: tonic::Request<super::super::types::GetProverStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverStatsResponse>,
            tonic::Status,
        >;
        /// Get statistics for all provers with pagination
        async fn get_filtered_prover_stats(
            &self,
            request: tonic::Request<super::super::types::GetFilteredProverStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProverStatsResponse>,
            tonic::Status,
        >;
        /// Get detailed statistics for a single prover by address
        async fn get_prover_stats_detail(
            &self,
            request: tonic::Request<super::super::types::GetProverStatsDetailRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverStatsDetailResponse>,
            tonic::Status,
        >;
        /// Get search results for provers
        async fn get_prover_search_results(
            &self,
            request: tonic::Request<super::super::types::GetProverSearchResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverSearchResultsResponse>,
            tonic::Status,
        >;
        /// Get paginated auction history
        async fn get_filtered_bid_history(
            &self,
            request: tonic::Request<super::super::types::GetFilteredBidHistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredBidHistoryResponse>,
            tonic::Status,
        >;
        /// Check if the user is whitelisted to use the TEE service.
        async fn get_tee_whitelist_status(
            &self,
            request: tonic::Request<super::super::types::GetTeeWhitelistStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetTeeWhitelistStatusResponse>,
            tonic::Status,
        >;
        ///
        /// Settlement
        ///
        /// These methods are for settling orders to L1.
        async fn get_settlement_request(
            &self,
            request: tonic::Request<super::super::types::GetSettlementRequestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetSettlementRequestResponse>,
            tonic::Status,
        >;
        async fn get_filtered_settlement_requests(
            &self,
            request: tonic::Request<super::super::types::GetFilteredSettlementRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredSettlementRequestsResponse>,
            tonic::Status,
        >;
        /// Get the provers that meet the filter criteria.
        async fn get_filtered_provers(
            &self,
            request: tonic::Request<super::super::types::GetFilteredProversRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProversResponse>,
            tonic::Status,
        >;
        /// Get the available balance of a staker.
        async fn get_staker_stake_balance(
            &self,
            request: tonic::Request<super::super::types::GetStakerStakeBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetStakerStakeBalanceResponse>,
            tonic::Status,
        >;
        /// Get the available balance of a prover.
        async fn get_prover_stake_balance(
            &self,
            request: tonic::Request<super::super::types::GetProverStakeBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetProverStakeBalanceResponse>,
            tonic::Status,
        >;
        /// Get the staker balance logs that meet the filter criteria.
        async fn get_filtered_staker_stake_balance_logs(
            &self,
            request: tonic::Request<super::super::types::GetFilteredStakerStakeBalanceLogsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredStakerStakeBalanceLogsResponse>,
            tonic::Status,
        >;
        /// Get the prover balance logs that meet the filter criteria.
        async fn get_filtered_prover_stake_balance_logs(
            &self,
            request: tonic::Request<super::super::types::GetFilteredProverStakeBalanceLogsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredProverStakeBalanceLogsResponse>,
            tonic::Status,
        >;
        /// Set a delegation.
        async fn set_delegation(
            &self,
            request: tonic::Request<super::super::types::SetDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::SetDelegationResponse>,
            tonic::Status,
        >;
        /// Get a delegation.
        async fn get_delegation(
            &self,
            request: tonic::Request<super::super::types::GetDelegationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetDelegationResponse>,
            tonic::Status,
        >;
        /// Get the withdrawal receipts of an account.
        async fn get_filtered_withdrawal_receipts(
            &self,
            request: tonic::Request<super::super::types::GetFilteredWithdrawalReceiptsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::types::GetFilteredWithdrawalReceiptsResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct ProverNetworkServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ProverNetworkServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ProverNetworkServer<T>
    where
        T: ProverNetwork,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/network.ProverNetwork/RequestProof" => {
                    #[allow(non_camel_case_types)]
                    struct RequestProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::RequestProofRequest>
                        for RequestProofSvc<T>
                    {
                        type Response = super::super::types::RequestProofResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::RequestProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::request_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RequestProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/FulfillProof" => {
                    #[allow(non_camel_case_types)]
                    struct FulfillProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::FulfillProofRequest>
                        for FulfillProofSvc<T>
                    {
                        type Response = super::super::types::FulfillProofResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::FulfillProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::fulfill_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FulfillProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ExecuteProof" => {
                    #[allow(non_camel_case_types)]
                    struct ExecuteProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::ExecuteProofRequest>
                        for ExecuteProofSvc<T>
                    {
                        type Response = super::super::types::ExecuteProofResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::ExecuteProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::execute_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecuteProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/FailFulfillment" => {
                    #[allow(non_camel_case_types)]
                    struct FailFulfillmentSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::FailFulfillmentRequest>
                        for FailFulfillmentSvc<T>
                    {
                        type Response = super::super::types::FailFulfillmentResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::FailFulfillmentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::fail_fulfillment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FailFulfillmentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestStatusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetProofRequestStatusRequest,
                        > for GetProofRequestStatusSvc<T>
                    {
                        type Response = super::super::types::GetProofRequestStatusResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProofRequestStatusRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_status(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestDetails" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestDetailsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetProofRequestDetailsRequest,
                        > for GetProofRequestDetailsSvc<T>
                    {
                        type Response = super::super::types::GetProofRequestDetailsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProofRequestDetailsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_details(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProofRequests" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProofRequestsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetFilteredProofRequestsRequest,
                        > for GetFilteredProofRequestsSvc<T>
                    {
                        type Response = super::super::types::GetFilteredProofRequestsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredProofRequestsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_proof_requests(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProofRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SubscribeProofRequests" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeProofRequestsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::ServerStreamingService<
                            super::super::types::GetFilteredProofRequestsRequest,
                        > for SubscribeProofRequestsSvc<T>
                    {
                        type Response = super::super::types::ProofRequest;
                        type ResponseStream = T::SubscribeProofRequestsStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredProofRequestsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::subscribe_proof_requests(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeProofRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetSearchResults" => {
                    #[allow(non_camel_case_types)]
                    struct GetSearchResultsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetSearchResultsRequest>
                        for GetSearchResultsSvc<T>
                    {
                        type Response = super::super::types::GetSearchResultsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetSearchResultsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_search_results(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSearchResultsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestMetricsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetProofRequestMetricsRequest,
                        > for GetProofRequestMetricsSvc<T>
                    {
                        type Response = super::super::types::GetProofRequestMetricsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProofRequestMetricsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_metrics(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestGraph" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestGraphSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetProofRequestGraphRequest,
                        > for GetProofRequestGraphSvc<T>
                    {
                        type Response = super::super::types::GetProofRequestGraphResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProofRequestGraphRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_graph(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestGraphSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetAnalyticsGraphs" => {
                    #[allow(non_camel_case_types)]
                    struct GetAnalyticsGraphsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetAnalyticsGraphsRequest>
                        for GetAnalyticsGraphsSvc<T>
                    {
                        type Response = super::super::types::GetAnalyticsGraphsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetAnalyticsGraphsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_analytics_graphs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAnalyticsGraphsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetOverviewGraphs" => {
                    #[allow(non_camel_case_types)]
                    struct GetOverviewGraphsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetOverviewGraphsRequest>
                        for GetOverviewGraphsSvc<T>
                    {
                        type Response = super::super::types::GetOverviewGraphsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetOverviewGraphsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_overview_graphs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOverviewGraphsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProofRequestParams" => {
                    #[allow(non_camel_case_types)]
                    struct GetProofRequestParamsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetProofRequestParamsRequest,
                        > for GetProofRequestParamsSvc<T>
                    {
                        type Response = super::super::types::GetProofRequestParamsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProofRequestParamsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_proof_request_params(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProofRequestParamsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetNonce" => {
                    #[allow(non_camel_case_types)]
                    struct GetNonceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetNonceRequest>
                        for GetNonceSvc<T>
                    {
                        type Response = super::super::types::GetNonceResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetNonceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_nonce(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetNonceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetAccountName" => {
                    #[allow(non_camel_case_types)]
                    struct SetAccountNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::SetAccountNameRequest>
                        for SetAccountNameSvc<T>
                    {
                        type Response = super::super::types::SetAccountNameResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SetAccountNameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_account_name(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetAccountNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetAccountName" => {
                    #[allow(non_camel_case_types)]
                    struct GetAccountNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetAccountNameRequest>
                        for GetAccountNameSvc<T>
                    {
                        type Response = super::super::types::GetAccountNameResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetAccountNameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_account_name(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAccountNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTermsSignature" => {
                    #[allow(non_camel_case_types)]
                    struct GetTermsSignatureSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetTermsSignatureRequest>
                        for GetTermsSignatureSvc<T>
                    {
                        type Response = super::super::types::GetTermsSignatureResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetTermsSignatureRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_terms_signature(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTermsSignatureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetTermsSignature" => {
                    #[allow(non_camel_case_types)]
                    struct SetTermsSignatureSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::SetTermsSignatureRequest>
                        for SetTermsSignatureSvc<T>
                    {
                        type Response = super::super::types::SetTermsSignatureResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SetTermsSignatureRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_terms_signature(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetTermsSignatureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetAccount" => {
                    #[allow(non_camel_case_types)]
                    struct GetAccountSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetAccountRequest>
                        for GetAccountSvc<T>
                    {
                        type Response = super::super::types::GetAccountResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetAccountRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_account(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAccountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetOwner" => {
                    #[allow(non_camel_case_types)]
                    struct GetOwnerSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetOwnerRequest>
                        for GetOwnerSvc<T>
                    {
                        type Response = super::super::types::GetOwnerResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetOwnerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_owner(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOwnerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProgram" => {
                    #[allow(non_camel_case_types)]
                    struct GetProgramSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetProgramRequest>
                        for GetProgramSvc<T>
                    {
                        type Response = super::super::types::GetProgramResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetProgramRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_program(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProgramSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/CreateProgram" => {
                    #[allow(non_camel_case_types)]
                    struct CreateProgramSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::CreateProgramRequest>
                        for CreateProgramSvc<T>
                    {
                        type Response = super::super::types::CreateProgramResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::CreateProgramRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::create_program(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateProgramSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetProgramName" => {
                    #[allow(non_camel_case_types)]
                    struct SetProgramNameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::SetProgramNameRequest>
                        for SetProgramNameSvc<T>
                    {
                        type Response = super::super::types::SetProgramNameResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SetProgramNameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_program_name(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetProgramNameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetBalance" => {
                    #[allow(non_camel_case_types)]
                    struct GetBalanceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetBalanceRequest>
                        for GetBalanceSvc<T>
                    {
                        type Response = super::super::types::GetBalanceResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetBalanceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_balance(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBalanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetDelegatedBalance" => {
                    #[allow(non_camel_case_types)]
                    struct GetDelegatedBalanceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetDelegatedBalanceRequest>
                        for GetDelegatedBalanceSvc<T>
                    {
                        type Response = super::super::types::GetDelegatedBalanceResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetDelegatedBalanceRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_delegated_balance(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetDelegatedBalanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredBalanceLogs" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredBalanceLogsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetFilteredBalanceLogsRequest,
                        > for GetFilteredBalanceLogsSvc<T>
                    {
                        type Response = super::super::types::GetFilteredBalanceLogsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredBalanceLogsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_balance_logs(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredBalanceLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AddCredit" => {
                    #[allow(non_camel_case_types)]
                    struct AddCreditSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::AddCreditRequest>
                        for AddCreditSvc<T>
                    {
                        type Response = super::super::types::AddCreditResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::AddCreditRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::add_credit(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddCreditSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLatestBridgeBlock" => {
                    #[allow(non_camel_case_types)]
                    struct GetLatestBridgeBlockSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetLatestBridgeBlockRequest,
                        > for GetLatestBridgeBlockSvc<T>
                    {
                        type Response = super::super::types::GetLatestBridgeBlockResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetLatestBridgeBlockRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_latest_bridge_block(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLatestBridgeBlockSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetGasPriceEstimate" => {
                    #[allow(non_camel_case_types)]
                    struct GetGasPriceEstimateSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetGasPriceEstimateRequest>
                        for GetGasPriceEstimateSvc<T>
                    {
                        type Response = super::super::types::GetGasPriceEstimateResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetGasPriceEstimateRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_gas_price_estimate(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetGasPriceEstimateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTransactionDetails" => {
                    #[allow(non_camel_case_types)]
                    struct GetTransactionDetailsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetTransactionDetailsRequest,
                        > for GetTransactionDetailsSvc<T>
                    {
                        type Response = super::super::types::GetTransactionDetailsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetTransactionDetailsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_transaction_details(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTransactionDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AddReservedCharge" => {
                    #[allow(non_camel_case_types)]
                    struct AddReservedChargeSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::AddReservedChargeRequest>
                        for AddReservedChargeSvc<T>
                    {
                        type Response = super::super::types::AddReservedChargeResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::AddReservedChargeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::add_reserved_charge(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddReservedChargeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetBillingSummary" => {
                    #[allow(non_camel_case_types)]
                    struct GetBillingSummarySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetBillingSummaryRequest>
                        for GetBillingSummarySvc<T>
                    {
                        type Response = super::super::types::GetBillingSummaryResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetBillingSummaryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_billing_summary(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBillingSummarySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/UpdatePrice" => {
                    #[allow(non_camel_case_types)]
                    struct UpdatePriceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::UpdatePriceRequest>
                        for UpdatePriceSvc<T>
                    {
                        type Response = super::super::types::UpdatePriceResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::UpdatePriceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::update_price(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdatePriceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredClusters" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredClustersSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetFilteredClustersRequest>
                        for GetFilteredClustersSvc<T>
                    {
                        type Response = super::super::types::GetFilteredClustersResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredClustersRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_clusters(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredClustersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetUsageSummary" => {
                    #[allow(non_camel_case_types)]
                    struct GetUsageSummarySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetUsageSummaryRequest>
                        for GetUsageSummarySvc<T>
                    {
                        type Response = super::super::types::GetUsageSummaryResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetUsageSummaryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_usage_summary(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetUsageSummarySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Transfer" => {
                    #[allow(non_camel_case_types)]
                    struct TransferSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::TransferRequest>
                        for TransferSvc<T>
                    {
                        type Response = super::super::types::TransferResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::TransferRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::transfer(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TransferSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredReservations" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredReservationsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetFilteredReservationsRequest,
                        > for GetFilteredReservationsSvc<T>
                    {
                        type Response = super::super::types::GetFilteredReservationsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredReservationsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_reservations(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredReservationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/AddReservation" => {
                    #[allow(non_camel_case_types)]
                    struct AddReservationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::AddReservationRequest>
                        for AddReservationSvc<T>
                    {
                        type Response = super::super::types::AddReservationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::AddReservationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::add_reservation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddReservationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RemoveReservation" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveReservationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::RemoveReservationRequest>
                        for RemoveReservationSvc<T>
                    {
                        type Response = super::super::types::RemoveReservationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::RemoveReservationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::remove_reservation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveReservationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Bid" => {
                    #[allow(non_camel_case_types)]
                    struct BidSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::BidRequest> for BidSvc<T>
                    {
                        type Response = super::super::types::BidResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::BidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as ProverNetwork>::bid(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Settle" => {
                    #[allow(non_camel_case_types)]
                    struct SettleSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::SettleRequest>
                        for SettleSvc<T>
                    {
                        type Response = super::super::types::SettleResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SettleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as ProverNetwork>::settle(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SettleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SignIn" => {
                    #[allow(non_camel_case_types)]
                    struct SignInSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::SignInRequest>
                        for SignInSvc<T>
                    {
                        type Response = super::super::types::SignInResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SignInRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as ProverNetwork>::sign_in(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SignInSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetOnboardedAccountsCount" => {
                    #[allow(non_camel_case_types)]
                    struct GetOnboardedAccountsCountSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetOnboardedAccountsCountRequest,
                        > for GetOnboardedAccountsCountSvc<T>
                    {
                        type Response = super::super::types::GetOnboardedAccountsCountResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetOnboardedAccountsCountRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_onboarded_accounts_count(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOnboardedAccountsCountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredOnboardedAccounts" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredOnboardedAccountsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetFilteredOnboardedAccountsRequest,
                        > for GetFilteredOnboardedAccountsSvc<T>
                    {
                        type Response = super::super::types::GetFilteredOnboardedAccountsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredOnboardedAccountsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_onboarded_accounts(
                                    &inner, request,
                                )
                                .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredOnboardedAccountsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLeaderboard" => {
                    #[allow(non_camel_case_types)]
                    struct GetLeaderboardSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetLeaderboardRequest>
                        for GetLeaderboardSvc<T>
                    {
                        type Response = super::super::types::GetLeaderboardResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetLeaderboardRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_leaderboard(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLeaderboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLeaderboardStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetLeaderboardStatsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetLeaderboardStatsRequest>
                        for GetLeaderboardStatsSvc<T>
                    {
                        type Response = super::super::types::GetLeaderboardStatsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetLeaderboardStatsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_leaderboard_stats(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLeaderboardStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetCodes" => {
                    #[allow(non_camel_case_types)]
                    struct GetCodesSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetCodesRequest>
                        for GetCodesSvc<T>
                    {
                        type Response = super::super::types::GetCodesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetCodesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_codes(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCodesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RedeemCode" => {
                    #[allow(non_camel_case_types)]
                    struct RedeemCodeSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::RedeemCodeRequest>
                        for RedeemCodeSvc<T>
                    {
                        type Response = super::super::types::RedeemCodeResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::RedeemCodeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::redeem_code(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RedeemCodeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ConnectTwitter" => {
                    #[allow(non_camel_case_types)]
                    struct ConnectTwitterSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::ConnectTwitterRequest>
                        for ConnectTwitterSvc<T>
                    {
                        type Response = super::super::types::ConnectTwitterResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::ConnectTwitterRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::connect_twitter(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConnectTwitterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/CompleteOnboarding" => {
                    #[allow(non_camel_case_types)]
                    struct CompleteOnboardingSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::CompleteOnboardingRequest>
                        for CompleteOnboardingSvc<T>
                    {
                        type Response = super::super::types::CompleteOnboardingResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::CompleteOnboardingRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::complete_onboarding(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CompleteOnboardingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetUseTwitterHandle" => {
                    #[allow(non_camel_case_types)]
                    struct SetUseTwitterHandleSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::SetUseTwitterHandleRequest>
                        for SetUseTwitterHandleSvc<T>
                    {
                        type Response = super::super::types::SetUseTwitterHandleResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetUseTwitterHandleRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_use_twitter_handle(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetUseTwitterHandleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetUseTwitterImage" => {
                    #[allow(non_camel_case_types)]
                    struct SetUseTwitterImageSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::SetUseTwitterImageRequest>
                        for SetUseTwitterImageSvc<T>
                    {
                        type Response = super::super::types::SetUseTwitterImageResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SetUseTwitterImageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_use_twitter_image(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetUseTwitterImageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RequestRandomProof" => {
                    #[allow(non_camel_case_types)]
                    struct RequestRandomProofSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::RequestRandomProofRequest>
                        for RequestRandomProofSvc<T>
                    {
                        type Response = super::super::types::RequestRandomProofResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::RequestRandomProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::request_random_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RequestRandomProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SubmitCaptchaGame" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitCaptchaGameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::SubmitCaptchaGameRequest>
                        for SubmitCaptchaGameSvc<T>
                    {
                        type Response = super::super::types::SubmitCaptchaGameResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SubmitCaptchaGameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::submit_captcha_game(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitCaptchaGameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RedeemStars" => {
                    #[allow(non_camel_case_types)]
                    struct RedeemStarsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::RedeemStarsRequest>
                        for RedeemStarsSvc<T>
                    {
                        type Response = super::super::types::RedeemStarsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::RedeemStarsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::redeem_stars(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RedeemStarsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFlappyLeaderboard" => {
                    #[allow(non_camel_case_types)]
                    struct GetFlappyLeaderboardSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetFlappyLeaderboardRequest,
                        > for GetFlappyLeaderboardSvc<T>
                    {
                        type Response = super::super::types::GetFlappyLeaderboardResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFlappyLeaderboardRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_flappy_leaderboard(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFlappyLeaderboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetTurboHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetTurboHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::SetTurboHighScoreRequest>
                        for SetTurboHighScoreSvc<T>
                    {
                        type Response = super::super::types::SetTurboHighScoreResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SetTurboHighScoreRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_turbo_high_score(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetTurboHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SubmitQuizGame" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitQuizGameSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::SubmitQuizGameRequest>
                        for SubmitQuizGameSvc<T>
                    {
                        type Response = super::super::types::SubmitQuizGameResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SubmitQuizGameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::submit_quiz_game(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitQuizGameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTurboLeaderboard" => {
                    #[allow(non_camel_case_types)]
                    struct GetTurboLeaderboardSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetTurboLeaderboardRequest>
                        for GetTurboLeaderboardSvc<T>
                    {
                        type Response = super::super::types::GetTurboLeaderboardResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetTurboLeaderboardRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_turbo_leaderboard(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTurboLeaderboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SubmitEthBlockMetadata" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitEthBlockMetadataSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::SubmitEthBlockMetadataRequest,
                        > for SubmitEthBlockMetadataSvc<T>
                    {
                        type Response = super::super::types::SubmitEthBlockMetadataResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SubmitEthBlockMetadataRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::submit_eth_block_metadata(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitEthBlockMetadataSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredEthBlockRequests" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredEthBlockRequestsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetFilteredEthBlockRequestsRequest,
                        > for GetFilteredEthBlockRequestsSvc<T>
                    {
                        type Response = super::super::types::GetFilteredEthBlockRequestsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredEthBlockRequestsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_eth_block_requests(
                                    &inner, request,
                                )
                                .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredEthBlockRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Set2048HighScore" => {
                    #[allow(non_camel_case_types)]
                    struct Set2048HighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::Set2048HighScoreRequest>
                        for Set2048HighScoreSvc<T>
                    {
                        type Response = super::super::types::Set2048HighScoreResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::Set2048HighScoreRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set2048_high_score(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = Set2048HighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetVolleyballHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetVolleyballHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::SetVolleyballHighScoreRequest,
                        > for SetVolleyballHighScoreSvc<T>
                    {
                        type Response = super::super::types::SetVolleyballHighScoreResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetVolleyballHighScoreRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_volleyball_high_score(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetVolleyballHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetEthBlockRequestMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct GetEthBlockRequestMetricsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetEthBlockRequestMetricsRequest,
                        > for GetEthBlockRequestMetricsSvc<T>
                    {
                        type Response = super::super::types::GetEthBlockRequestMetricsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetEthBlockRequestMetricsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_eth_block_request_metrics(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetEthBlockRequestMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetTurboTimeTrialHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetTurboTimeTrialHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::SetTurboTimeTrialHighScoreRequest,
                        > for SetTurboTimeTrialHighScoreSvc<T>
                    {
                        type Response = super::super::types::SetTurboTimeTrialHighScoreResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetTurboTimeTrialHighScoreRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_turbo_time_trial_high_score(
                                    &inner, request,
                                )
                                .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetTurboTimeTrialHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetCoinCrazeHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetCoinCrazeHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::SetCoinCrazeHighScoreRequest,
                        > for SetCoinCrazeHighScoreSvc<T>
                    {
                        type Response = super::super::types::SetCoinCrazeHighScoreResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::SetCoinCrazeHighScoreRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_coin_craze_high_score(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetCoinCrazeHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetLeanHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetLeanHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::SetLeanHighScoreRequest>
                        for SetLeanHighScoreSvc<T>
                    {
                        type Response = super::super::types::SetLeanHighScoreResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SetLeanHighScoreRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_lean_high_score(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetLeanHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetFlowHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetFlowHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::SetFlowHighScoreRequest>
                        for SetFlowHighScoreSvc<T>
                    {
                        type Response = super::super::types::SetFlowHighScoreResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SetFlowHighScoreRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_flow_high_score(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetFlowHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetRollupHighScore" => {
                    #[allow(non_camel_case_types)]
                    struct SetRollupHighScoreSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::SetRollupHighScoreRequest>
                        for SetRollupHighScoreSvc<T>
                    {
                        type Response = super::super::types::SetRollupHighScoreResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SetRollupHighScoreRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_rollup_high_score(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetRollupHighScoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetPendingStars" => {
                    #[allow(non_camel_case_types)]
                    struct GetPendingStarsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetPendingStarsRequest>
                        for GetPendingStarsSvc<T>
                    {
                        type Response = super::super::types::GetPendingStarsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetPendingStarsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_pending_stars(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPendingStarsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetWhitelistStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetWhitelistStatusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetWhitelistStatusRequest>
                        for GetWhitelistStatusSvc<T>
                    {
                        type Response = super::super::types::GetWhitelistStatusResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetWhitelistStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_whitelist_status(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetWhitelistStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetGpuDelegate" => {
                    #[allow(non_camel_case_types)]
                    struct SetGpuDelegateSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::SetGpuDelegateRequest>
                        for SetGpuDelegateSvc<T>
                    {
                        type Response = super::super::types::SetGpuDelegateResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SetGpuDelegateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_gpu_delegate(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetGpuDelegateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ClaimGpu" => {
                    #[allow(non_camel_case_types)]
                    struct ClaimGpuSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::ClaimGpuRequest>
                        for ClaimGpuSvc<T>
                    {
                        type Response = super::super::types::ClaimGpuResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::ClaimGpuRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::claim_gpu(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ClaimGpuSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetGpuVariant" => {
                    #[allow(non_camel_case_types)]
                    struct SetGpuVariantSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::SetGpuVariantRequest>
                        for SetGpuVariantSvc<T>
                    {
                        type Response = super::super::types::SetGpuVariantResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SetGpuVariantRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_gpu_variant(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetGpuVariantSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/LinkWhitelistedTwitter" => {
                    #[allow(non_camel_case_types)]
                    struct LinkWhitelistedTwitterSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::LinkWhitelistedTwitterRequest,
                        > for LinkWhitelistedTwitterSvc<T>
                    {
                        type Response = super::super::types::LinkWhitelistedTwitterResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::LinkWhitelistedTwitterRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::link_whitelisted_twitter(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkWhitelistedTwitterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/RetrieveProvingKey" => {
                    #[allow(non_camel_case_types)]
                    struct RetrieveProvingKeySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::RetrieveProvingKeyRequest>
                        for RetrieveProvingKeySvc<T>
                    {
                        type Response = super::super::types::RetrieveProvingKeyResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::RetrieveProvingKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::retrieve_proving_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RetrieveProvingKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/LinkWhitelistedGithub" => {
                    #[allow(non_camel_case_types)]
                    struct LinkWhitelistedGithubSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::LinkWhitelistedGithubRequest,
                        > for LinkWhitelistedGithubSvc<T>
                    {
                        type Response = super::super::types::LinkWhitelistedGithubResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::LinkWhitelistedGithubRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::link_whitelisted_github(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkWhitelistedGithubSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/LinkWhitelistedDiscord" => {
                    #[allow(non_camel_case_types)]
                    struct LinkWhitelistedDiscordSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::LinkWhitelistedDiscordRequest,
                        > for LinkWhitelistedDiscordSvc<T>
                    {
                        type Response = super::super::types::LinkWhitelistedDiscordResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::LinkWhitelistedDiscordRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::link_whitelisted_discord(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkWhitelistedDiscordSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverLeaderboard" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverLeaderboardSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetProverLeaderboardRequest,
                        > for GetProverLeaderboardSvc<T>
                    {
                        type Response = super::super::types::GetProverLeaderboardResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProverLeaderboardRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_leaderboard(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverLeaderboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredGpus" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredGpusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetFilteredGpusRequest>
                        for GetFilteredGpusSvc<T>
                    {
                        type Response = super::super::types::GetFilteredGpusResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetFilteredGpusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_gpus(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredGpusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetGpuCoordinates" => {
                    #[allow(non_camel_case_types)]
                    struct SetGpuCoordinatesSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::SetGpuCoordinatesRequest>
                        for SetGpuCoordinatesSvc<T>
                    {
                        type Response = super::super::types::SetGpuCoordinatesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SetGpuCoordinatesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_gpu_coordinates(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetGpuCoordinatesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetPoints" => {
                    #[allow(non_camel_case_types)]
                    struct GetPointsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetPointsRequest>
                        for GetPointsSvc<T>
                    {
                        type Response = super::super::types::GetPointsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetPointsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_points(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPointsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/ProcessClicks" => {
                    #[allow(non_camel_case_types)]
                    struct ProcessClicksSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::ProcessClicksRequest>
                        for ProcessClicksSvc<T>
                    {
                        type Response = super::super::types::ProcessClicksResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::ProcessClicksRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::process_clicks(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ProcessClicksSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/PurchaseUpgrade" => {
                    #[allow(non_camel_case_types)]
                    struct PurchaseUpgradeSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::PurchaseUpgradeRequest>
                        for PurchaseUpgradeSvc<T>
                    {
                        type Response = super::super::types::PurchaseUpgradeResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::PurchaseUpgradeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::purchase_upgrade(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PurchaseUpgradeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/Bet" => {
                    #[allow(non_camel_case_types)]
                    struct BetSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::BetRequest> for BetSvc<T>
                    {
                        type Response = super::super::types::BetResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::BetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as ProverNetwork>::bet(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetContestDetails" => {
                    #[allow(non_camel_case_types)]
                    struct GetContestDetailsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetContestDetailsRequest>
                        for GetContestDetailsSvc<T>
                    {
                        type Response = super::super::types::GetContestDetailsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetContestDetailsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_contest_details(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetContestDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetLatestContest" => {
                    #[allow(non_camel_case_types)]
                    struct GetLatestContestSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetLatestContestRequest>
                        for GetLatestContestSvc<T>
                    {
                        type Response = super::super::types::GetLatestContestResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetLatestContestRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_latest_contest(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLatestContestSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetContestBettors" => {
                    #[allow(non_camel_case_types)]
                    struct GetContestBettorsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetContestBettorsRequest>
                        for GetContestBettorsSvc<T>
                    {
                        type Response = super::super::types::GetContestBettorsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetContestBettorsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_contest_bettors(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetContestBettorsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetGpuMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct GetGpuMetricsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetGpuMetricsRequest>
                        for GetGpuMetricsSvc<T>
                    {
                        type Response = super::super::types::GetGpuMetricsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetGpuMetricsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_gpu_metrics(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetGpuMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProverActivity" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProverActivitySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetFilteredProverActivityRequest,
                        > for GetFilteredProverActivitySvc<T>
                    {
                        type Response = super::super::types::GetFilteredProverActivityResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredProverActivityRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_prover_activity(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProverActivitySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverMetricsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetProverMetricsRequest>
                        for GetProverMetricsSvc<T>
                    {
                        type Response = super::super::types::GetProverMetricsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetProverMetricsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_metrics(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredBetHistory" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredBetHistorySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetFilteredBetHistoryRequest,
                        > for GetFilteredBetHistorySvc<T>
                    {
                        type Response = super::super::types::GetFilteredBetHistoryResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredBetHistoryRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_bet_history(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredBetHistorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetGpuTeamStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetGpuTeamStatsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetGpuTeamStatsRequest>
                        for GetGpuTeamStatsSvc<T>
                    {
                        type Response = super::super::types::GetGpuTeamStatsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetGpuTeamStatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_gpu_team_stats(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetGpuTeamStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetConfigValues" => {
                    #[allow(non_camel_case_types)]
                    struct GetConfigValuesSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetConfigValuesRequest>
                        for GetConfigValuesSvc<T>
                    {
                        type Response = super::super::types::GetConfigValuesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetConfigValuesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_config_values(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetConfigValuesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverStatsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetProverStatsRequest>
                        for GetProverStatsSvc<T>
                    {
                        type Response = super::super::types::GetProverStatsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetProverStatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_stats(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProverStats" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProverStatsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetFilteredProverStatsRequest,
                        > for GetFilteredProverStatsSvc<T>
                    {
                        type Response = super::super::types::GetFilteredProverStatsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredProverStatsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_prover_stats(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProverStatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverStatsDetail" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverStatsDetailSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetProverStatsDetailRequest,
                        > for GetProverStatsDetailSvc<T>
                    {
                        type Response = super::super::types::GetProverStatsDetailResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProverStatsDetailRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_stats_detail(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverStatsDetailSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverSearchResults" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverSearchResultsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetProverSearchResultsRequest,
                        > for GetProverSearchResultsSvc<T>
                    {
                        type Response = super::super::types::GetProverSearchResultsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProverSearchResultsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_search_results(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverSearchResultsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredBidHistory" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredBidHistorySvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetFilteredBidHistoryRequest,
                        > for GetFilteredBidHistorySvc<T>
                    {
                        type Response = super::super::types::GetFilteredBidHistoryResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredBidHistoryRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_bid_history(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredBidHistorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetTEEWhitelistStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetTEEWhitelistStatusSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetTeeWhitelistStatusRequest,
                        > for GetTEEWhitelistStatusSvc<T>
                    {
                        type Response = super::super::types::GetTeeWhitelistStatusResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetTeeWhitelistStatusRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_tee_whitelist_status(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTEEWhitelistStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetSettlementRequest" => {
                    #[allow(non_camel_case_types)]
                    struct GetSettlementRequestSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetSettlementRequestRequest,
                        > for GetSettlementRequestSvc<T>
                    {
                        type Response = super::super::types::GetSettlementRequestResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetSettlementRequestRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_settlement_request(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSettlementRequestSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredSettlementRequests" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredSettlementRequestsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetFilteredSettlementRequestsRequest,
                        > for GetFilteredSettlementRequestsSvc<T>
                    {
                        type Response = super::super::types::GetFilteredSettlementRequestsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredSettlementRequestsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_settlement_requests(
                                    &inner, request,
                                )
                                .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredSettlementRequestsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProvers" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProversSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetFilteredProversRequest>
                        for GetFilteredProversSvc<T>
                    {
                        type Response = super::super::types::GetFilteredProversResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetFilteredProversRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_provers(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProversSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetStakerStakeBalance" => {
                    #[allow(non_camel_case_types)]
                    struct GetStakerStakeBalanceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetStakerStakeBalanceRequest,
                        > for GetStakerStakeBalanceSvc<T>
                    {
                        type Response = super::super::types::GetStakerStakeBalanceResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetStakerStakeBalanceRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_staker_stake_balance(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetStakerStakeBalanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetProverStakeBalance" => {
                    #[allow(non_camel_case_types)]
                    struct GetProverStakeBalanceSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetProverStakeBalanceRequest,
                        > for GetProverStakeBalanceSvc<T>
                    {
                        type Response = super::super::types::GetProverStakeBalanceResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetProverStakeBalanceRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_prover_stake_balance(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProverStakeBalanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredStakerStakeBalanceLogs" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredStakerStakeBalanceLogsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetFilteredStakerStakeBalanceLogsRequest,
                        > for GetFilteredStakerStakeBalanceLogsSvc<T>
                    {
                        type Response =
                            super::super::types::GetFilteredStakerStakeBalanceLogsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredStakerStakeBalanceLogsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_staker_stake_balance_logs(
                                    &inner, request,
                                )
                                .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredStakerStakeBalanceLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredProverStakeBalanceLogs" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredProverStakeBalanceLogsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetFilteredProverStakeBalanceLogsRequest,
                        > for GetFilteredProverStakeBalanceLogsSvc<T>
                    {
                        type Response =
                            super::super::types::GetFilteredProverStakeBalanceLogsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredProverStakeBalanceLogsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_prover_stake_balance_logs(
                                    &inner, request,
                                )
                                .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredProverStakeBalanceLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/SetDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct SetDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::SetDelegationRequest>
                        for SetDelegationSvc<T>
                    {
                        type Response = super::super::types::SetDelegationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::SetDelegationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::set_delegation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetDelegation" => {
                    #[allow(non_camel_case_types)]
                    struct GetDelegationSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<super::super::types::GetDelegationRequest>
                        for GetDelegationSvc<T>
                    {
                        type Response = super::super::types::GetDelegationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::super::types::GetDelegationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_delegation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetDelegationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/network.ProverNetwork/GetFilteredWithdrawalReceipts" => {
                    #[allow(non_camel_case_types)]
                    struct GetFilteredWithdrawalReceiptsSvc<T: ProverNetwork>(pub Arc<T>);
                    impl<T: ProverNetwork>
                        tonic::server::UnaryService<
                            super::super::types::GetFilteredWithdrawalReceiptsRequest,
                        > for GetFilteredWithdrawalReceiptsSvc<T>
                    {
                        type Response = super::super::types::GetFilteredWithdrawalReceiptsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::types::GetFilteredWithdrawalReceiptsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ProverNetwork>::get_filtered_withdrawal_receipts(
                                    &inner, request,
                                )
                                .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFilteredWithdrawalReceiptsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    let mut response = http::Response::new(empty_body());
                    let headers = response.headers_mut();
                    headers.insert(
                        tonic::Status::GRPC_STATUS,
                        (tonic::Code::Unimplemented as i32).into(),
                    );
                    headers.insert(http::header::CONTENT_TYPE, tonic::metadata::GRPC_CONTENT_TYPE);
                    Ok(response)
                }),
            }
        }
    }
    impl<T> Clone for ProverNetworkServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "network.ProverNetwork";
    impl<T> tonic::server::NamedService for ProverNetworkServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
