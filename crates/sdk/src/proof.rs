#![allow(missing_docs)]

use std::{fmt::Debug, fs::File, path::Path};

use anyhow::Result;
use serde::{Deserialize, Serialize};
use sp1_core_executor::SP1ReduceProof;
use sp1_primitives::io::SP1PublicValues;
use sp1_prover::{CoreSC, Groth16Bn254Proof, InnerSC, PlonkBn254Proof};
use sp1_stark::ShardProof;
use strum_macros::{EnumDiscriminants, EnumTryAs};

/// A proof generated by the SP1 RISC-V zkVM.
#[derive(Debug, Clone, Serialize, Deserialize, EnumDiscriminants, EnumTryAs)]
#[strum_discriminants(derive(Default, Hash, PartialOrd, Ord))]
#[strum_discriminants(name(SP1ProofMode))]
pub enum SP1Proof {
    /// A proof generated by the core proof mode.
    ///
    /// The proof size scales linearly with the number of cycles.
    #[strum_discriminants(default)]
    Core(Vec<ShardProof<CoreSC>>),
    /// A proof generated by the compress proof mode.
    ///
    /// The proof size is constant, regardless of the number of cycles.
    Compressed(Box<SP1ReduceProof<InnerSC>>),
    /// A proof generated by the Plonk proof mode.
    Plonk(PlonkBn254Proof),
    /// A proof generated by the Groth16 proof mode.
    Groth16(Groth16Bn254Proof),
}

/// A proof generated by the SP1 RISC-V zkVM bundled together with the public values and the
/// version.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SP1ProofWithPublicValues {
    /// The raw proof generated by the SP1 RISC-V zkVM.
    pub proof: SP1Proof,
    /// The public values generated by the SP1 RISC-V zkVM.
    pub public_values: SP1PublicValues,
    /// The version of the SP1 RISC-V zkVM (not necessary but useful for detecting version
    /// mismatches).
    pub sp1_version: String,
}

impl SP1ProofWithPublicValues {
    /// Saves the proof to a path.
    pub fn save(&self, path: impl AsRef<Path>) -> Result<()> {
        bincode::serialize_into(File::create(path).expect("failed to open file"), self)
            .map_err(Into::into)
    }

    /// Loads a proof from a path.
    pub fn load(path: impl AsRef<Path>) -> Result<Self> {
        bincode::deserialize_from(File::open(path).expect("failed to open file"))
            .map_err(Into::into)
    }

    /// The proof in the byte encoding the onchain verifiers accepts for [`SP1ProofMode::Groth16`] and
    /// [`SP1ProofMode::Plonk`] proofs.
    ///
    /// # Details
    /// The bytes consist of the first four bytes of Groth16/Plonk vkey hash followed by the encoded
    /// proof, in a form optimized for onchain verification.
    #[must_use]
    pub fn bytes(&self) -> Vec<u8> {
        match &self.proof {
            SP1Proof::Plonk(plonk_proof) => {
                // If the proof is empty, then this is a mock proof. The mock SP1 verifier
                // expects an empty byte array for verification, so return an empty byte array.
                if plonk_proof.encoded_proof.is_empty() {
                    return Vec::new();
                }

                let proof_bytes =
                    hex::decode(&plonk_proof.encoded_proof).expect("Invalid Plonk proof");
                [plonk_proof.plonk_vkey_hash[..4].to_vec(), proof_bytes].concat()
            }
            SP1Proof::Groth16(groth16_proof) => {
                // If the proof is empty, then this is a mock proof. The mock SP1 verifier
                // expects an empty byte array for verification, so return an empty byte array.
                if groth16_proof.encoded_proof.is_empty() {
                    return Vec::new();
                }

                let proof_bytes =
                    hex::decode(&groth16_proof.encoded_proof).expect("Invalid Groth16 proof");
                [groth16_proof.groth16_vkey_hash[..4].to_vec(), proof_bytes].concat()
            }
            proof => panic!(
                "Proof type {:?} is not supported for onchain verification. \
                Only Plonk and Groth16 proofs are verifiable onchain",
                std::mem::discriminant(proof)
            ),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_plonk_proof_bytes() {
        let plonk_proof = SP1ProofWithPublicValues {
            proof: SP1Proof::Plonk(PlonkBn254Proof {
                encoded_proof: "ab".to_string(),
                plonk_vkey_hash: [0; 32],
                public_inputs: [String::new(), String::new()],
                raw_proof: String::new(),
            }),
            public_values: SP1PublicValues::new(),
            sp1_version: String::new(),
        };
        let expected_bytes = [vec![0, 0, 0, 0], hex::decode("ab").unwrap()].concat();
        assert_eq!(plonk_proof.bytes(), expected_bytes);
    }

    #[test]
    fn test_groth16_proof_bytes() {
        let groth16_proof = SP1ProofWithPublicValues {
            proof: SP1Proof::Groth16(Groth16Bn254Proof {
                encoded_proof: "ab".to_string(),
                groth16_vkey_hash: [0; 32],
                public_inputs: [String::new(), String::new()],
                raw_proof: String::new(),
            }),
            public_values: SP1PublicValues::new(),
            sp1_version: String::new(),
        };
        let expected_bytes = [vec![0, 0, 0, 0], hex::decode("ab").unwrap()].concat();
        assert_eq!(groth16_proof.bytes(), expected_bytes);
    }

    #[test]
    fn test_mock_plonk_proof_bytes() {
        let mock_plonk_proof = SP1ProofWithPublicValues {
            proof: SP1Proof::Plonk(PlonkBn254Proof {
                encoded_proof: String::new(),
                plonk_vkey_hash: [0; 32],
                public_inputs: [String::new(), String::new()],
                raw_proof: String::new(),
            }),
            public_values: SP1PublicValues::new(),
            sp1_version: String::new(),
        };
        assert_eq!(mock_plonk_proof.bytes(), Vec::<u8>::new());
    }

    #[test]
    fn test_mock_groth16_proof_bytes() {
        let mock_groth16_proof = SP1ProofWithPublicValues {
            proof: SP1Proof::Groth16(Groth16Bn254Proof {
                encoded_proof: String::new(),
                groth16_vkey_hash: [0; 32],
                public_inputs: [String::new(), String::new()],
                raw_proof: String::new(),
            }),
            public_values: SP1PublicValues::new(),
            sp1_version: String::new(),
        };
        assert_eq!(mock_groth16_proof.bytes(), Vec::<u8>::new());
    }

    #[test]
    #[should_panic(
        expected = "Proof type Discriminant(0) is not supported for onchain verification. Only Plonk and Groth16 proofs are verifiable onchain"
    )]
    fn test_core_proof_bytes_unimplemented() {
        let core_proof = SP1ProofWithPublicValues {
            proof: SP1Proof::Core(vec![]),
            public_values: SP1PublicValues::new(),
            sp1_version: String::new(),
        };
        println!("{:?}", core_proof.bytes());
    }
}
