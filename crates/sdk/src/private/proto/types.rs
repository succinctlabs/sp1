// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestProofRequest {
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RequestProofRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestProofRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The version of the prover to use.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// The mode for the request.
    #[prost(enumeration = "ProofMode", tag = "4")]
    pub mode: i32,
    /// The stdin resource identifier.
    #[prost(string, tag = "5")]
    pub stdin_uri: ::prost::alloc::string::String,
    /// The deadline for the request.
    #[prost(uint64, tag = "6")]
    pub deadline: u64,
    /// The cycle limit for the request.
    #[prost(uint64, tag = "7")]
    pub cycle_limit: u64,
    /// The gas limit for the request. If 0, the cycle_limit is used.
    #[prost(uint64, tag = "8")]
    pub gas_limit: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestProofResponse {
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "1")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The body of the response.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<RequestProofResponseBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestProofResponseBody {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestStatusRequest {
    /// The identifier for the request.
    #[prost(bytes = "vec", tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestStatusResponse {
    /// The fulfillment status of the request.
    #[prost(enumeration = "FulfillmentStatus", tag = "1")]
    pub fulfillment_status: i32,
    /// The execution status of the request.
    #[prost(enumeration = "ExecutionStatus", tag = "2")]
    pub execution_status: i32,
    /// The transaction hash of the request.
    #[prost(bytes = "vec", tag = "3")]
    pub request_tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The deadline of the request. A request should be ignored if it is past
    /// its deadline.
    #[prost(uint64, tag = "4")]
    pub deadline: u64,
    /// The optional transaction hash of the proof fulfill. Only included if the
    /// request has a fulfillment status of FULFILLED.
    #[prost(bytes = "vec", optional, tag = "5")]
    pub fulfill_tx_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The optional proof URI, where you can download the result of the request.
    /// Only included if the request has a fulfillment status of FULFILLED.
    #[prost(string, optional, tag = "6")]
    pub proof_presigned_url: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProgramExistsRequest {
    /// The verification key hash of the program.
    #[prost(bytes = "vec", tag = "1")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProgramExistsResponse {
    /// The program existance.
    #[prost(bool, tag = "1")]
    pub exists: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProgramRequest {
    /// The signature of the sender.
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The body of the request.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<CreateProgramRequestBody>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProgramRequestBody {
    /// The account nonce of the sender.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// The verification key hash.
    #[prost(bytes = "vec", tag = "2")]
    pub vk_hash: ::prost::alloc::vec::Vec<u8>,
    /// The program resource identifier.
    #[prost(string, tag = "3")]
    pub program_uri: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateProgramResponse {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProofMode {
    UnspecifiedProofMode = 0,
    /// The core proof mode.
    Core = 1,
    /// The compressed proof mode.
    Compressed = 2,
    /// The plonk proof mode.
    Plonk = 3,
    /// The groth16 proof mode.
    Groth16 = 4,
}
impl ProofMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedProofMode => "UNSPECIFIED_PROOF_MODE",
            Self::Core => "CORE",
            Self::Compressed => "COMPRESSED",
            Self::Plonk => "PLONK",
            Self::Groth16 => "GROTH16",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_PROOF_MODE" => Some(Self::UnspecifiedProofMode),
            "CORE" => Some(Self::Core),
            "COMPRESSED" => Some(Self::Compressed),
            "PLONK" => Some(Self::Plonk),
            "GROTH16" => Some(Self::Groth16),
            _ => None,
        }
    }
}
/// The different fulfillment statuses that a request can be in.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FulfillmentStatus {
    UnspecifiedFulfillmentStatus = 0,
    /// The request has been requested.
    Requested = 1,
    /// The request has been assigned to a fulfiller.
    Assigned = 2,
    /// The request has been fulfilled.
    Fulfilled = 3,
    /// The request cannot be fulfilled.
    Unfulfillable = 4,
}
impl FulfillmentStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedFulfillmentStatus => "UNSPECIFIED_FULFILLMENT_STATUS",
            Self::Requested => "REQUESTED",
            Self::Assigned => "ASSIGNED",
            Self::Fulfilled => "FULFILLED",
            Self::Unfulfillable => "UNFULFILLABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_FULFILLMENT_STATUS" => Some(Self::UnspecifiedFulfillmentStatus),
            "REQUESTED" => Some(Self::Requested),
            "ASSIGNED" => Some(Self::Assigned),
            "FULFILLED" => Some(Self::Fulfilled),
            "UNFULFILLABLE" => Some(Self::Unfulfillable),
            _ => None,
        }
    }
}
/// The different execution statuses that a request can be in.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecutionStatus {
    UnspecifiedExecutionStatus = 0,
    /// The request has not been executed.
    Unexecuted = 1,
    /// The request has been executed.
    Executed = 2,
    /// The request cannot be executed.
    Unexecutable = 3,
    /// The request was executed, but validation failed.
    ValidationFailed = 4,
}
impl ExecutionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedExecutionStatus => "UNSPECIFIED_EXECUTION_STATUS",
            Self::Unexecuted => "UNEXECUTED",
            Self::Executed => "EXECUTED",
            Self::Unexecutable => "UNEXECUTABLE",
            Self::ValidationFailed => "VALIDATION_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_EXECUTION_STATUS" => Some(Self::UnspecifiedExecutionStatus),
            "UNEXECUTED" => Some(Self::Unexecuted),
            "EXECUTED" => Some(Self::Executed),
            "UNEXECUTABLE" => Some(Self::Unexecutable),
            "VALIDATION_FAILED" => Some(Self::ValidationFailed),
            _ => None,
        }
    }
}
