// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReadyRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReadyResponse {
    #[prost(bool, tag = "1")]
    pub ready: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetupRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetupResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub result: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProveCoreRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProveCoreResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub result: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompressRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompressResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub result: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShrinkRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShrinkResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub result: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WrapRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WrapResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub result: ::prost::alloc::vec::Vec<u8>,
}
pub use twirp;
pub const SERVICE_FQN: &str = "/api.ProverService";
#[twirp::async_trait::async_trait]
pub trait ProverService {
    async fn setup(
        &self,
        ctx: twirp::Context,
        req: SetupRequest,
    ) -> Result<SetupResponse, twirp::TwirpErrorResponse>;
    async fn ready(
        &self,
        ctx: twirp::Context,
        req: ReadyRequest,
    ) -> Result<ReadyResponse, twirp::TwirpErrorResponse>;
    async fn prove_core(
        &self,
        ctx: twirp::Context,
        req: ProveCoreRequest,
    ) -> Result<ProveCoreResponse, twirp::TwirpErrorResponse>;
    async fn prove_core_stateless(
        &self,
        ctx: twirp::Context,
        req: ProveCoreRequest,
    ) -> Result<ProveCoreResponse, twirp::TwirpErrorResponse>;
    async fn compress(
        &self,
        ctx: twirp::Context,
        req: CompressRequest,
    ) -> Result<CompressResponse, twirp::TwirpErrorResponse>;
    async fn shrink(
        &self,
        ctx: twirp::Context,
        req: ShrinkRequest,
    ) -> Result<ShrinkResponse, twirp::TwirpErrorResponse>;
    async fn wrap(
        &self,
        ctx: twirp::Context,
        req: WrapRequest,
    ) -> Result<WrapResponse, twirp::TwirpErrorResponse>;
}
#[twirp::async_trait::async_trait]
impl<T> ProverService for std::sync::Arc<T>
where
    T: ProverService + Sync + Send,
{
    async fn setup(
        &self,
        ctx: twirp::Context,
        req: SetupRequest,
    ) -> Result<SetupResponse, twirp::TwirpErrorResponse> {
        T::setup(&*self, ctx, req).await
    }
    async fn ready(
        &self,
        ctx: twirp::Context,
        req: ReadyRequest,
    ) -> Result<ReadyResponse, twirp::TwirpErrorResponse> {
        T::ready(&*self, ctx, req).await
    }
    async fn prove_core(
        &self,
        ctx: twirp::Context,
        req: ProveCoreRequest,
    ) -> Result<ProveCoreResponse, twirp::TwirpErrorResponse> {
        T::prove_core(&*self, ctx, req).await
    }
    async fn prove_core_stateless(
        &self,
        ctx: twirp::Context,
        req: ProveCoreRequest,
    ) -> Result<ProveCoreResponse, twirp::TwirpErrorResponse> {
        T::prove_core_stateless(&*self, ctx, req).await
    }
    async fn compress(
        &self,
        ctx: twirp::Context,
        req: CompressRequest,
    ) -> Result<CompressResponse, twirp::TwirpErrorResponse> {
        T::compress(&*self, ctx, req).await
    }
    async fn shrink(
        &self,
        ctx: twirp::Context,
        req: ShrinkRequest,
    ) -> Result<ShrinkResponse, twirp::TwirpErrorResponse> {
        T::shrink(&*self, ctx, req).await
    }
    async fn wrap(
        &self,
        ctx: twirp::Context,
        req: WrapRequest,
    ) -> Result<WrapResponse, twirp::TwirpErrorResponse> {
        T::wrap(&*self, ctx, req).await
    }
}
pub fn router<T>(api: T) -> twirp::Router
where
    T: ProverService + Clone + Send + Sync + 'static,
{
    twirp::details::TwirpRouterBuilder::new(api)
        .route(
            "/Setup",
            |api: T, ctx: twirp::Context, req: SetupRequest| async move {
                api.setup(ctx, req).await
            },
        )
        .route(
            "/Ready",
            |api: T, ctx: twirp::Context, req: ReadyRequest| async move {
                api.ready(ctx, req).await
            },
        )
        .route(
            "/ProveCore",
            |api: T, ctx: twirp::Context, req: ProveCoreRequest| async move {
                api.prove_core(ctx, req).await
            },
        )
        .route(
            "/ProveCoreStateless",
            |api: T, ctx: twirp::Context, req: ProveCoreRequest| async move {
                api.prove_core_stateless(ctx, req).await
            },
        )
        .route(
            "/Compress",
            |api: T, ctx: twirp::Context, req: CompressRequest| async move {
                api.compress(ctx, req).await
            },
        )
        .route(
            "/Shrink",
            |api: T, ctx: twirp::Context, req: ShrinkRequest| async move {
                api.shrink(ctx, req).await
            },
        )
        .route(
            "/Wrap",
            |api: T, ctx: twirp::Context, req: WrapRequest| async move {
                api.wrap(ctx, req).await
            },
        )
        .build()
}
#[twirp::async_trait::async_trait]
pub trait ProverServiceClient: Send + Sync + std::fmt::Debug {
    async fn setup(
        &self,
        req: SetupRequest,
    ) -> Result<SetupResponse, twirp::ClientError>;
    async fn ready(
        &self,
        req: ReadyRequest,
    ) -> Result<ReadyResponse, twirp::ClientError>;
    async fn prove_core(
        &self,
        req: ProveCoreRequest,
    ) -> Result<ProveCoreResponse, twirp::ClientError>;
    async fn prove_core_stateless(
        &self,
        req: ProveCoreRequest,
    ) -> Result<ProveCoreResponse, twirp::ClientError>;
    async fn compress(
        &self,
        req: CompressRequest,
    ) -> Result<CompressResponse, twirp::ClientError>;
    async fn shrink(
        &self,
        req: ShrinkRequest,
    ) -> Result<ShrinkResponse, twirp::ClientError>;
    async fn wrap(&self, req: WrapRequest) -> Result<WrapResponse, twirp::ClientError>;
}
#[twirp::async_trait::async_trait]
impl ProverServiceClient for twirp::client::Client {
    async fn setup(
        &self,
        req: SetupRequest,
    ) -> Result<SetupResponse, twirp::ClientError> {
        self.request("api.ProverService/Setup", req).await
    }
    async fn ready(
        &self,
        req: ReadyRequest,
    ) -> Result<ReadyResponse, twirp::ClientError> {
        self.request("api.ProverService/Ready", req).await
    }
    async fn prove_core(
        &self,
        req: ProveCoreRequest,
    ) -> Result<ProveCoreResponse, twirp::ClientError> {
        self.request("api.ProverService/ProveCore", req).await
    }
    async fn prove_core_stateless(
        &self,
        req: ProveCoreRequest,
    ) -> Result<ProveCoreResponse, twirp::ClientError> {
        self.request("api.ProverService/ProveCoreStateless", req).await
    }
    async fn compress(
        &self,
        req: CompressRequest,
    ) -> Result<CompressResponse, twirp::ClientError> {
        self.request("api.ProverService/Compress", req).await
    }
    async fn shrink(
        &self,
        req: ShrinkRequest,
    ) -> Result<ShrinkResponse, twirp::ClientError> {
        self.request("api.ProverService/Shrink", req).await
    }
    async fn wrap(&self, req: WrapRequest) -> Result<WrapResponse, twirp::ClientError> {
        self.request("api.ProverService/Wrap", req).await
    }
}
